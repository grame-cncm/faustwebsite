{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is Faust? Faust (Functional Audio Stream) is a functional programming language for sound synthesis and audio processing with a strong focus on the design of synthesizers, musical instruments, audio effects, etc. Faust targets high-performance signal processing applications and audio plug-ins for a variety of platforms and standards. The core component of Faust is its compiler. It allows to \"translate\" any Faust digital signal processing (DSP) specification to a wide range of non-domain specific languages such as C++, C, LLVM bit code, WebAssembly, Rust, etc. In this regard, Faust can be seen as an alternative to C++ but is much simpler and intuitive to learn. Thanks to a wrapping system called \"architectures,\" codes generated by Faust can be easily compiled into a wide variety of objects ranging from audio plug-ins to standalone applications or smartphone and web apps, etc. The Faust Web IDE Getting Started If You're In a Hurry If you\u2019re in a hurry and just wanna have a look at how Faust programs look like, you can simply check the Faust Examples . If You Wanna Get Started With Faust If you\u2019re looking for a step by step tutorial of approximately 2 hours that will walk you through writing simple Faust programs and give you an overview of what Faust can do, have a look at our Quick Start Tutorial . If You\u2019re Looking For the \"Manual\" Faust\u2019s syntax and features are thoroughly documented in the Faust Manual . This resource contains hundreds of code examples and many short tutorials. If You\u2019re Looking For the Documentation of a Function In the Faust Libraries The documentation of Faust's standard libraries is automatically generated directly from the libraries' source code. If You Prefer Video Tutorials Check out the Faust Kadenze course . Faust News >> February 5, 2022: Open Science Award for Open Source Research Software for Faust Great birthday present for the 20th anniversary of the Faust language! Developed by Grame since 2002, supported by a whole community of users and contributors, Faust is one of the four winners of the Open Science Award for Open Source Research Software (documentation category) awarded at the Open Science European Conference (OSEC). >> February 1, 2021: Faust Physical Modeling Workshop -- Online Event Faust has been used for the physical modeling of musical instruments for many years now. Various tools have been developed recently to address the needs of various modeling techniques (e.g., finite difference scheme, waveguides, mass interaction, etc.). The goal of this one day workshop was to provide a series of interactive one-hour tutorials on these tools as well as some background on their related modeling techniques. It took place online on Feb. 1, 2021, 3-9pm GMT+1. Additional information about this event can be found here . >> November 21, 2020: Programmable Audio Workshop (PAW-20) -- Online Event With a combination of talks and workshops, PAW is an intensive day devoted to electronic sounds and programmable audio technologies! PAW-20 will be a fully online event. Information about the free registration process will be posted soon! PAW 2019 >> December 1-2, 2020: International Faust Conference 2020 (IFC-20) -- Online Event The Second International Faust Conference (IFC-20) will take place at the Maison des Sciences de l\u2019Homme Paris Nord (Saint-Denis, France) on December 1-2, 2020. It aims at gathering researchers, developers, musicians, computer artists using the Faust programming language to present current works, creations and projects and discuss future directions for Faust and its community. The 2020 edition is organized by the CICM (Centre de Recherches Informatique et Cr\u00e9ation Musicale) / MUSIDANSE Lab / Universit\u00e9 Paris 8. IFC 2018 >> FAST Project: Fast Audio Signal Processing Technologies on FPGA The FAST project will start in March 2021! It is funded by the Agence Nationale de la Recherche (ANR -- the French National Research Agency). It gathers the strength of GRAME-CNCM , CITI Lab (INSA Lyon) , and LMFA (\u00c9cole Centrale Lyon) towards two goals: facilitate the design of ultra-low latency embedded systems for real-time audio signal processing, use such systems in the context of active control of acoustics. Faust will play a central role in this project.","title":"Home"},{"location":"#what-is-faust","text":"Faust (Functional Audio Stream) is a functional programming language for sound synthesis and audio processing with a strong focus on the design of synthesizers, musical instruments, audio effects, etc. Faust targets high-performance signal processing applications and audio plug-ins for a variety of platforms and standards. The core component of Faust is its compiler. It allows to \"translate\" any Faust digital signal processing (DSP) specification to a wide range of non-domain specific languages such as C++, C, LLVM bit code, WebAssembly, Rust, etc. In this regard, Faust can be seen as an alternative to C++ but is much simpler and intuitive to learn. Thanks to a wrapping system called \"architectures,\" codes generated by Faust can be easily compiled into a wide variety of objects ranging from audio plug-ins to standalone applications or smartphone and web apps, etc. The Faust Web IDE","title":"What is Faust?"},{"location":"#getting-started","text":"","title":"Getting Started"},{"location":"#if-youre-in-a-hurry","text":"If you\u2019re in a hurry and just wanna have a look at how Faust programs look like, you can simply check the Faust Examples .","title":"If You're In a Hurry"},{"location":"#if-you-wanna-get-started-with-faust","text":"If you\u2019re looking for a step by step tutorial of approximately 2 hours that will walk you through writing simple Faust programs and give you an overview of what Faust can do, have a look at our Quick Start Tutorial .","title":"If You Wanna Get Started With Faust"},{"location":"#if-youre-looking-for-the-manual","text":"Faust\u2019s syntax and features are thoroughly documented in the Faust Manual . This resource contains hundreds of code examples and many short tutorials.","title":"If You\u2019re Looking For the \"Manual\""},{"location":"#if-youre-looking-for-the-documentation-of-a-function-in-the-faust-libraries","text":"The documentation of Faust's standard libraries is automatically generated directly from the libraries' source code.","title":"If You\u2019re Looking For the Documentation of a Function In the Faust Libraries"},{"location":"#if-you-prefer-video-tutorials","text":"Check out the Faust Kadenze course .","title":"If You Prefer Video Tutorials"},{"location":"#faust-news","text":"","title":"Faust News"},{"location":"#february-5-2022-open-science-award-for-open-source-research-software-for-faust","text":"Great birthday present for the 20th anniversary of the Faust language! Developed by Grame since 2002, supported by a whole community of users and contributors, Faust is one of the four winners of the Open Science Award for Open Source Research Software (documentation category) awarded at the Open Science European Conference (OSEC).","title":"&gt;&gt; February 5, 2022: Open Science Award for Open Source Research Software for Faust"},{"location":"#february-1-2021-faust-physical-modeling-workshop-online-event","text":"Faust has been used for the physical modeling of musical instruments for many years now. Various tools have been developed recently to address the needs of various modeling techniques (e.g., finite difference scheme, waveguides, mass interaction, etc.). The goal of this one day workshop was to provide a series of interactive one-hour tutorials on these tools as well as some background on their related modeling techniques. It took place online on Feb. 1, 2021, 3-9pm GMT+1. Additional information about this event can be found here .","title":"&gt;&gt; February 1, 2021: Faust Physical Modeling Workshop -- Online Event"},{"location":"#november-21-2020-programmable-audio-workshop-paw-20-online-event","text":"With a combination of talks and workshops, PAW is an intensive day devoted to electronic sounds and programmable audio technologies! PAW-20 will be a fully online event. Information about the free registration process will be posted soon! PAW 2019","title":"&gt;&gt; November 21, 2020: Programmable Audio Workshop (PAW-20) -- Online Event"},{"location":"#december-1-2-2020-international-faust-conference-2020-ifc-20-online-event","text":"The Second International Faust Conference (IFC-20) will take place at the Maison des Sciences de l\u2019Homme Paris Nord (Saint-Denis, France) on December 1-2, 2020. It aims at gathering researchers, developers, musicians, computer artists using the Faust programming language to present current works, creations and projects and discuss future directions for Faust and its community. The 2020 edition is organized by the CICM (Centre de Recherches Informatique et Cr\u00e9ation Musicale) / MUSIDANSE Lab / Universit\u00e9 Paris 8. IFC 2018","title":"&gt;&gt; December 1-2, 2020: International Faust Conference 2020 (IFC-20) -- Online Event"},{"location":"#fast-project-fast-audio-signal-processing-technologies-on-fpga","text":"The FAST project will start in March 2021! It is funded by the Agence Nationale de la Recherche (ANR -- the French National Research Agency). It gathers the strength of GRAME-CNCM , CITI Lab (INSA Lyon) , and LMFA (\u00c9cole Centrale Lyon) towards two goals: facilitate the design of ultra-low latency embedded systems for real-time audio signal processing, use such systems in the context of active control of acoustics. Faust will play a central role in this project.","title":"&gt;&gt; FAST Project: Fast Audio Signal Processing Technologies on FPGA"},{"location":"about/","text":"\u2039# The Faust Project The Faust Project has started in 2002. It is actively developped by the Grame Research Lab . Many persons are contributing to the Faust project, by providing code for the compiler, architecture files, libraries, examples, documentation, scripts, bug reports, ideas, etc. We would like in particular to thank: Fons Adriaensen, Karim Barkati, J\u00e9r\u00f4me Barth\u00e9lemy, Tim Blechmann, Tiziano Bole, Alain Bonardi, Thomas Charbonnel, Raffaele Ciavarella, Julien Colafrancesco, Damien Cramet, Sarah Denoux, \u00c9tienne Gaudrin, Olivier Guillerminet, Pierre Guillot, Albert Gr\u00e4f, Pierre Jouvelot, Stefan Kersten, Victor Lazzarini, Matthieu Leberre, Mathieu Leroi, Fernando Lopez-Lezcano, Kjetil Matheussen, Hermann Meyer, R\u00e9my Muller, Raphael Panis, Eliott Paris, Reza Payami, Laurent Pottier, Sampo Savolainen, Nicolas Scaringella, Anne Sedes, Priyanka Shekar, Stephen Sinclair, Travis Skare, Julius Smith, Mike Solomon, Michael Wilson, Bart Brouns, Dirk Roosenburg. as well as our colleagues at GRAME : Dominique Fober Christophe Lebreton St\u00e9phane Letz Romain Michon Yann Orlarey We would like also to thank for their financial support: the French Ministry of Culture , the Auvergne-Rh\u00f4ne-Alpes Region , the City of Lyon , the French National Research Agency (ANR) .","title":"About"},{"location":"downloads/","text":"Faust Downloads Faust comes in many different forms and it can be confusing to know what to install to start using this tool. We recommend you to have a look at the overview of the Faust universe section of the Faust manual . That being said, most of the features of Faust are accessible through the >> Faust Web IDE << so we recommend most people to use this tools which doesn't require any installation. Now, if you really wish to have a local version of Faust on your system, this page should give you an overview of the options that you have. Faust Compiler & libfaust Windows Look for the most recent Faust-XXX-win64.exe on: https://github.com/grame-cncm/faust/releases MacOS Look for the most recent Faust-XXX.dmg on: https://github.com/grame-cncm/faust/releases Linux Look for the most recent Faust-XXX.tar.gz on: https://github.com/grame-cncm/faust/releases Building Faust from the Source Alternatively, you might want to build Faust from scratch. For that you can either get the latest release of the Faust source or clone it from our GitRepo . Build instructions are available here . FaustLive FaustLive is an \"on-the-fly\" compiler for Faust (see the overview of the Faust universe for more information) allowing us to instantly run Faust programs. Windows Look for the most recent FaustLive-XXX-win64.exe on: https://github.com/grame-cncm/faustlive/releases MacOS Look for the most recent FaustLive-XXX.dmg on: https://github.com/grame-cncm/faustlive/releases Linux Look for the most recent FaustLive-XXX.tar.gz on: https://github.com/grame-cncm/faustlive/releases Building FaustLive from the Source Alternatively, you might want to build FaustLive from scratch. For that you can either get the latest release of the FaustLive source or clone it from our GitRepo . Faustgen Faustgen is a Max/MSP object to compile Faust code dynamically (see the overview of the Faust universe for more information). Windows Look for the most recent faustgen-XXX-win64.zip on: https://github.com/grame-cncm/faust/releases MacOS Look for the most recent faustgen-XXX-macosx.dmg on: https://github.com/grame-cncm/faust/releases FaustWorks FaustWorks is an IDE for the Faust compiler. It is not actively maintained and you should use Faust WEB IDE instead. The source code is available from the FaustWorks github repository","title":"Downloads"},{"location":"downloads/#faust-downloads","text":"Faust comes in many different forms and it can be confusing to know what to install to start using this tool. We recommend you to have a look at the overview of the Faust universe section of the Faust manual . That being said, most of the features of Faust are accessible through the >> Faust Web IDE << so we recommend most people to use this tools which doesn't require any installation. Now, if you really wish to have a local version of Faust on your system, this page should give you an overview of the options that you have.","title":"Faust Downloads"},{"location":"downloads/#faust-compiler-libfaust","text":"","title":"Faust Compiler &amp; libfaust"},{"location":"downloads/#windows","text":"Look for the most recent Faust-XXX-win64.exe on: https://github.com/grame-cncm/faust/releases","title":"Windows"},{"location":"downloads/#macos","text":"Look for the most recent Faust-XXX.dmg on: https://github.com/grame-cncm/faust/releases","title":"MacOS"},{"location":"downloads/#linux","text":"Look for the most recent Faust-XXX.tar.gz on: https://github.com/grame-cncm/faust/releases","title":"Linux"},{"location":"downloads/#building-faust-from-the-source","text":"Alternatively, you might want to build Faust from scratch. For that you can either get the latest release of the Faust source or clone it from our GitRepo . Build instructions are available here .","title":"Building Faust from the Source"},{"location":"downloads/#faustlive","text":"FaustLive is an \"on-the-fly\" compiler for Faust (see the overview of the Faust universe for more information) allowing us to instantly run Faust programs.","title":"FaustLive"},{"location":"downloads/#windows_1","text":"Look for the most recent FaustLive-XXX-win64.exe on: https://github.com/grame-cncm/faustlive/releases","title":"Windows"},{"location":"downloads/#macos_1","text":"Look for the most recent FaustLive-XXX.dmg on: https://github.com/grame-cncm/faustlive/releases","title":"MacOS"},{"location":"downloads/#linux_1","text":"Look for the most recent FaustLive-XXX.tar.gz on: https://github.com/grame-cncm/faustlive/releases","title":"Linux"},{"location":"downloads/#building-faustlive-from-the-source","text":"Alternatively, you might want to build FaustLive from scratch. For that you can either get the latest release of the FaustLive source or clone it from our GitRepo .","title":"Building FaustLive from the Source"},{"location":"downloads/#faustgen","text":"Faustgen is a Max/MSP object to compile Faust code dynamically (see the overview of the Faust universe for more information).","title":"Faustgen"},{"location":"downloads/#windows_2","text":"Look for the most recent faustgen-XXX-win64.zip on: https://github.com/grame-cncm/faust/releases","title":"Windows"},{"location":"downloads/#macos_2","text":"Look for the most recent faustgen-XXX-macosx.dmg on: https://github.com/grame-cncm/faust/releases","title":"MacOS"},{"location":"downloads/#faustworks","text":"FaustWorks is an IDE for the Faust compiler. It is not actively maintained and you should use Faust WEB IDE instead. The source code is available from the FaustWorks github repository","title":"FaustWorks"},{"location":"community/bugs/","text":"Reporting Bugs The best way to report a bug in Faust or in any of its associated tool is to submit an issue on the corresponding Git repository: Report a bug in the Faust Compiler , libfaust , faustgen or any other tool part of the Faust distribution Report a bug in the Faust Web Editor Report a bug in the Faust Web IDE Report a bug in the Faust Playground Report a bug in FaustLive Report a bug in FaustWorks Report a bug in the Faust Libraries Report a bug in the Faust Web Services Report a bug in the Faust Online Compiler Report a bug/typo on this website .","title":"Reporting Bugs"},{"location":"community/bugs/#reporting-bugs","text":"The best way to report a bug in Faust or in any of its associated tool is to submit an issue on the corresponding Git repository: Report a bug in the Faust Compiler , libfaust , faustgen or any other tool part of the Faust distribution Report a bug in the Faust Web Editor Report a bug in the Faust Web IDE Report a bug in the Faust Playground Report a bug in FaustLive Report a bug in FaustWorks Report a bug in the Faust Libraries Report a bug in the Faust Web Services Report a bug in the Faust Online Compiler Report a bug/typo on this website .","title":"Reporting Bugs"},{"location":"community/events/","text":"Events Faust Physical Modeling Workshop Faust has been used for the physical modeling of musical instruments for many years now. Different tools have been developed recently to address the needs of various modeling techniques (e.g., finite difference scheme, waveguides, mass interaction, etc.). The goal of this one day online workshop which took place on Feb. 1, 2021 was to provide a series of interactive one-hour tutorials on these tools as well as some background on their related modeling techniques. Creating Circuit-Bendable Wave-Digital Models of Analog Audio Circuits in Faust -- Dirk Roosenburg Download this workshop's code here Wave-digital models are a well researched and popular approach for creating virtual-analog models of audio circuits for use in audio processing. wdmodels.lib is a new addition to the Faust Libraries that supports easy creation of these models in Faust. In this workshop, we will introduce the technique of wave-digital modeling of circuits by analyzing several audio circuits and exploring their implementation in wdmodels.lib . We also will discuss library support of more complex implementation tasks associated with wave-digital models, such as R-type adaptors and Multiple/Multiport non-linearities. Finally, we will conclude by exploring the capacity of Faust to \"circuit-bend\" our wave-digital models. An Introduction to Mass-Interaction Modelling in Faust -- James Leonard and J\u00e9r\u00f4me Villeneuve Download this workshop's code here This workshop proposes an introduction to mass-interaction (sometimes referred to as mass-spring) modelling for sound synthesis in the Faust environment. After a brief historic introduction to this field, we will give a hands on tutorial on the mi_faust library, which allows simulating modular physical constructions in Faust, as well as online model scripting tools that allow for efficient model design and code generation. We will conclude with ongoing developments and perspectives, in particular regarding performance issues, possible extensions to 3-DoF physics, and the importance of modelling frameworks that allow for a creative approach to physical model design. Finite Difference Schemes Synthesis in Faust -- Riccardo Russo Download this workshop's code here Over the years, Faust proved to be a powerful tool for developing physical modeling synthesis. However, coding finite difference schemes models has always been complicated, in fact, their implementation in imperative programming languages is typically achieved using data structures, which are not available in Faust. This workshop will introduce the fds library, a new tool which allows to code linear, explicit finite difference schemes physical models in Faust, based on a cellular automata formalism. We will start with a brief introduction on how finite difference schemes work and what is their place within the scope physical modeling techniques. Then, we will focus on how to implement the algorithms we obtained on paper in Faust and, lastly, we will see how the fds library can be used to code such algorithms in a much easier way. By the end of the tutorial you should have quite an understanding on the basic principles of finite difference schemes, on the roles of the different functions inside the fds library and on how they can be used to easily obtain a working fds physical model. break Introduction to the Faust Physical Modeling Toolkit -- Romain Michon Download this workshop's code here A series of tools to facilitate the implementation of waveguide and modal physical models of musical instruments have been developed over the years by the Faust team to become the \"Faust Physical Modeling Toolkit.\" This comprises the Faust Physical Modeling library ( pm.lib ) as well as mesh2faust , a tool to convert 3D meshes into modal physical models compatible with pm.lib . During this workshop, we will provide a step-by-step tutorial on how to use these different tools to implement various kinds of physical models from scratch. Overview of Physical Modeling Formulations and Faust Implementations -- Julius O. Smith Download this workshop's code is available at https://ccrma.stanford.edu/~jos/aspf/Appendix_A_State_Space_Models.html#code:statespace and https://ccrma.stanford.edu/~jos/aspf/State_Space_BiQuad_FAUST.html#code:statespaceBiquad A summary of methods for physical modeling is followed by some examples in Faust. Physical models normally start out as differential equations which are then digitized to yield finite-difference schemes as were discussed earlier in this workshop. Wave digital and digital waveguide formulations were also discussed. Two additional topics are state-space models and modal representations which can be obtained by diagonalizing state-space models. As a result, this talk focuses primarily on state-space models and how to diagonalize them.","title":"Events"},{"location":"community/events/#events","text":"","title":"Events"},{"location":"community/events/#faust-physical-modeling-workshop","text":"Faust has been used for the physical modeling of musical instruments for many years now. Different tools have been developed recently to address the needs of various modeling techniques (e.g., finite difference scheme, waveguides, mass interaction, etc.). The goal of this one day online workshop which took place on Feb. 1, 2021 was to provide a series of interactive one-hour tutorials on these tools as well as some background on their related modeling techniques.","title":"Faust Physical Modeling Workshop"},{"location":"community/events/#creating-circuit-bendable-wave-digital-models-of-analog-audio-circuits-in-faust-dirk-roosenburg","text":"Download this workshop's code here Wave-digital models are a well researched and popular approach for creating virtual-analog models of audio circuits for use in audio processing. wdmodels.lib is a new addition to the Faust Libraries that supports easy creation of these models in Faust. In this workshop, we will introduce the technique of wave-digital modeling of circuits by analyzing several audio circuits and exploring their implementation in wdmodels.lib . We also will discuss library support of more complex implementation tasks associated with wave-digital models, such as R-type adaptors and Multiple/Multiport non-linearities. Finally, we will conclude by exploring the capacity of Faust to \"circuit-bend\" our wave-digital models.","title":"Creating Circuit-Bendable Wave-Digital Models of Analog Audio Circuits in Faust -- Dirk Roosenburg"},{"location":"community/events/#an-introduction-to-mass-interaction-modelling-in-faust-james-leonard-and-jerome-villeneuve","text":"Download this workshop's code here This workshop proposes an introduction to mass-interaction (sometimes referred to as mass-spring) modelling for sound synthesis in the Faust environment. After a brief historic introduction to this field, we will give a hands on tutorial on the mi_faust library, which allows simulating modular physical constructions in Faust, as well as online model scripting tools that allow for efficient model design and code generation. We will conclude with ongoing developments and perspectives, in particular regarding performance issues, possible extensions to 3-DoF physics, and the importance of modelling frameworks that allow for a creative approach to physical model design.","title":"An Introduction to Mass-Interaction Modelling in Faust -- James Leonard and J\u00e9r\u00f4me Villeneuve"},{"location":"community/events/#finite-difference-schemes-synthesis-in-faust-riccardo-russo","text":"Download this workshop's code here Over the years, Faust proved to be a powerful tool for developing physical modeling synthesis. However, coding finite difference schemes models has always been complicated, in fact, their implementation in imperative programming languages is typically achieved using data structures, which are not available in Faust. This workshop will introduce the fds library, a new tool which allows to code linear, explicit finite difference schemes physical models in Faust, based on a cellular automata formalism. We will start with a brief introduction on how finite difference schemes work and what is their place within the scope physical modeling techniques. Then, we will focus on how to implement the algorithms we obtained on paper in Faust and, lastly, we will see how the fds library can be used to code such algorithms in a much easier way. By the end of the tutorial you should have quite an understanding on the basic principles of finite difference schemes, on the roles of the different functions inside the fds library and on how they can be used to easily obtain a working fds physical model.","title":"Finite Difference Schemes Synthesis in Faust -- Riccardo Russo"},{"location":"community/events/#break","text":"","title":"break"},{"location":"community/events/#introduction-to-the-faust-physical-modeling-toolkit-romain-michon","text":"Download this workshop's code here A series of tools to facilitate the implementation of waveguide and modal physical models of musical instruments have been developed over the years by the Faust team to become the \"Faust Physical Modeling Toolkit.\" This comprises the Faust Physical Modeling library ( pm.lib ) as well as mesh2faust , a tool to convert 3D meshes into modal physical models compatible with pm.lib . During this workshop, we will provide a step-by-step tutorial on how to use these different tools to implement various kinds of physical models from scratch.","title":"Introduction to the Faust Physical Modeling Toolkit -- Romain Michon"},{"location":"community/events/#overview-of-physical-modeling-formulations-and-faust-implementations-julius-o-smith","text":"Download this workshop's code is available at https://ccrma.stanford.edu/~jos/aspf/Appendix_A_State_Space_Models.html#code:statespace and https://ccrma.stanford.edu/~jos/aspf/State_Space_BiQuad_FAUST.html#code:statespaceBiquad A summary of methods for physical modeling is followed by some examples in Faust. Physical models normally start out as differential equations which are then digitized to yield finite-difference schemes as were discussed earlier in this workshop. Wave digital and digital waveguide formulations were also discussed. Two additional topics are state-space models and modal representations which can be obtained by diagonalizing state-space models. As a result, this talk focuses primarily on state-space models and how to diagonalize them.","title":"Overview of Physical Modeling Formulations and Faust Implementations -- Julius O. Smith"},{"location":"community/help/","text":"Getting Help Faust Mailing Lists Mailing lists are by far the best way to reach out to the Faust community. If you have a question about the Faust language, the use of one of its associated tools (e.g., FaustLive, the web editor, etc.), or if you just want to follow the latest Faust news, please subscribe and ask your question to: the Faust Users Mailing List If you'd like to follow the development of Faust and of its associated tools and/or if you wish to contribute to it, please subscribe and ask your question to: the Faust Developers Mailing List Faust slack channel Slack is probably the fastest way to get help with Faust: https://faustaudio.slack.com . Faust discord channel The Audio Programmer community discord community has a #faust channel.","title":"Getting Help"},{"location":"community/help/#getting-help","text":"","title":"Getting Help"},{"location":"community/help/#faust-mailing-lists","text":"Mailing lists are by far the best way to reach out to the Faust community. If you have a question about the Faust language, the use of one of its associated tools (e.g., FaustLive, the web editor, etc.), or if you just want to follow the latest Faust news, please subscribe and ask your question to: the Faust Users Mailing List If you'd like to follow the development of Faust and of its associated tools and/or if you wish to contribute to it, please subscribe and ask your question to: the Faust Developers Mailing List","title":"Faust Mailing Lists"},{"location":"community/help/#faust-slack-channel","text":"Slack is probably the fastest way to get help with Faust: https://faustaudio.slack.com .","title":"Faust slack channel"},{"location":"community/help/#faust-discord-channel","text":"The Audio Programmer community discord community has a #faust channel.","title":"Faust discord channel"},{"location":"community/ifc/","text":"International Faust Conference (IFC) The International Faust Conference (IFC) takes place every two year. It aims at gathering developers and users of the Faust programming language to present current projects and discuss future directions for Faust and its community. Participants share their work through paper presentations. A series of round tables on various topics serve as a platform to brainstorm on Faust's features, semantics, tools, applications, etc. to determine future directions for this language. Open spaces for demos and workshops are usually available for participants to openly share their ongoing projects with the rest of the community. Next Edition: IFC-22 - June 7-8, 2022 - During SMC-22 at St-Etienne (France) The third edition of the International Faust Conference (IFC-22) will take place during SMC-22 at St-Etienne (France) on June 7-8, 2022. Past Editions IFC-20 - MSH Paris Nord Saint-Denis (France) The second edition of the International Faust Conference (IFC-20) took place at the Maison des Sciences de l\u2019Homme Paris Nord on December 1-2, 2020. IFC-18 - JGU, Mainz (Germany) The first edition of the International Faust Conference (IFC-18) took place at the Johannes Gutenberg University of Mainz (Germany) on July 17-18, 2018.","title":"Faust Conference"},{"location":"community/ifc/#international-faust-conference-ifc","text":"The International Faust Conference (IFC) takes place every two year. It aims at gathering developers and users of the Faust programming language to present current projects and discuss future directions for Faust and its community. Participants share their work through paper presentations. A series of round tables on various topics serve as a platform to brainstorm on Faust's features, semantics, tools, applications, etc. to determine future directions for this language. Open spaces for demos and workshops are usually available for participants to openly share their ongoing projects with the rest of the community.","title":"International Faust Conference (IFC)"},{"location":"community/ifc/#next-edition-ifc-22-june-7-8-2022-during-smc-22-at-st-etienne-france","text":"The third edition of the International Faust Conference (IFC-22) will take place during SMC-22 at St-Etienne (France) on June 7-8, 2022.","title":"Next Edition: IFC-22 - June 7-8, 2022 - During SMC-22 at St-Etienne (France)"},{"location":"community/ifc/#past-editions","text":"","title":"Past Editions"},{"location":"community/ifc/#ifc-20-msh-paris-nord-saint-denis-france","text":"The second edition of the International Faust Conference (IFC-20) took place at the Maison des Sciences de l\u2019Homme Paris Nord on December 1-2, 2020.","title":"IFC-20 - MSH Paris Nord Saint-Denis (France)"},{"location":"community/ifc/#ifc-18-jgu-mainz-germany","text":"The first edition of the International Faust Conference (IFC-18) took place at the Johannes Gutenberg University of Mainz (Germany) on July 17-18, 2018.","title":"IFC-18 - JGU, Mainz (Germany)"},{"location":"community/learning/","text":"Learning Faust Faust Kadenze Course In 2018, Yann Orlarey and Romain Michon shot an online course on the Kadenze platform on Real Time Audio Signal Processing in Faust . The videos of this course are free to watch online . Center for Computer Research in Music and Acoustics (CCRMA) Several courses on Faust are given at CCRMA: Julius Smith's Faust tutorial Romain Michon's Faust tutorials Music 250a (Physical Interaction Design for Music) course which hosts various tutorials on Faust and hardware Music 320c (Audio Plugin Development in Faust and C++) Embedded DSP With Faust Workshop TU Berlin The regular sound synthesis class at the Audio Communication Group, TU Berlin, makes use of Faust for exploring the basics of different synthesis algorithms. Student projects based on Faust include Eurorack modules, standalone drum machines and synthesizers, as well as data sonification approaches. The class is taught by Henrik von Coler , who is director of the Electronic Studio at the TU. HPI Potsdam The class Data Sonification & Opportunities of Sound at Hasso Plattner Institute, University of Potsdam Potsdam, is an interdisciplinary format, exploring the use of sonification and sound synthesis in the context of design thinking, neurosience and medical applications. The signal processing part is taught by Henrik von Coler . Universit\u00e9 Paris 8 A 24 hours introduction to Faust is given by Alain Bonardi during the first semester to undergraduated students (L3, 3rd year after the french 'baccalaur\u00e9at') in the framework of the course \"Programming Languages in Computer Music 1\" offered in the \"Music creation with computers\" minor. Universidad Nacional de Quilmes Cursos de Faust / DSP en espan\u0303ol, realizados por Juan Ramos . Incluyen las clases del \"Seminario de Actualizacio\u0301n en Sonido, Ciencia y Tecnologi\u0301a II\", dictado en la Universidad Nacional de Quilmes (Argentina) en 2021. Faust / DSP courses in Spanish, prepared by Juan Ramos . They include the classes of the \"Update Seminar on Sound, Science and Technology II\", held at the National University of Quilmes (Argentina) in 2021: An intro video is available here All available classes are located here Professional Masters of RIM & RAN The Professional RIM & RAN Masters are aimed at developing students applied knowledge and understanding of electronic and digital technologies for the creation, prepare them to the professions of Producer in Computer Music (RIM - R\u00e9alisateur en Informatique Musicale) and in Digital Arts (RAN - R\u00e9alisateur en Arts Num\u00e9riques) . These producers are direct actors in musical and artistic productions, and work at the interface between software developers, applied computer scientists, composers, artists, etc. and all people likely to integrate video, image and sound in their activities. Most of the courses concerning signal processing are given around the Faust language (M1 Romain Michon 12h / M2 Yann Orlarey 20h). Johannes Gutenberg University of Mainz To complete...","title":"Learning Faust"},{"location":"community/learning/#learning-faust","text":"","title":"Learning Faust"},{"location":"community/learning/#faust-kadenze-course","text":"In 2018, Yann Orlarey and Romain Michon shot an online course on the Kadenze platform on Real Time Audio Signal Processing in Faust . The videos of this course are free to watch online .","title":"Faust Kadenze Course"},{"location":"community/learning/#center-for-computer-research-in-music-and-acoustics-ccrma","text":"Several courses on Faust are given at CCRMA: Julius Smith's Faust tutorial Romain Michon's Faust tutorials Music 250a (Physical Interaction Design for Music) course which hosts various tutorials on Faust and hardware Music 320c (Audio Plugin Development in Faust and C++) Embedded DSP With Faust Workshop","title":"Center for Computer Research in Music and Acoustics (CCRMA)"},{"location":"community/learning/#tu-berlin","text":"The regular sound synthesis class at the Audio Communication Group, TU Berlin, makes use of Faust for exploring the basics of different synthesis algorithms. Student projects based on Faust include Eurorack modules, standalone drum machines and synthesizers, as well as data sonification approaches. The class is taught by Henrik von Coler , who is director of the Electronic Studio at the TU.","title":"TU Berlin"},{"location":"community/learning/#hpi-potsdam","text":"The class Data Sonification & Opportunities of Sound at Hasso Plattner Institute, University of Potsdam Potsdam, is an interdisciplinary format, exploring the use of sonification and sound synthesis in the context of design thinking, neurosience and medical applications. The signal processing part is taught by Henrik von Coler .","title":"HPI Potsdam"},{"location":"community/learning/#universite-paris-8","text":"A 24 hours introduction to Faust is given by Alain Bonardi during the first semester to undergraduated students (L3, 3rd year after the french 'baccalaur\u00e9at') in the framework of the course \"Programming Languages in Computer Music 1\" offered in the \"Music creation with computers\" minor.","title":"Universit\u00e9 Paris 8"},{"location":"community/learning/#universidad-nacional-de-quilmes","text":"Cursos de Faust / DSP en espan\u0303ol, realizados por Juan Ramos . Incluyen las clases del \"Seminario de Actualizacio\u0301n en Sonido, Ciencia y Tecnologi\u0301a II\", dictado en la Universidad Nacional de Quilmes (Argentina) en 2021. Faust / DSP courses in Spanish, prepared by Juan Ramos . They include the classes of the \"Update Seminar on Sound, Science and Technology II\", held at the National University of Quilmes (Argentina) in 2021: An intro video is available here All available classes are located here","title":"Universidad Nacional de Quilmes"},{"location":"community/learning/#professional-masters-of-rim-ran","text":"The Professional RIM & RAN Masters are aimed at developing students applied knowledge and understanding of electronic and digital technologies for the creation, prepare them to the professions of Producer in Computer Music (RIM - R\u00e9alisateur en Informatique Musicale) and in Digital Arts (RAN - R\u00e9alisateur en Arts Num\u00e9riques) . These producers are direct actors in musical and artistic productions, and work at the interface between software developers, applied computer scientists, composers, artists, etc. and all people likely to integrate video, image and sound in their activities. Most of the courses concerning signal processing are given around the Faust language (M1 Romain Michon 12h / M2 Yann Orlarey 20h).","title":"Professional Masters of RIM &amp; RAN"},{"location":"community/learning/#johannes-gutenberg-university-of-mainz","text":"To complete...","title":"Johannes Gutenberg University of Mainz"},{"location":"community/logos/","text":"Faust Logos The Faust logo is available in several variants (Full Logo, Simple Logo, Faust Award, and Made with Faust). The Adobe Illustrator file is available here Full Logo Very nice and trendy on your T-shirt... Blue White Grey Orange Simple Logo If you don't have too much space... Blue White Grey Orange Faust Awards And the winner is... Blue White Grey Orange Made with Faust For your next killer app... Blue White Grey Orange","title":"Logos"},{"location":"community/logos/#faust-logos","text":"The Faust logo is available in several variants (Full Logo, Simple Logo, Faust Award, and Made with Faust). The Adobe Illustrator file is available here","title":"Faust Logos"},{"location":"community/logos/#full-logo","text":"Very nice and trendy on your T-shirt...","title":"Full Logo"},{"location":"community/logos/#blue","text":"","title":"Blue"},{"location":"community/logos/#white","text":"","title":"White"},{"location":"community/logos/#grey","text":"","title":"Grey"},{"location":"community/logos/#orange","text":"","title":"Orange"},{"location":"community/logos/#simple-logo","text":"If you don't have too much space...","title":"Simple Logo"},{"location":"community/logos/#blue_1","text":"","title":"Blue"},{"location":"community/logos/#white_1","text":"","title":"White"},{"location":"community/logos/#grey_1","text":"","title":"Grey"},{"location":"community/logos/#orange_1","text":"","title":"Orange"},{"location":"community/logos/#faust-awards","text":"And the winner is...","title":"Faust Awards"},{"location":"community/logos/#blue_2","text":"","title":"Blue"},{"location":"community/logos/#white_2","text":"","title":"White"},{"location":"community/logos/#grey_2","text":"","title":"Grey"},{"location":"community/logos/#orange_2","text":"","title":"Orange"},{"location":"community/logos/#made-with-faust","text":"For your next killer app...","title":"Made with Faust"},{"location":"community/logos/#blue_3","text":"","title":"Blue"},{"location":"community/logos/#white_3","text":"","title":"White"},{"location":"community/logos/#grey_3","text":"","title":"Grey"},{"location":"community/logos/#orange_3","text":"","title":"Orange"},{"location":"community/made-with-faust/","text":"Powered With Faust This page lists the projects using Faust in different ways: musical pieces or artistic projects, plugins, standalone applications, integration in audio programming environments, development tools, research (possibly non musical) projects, embedded devices, Web applications, etc. Web Audio Modules Web Audio Modules are an open source framework facilitating the development of high-performance Web Audio plugins (instruments, realtime audio effects and MIDI processors). They can be developed using JavaScript and Web standards or compiled from C, C++ code, and domain-specific languages such as Faust or Csound. The Faust Web IDE contains an integrated GUI builder, read a tutorial here . Kapitonov Plugins Pack Set of 7 plugins for guitar sound processing, compiled in LADSPA and LV2 formats. Compatible with hosts such as Ardour, Qtractor, Carla, guitarix, jack-rack. The DSP of all of them is written in Faust. BioSignals BioSignals is a data aquisition and processing device for EMG, ECG and EEG signals. Since it is using the OpenWare firmware, it can be programmed with Faust. Scale it Scale it is an open source program (written in graphical programming language Pure data and in Faust) that allows sonification of a signal distribution in real time. There are two different possibilities of sonification of the signal. One of the objects, tone, generates changes in pitch of a monophonic tone. The other object, chord, expresses the input value in width of polyphony. Scale it is being developed primarily for neurofeedback purposes. To allow straightforward and customizable instruments to carry sonic feedback about EEG activity in specific regions of the neocortex. JackTrip JackTrip is a Linux, macOS, or Windows multi-machine audio system used for network music performance over the Internet. It supports any number of channels (as many as the computer/network can handle) of bidirectional, high quality, uncompressed audio signal streaming. Several DSP effects ( compressor , freeverb , zitarev , limiter ) are written in Faust, compiled as C++ code, and included in project sources . Level Rider This is an audio plugin written in Faust that automates gain level adjustments, based on a target gain level, a time window over which overall loudness is calculated via RMS, and a maximum adjustment threshold. This plugin is comparable to Waves Vocal Rider or Waves Bass Rider in its functionality, but is free and open-source. Whetstone Transient Shaper A free, open source transient shaping audio plugin that operates on a specified frequency band. Whetstone will extract a certain frequency band based on a low cutoff and high cutoff that you choose, apply transient shaping to it, and then reintegrate the shaped band back into the original signal. This plugin is meant to be comparable to the excellent Spiff plugin in its core functionality, but lacks many of the nice features and polished UI. The DSP is coded in Faust . Reverb Trickery A free, open source audio plugin implementing various creative reverb effects, including octave-shifted, distorted, hi-pass/low-passed, gated, and narrowing reverb, coded in Faust . b259wf This is a model of the \"tibre\" circuit of the Buchla 259 Complex Wave Generator, made in Faust . The model follows the circuit modelling as seen on the paper Virtual Analog Buchkla 259 wavefolder , using 5 folds. The proposed 2-point BLAMP antialiasing method has been attempted for arbitrary sources as shown here , but it is not sufficient for high frequencies and/or more complex signals. Instead, filtering and light cubic nonlinearity distiorion has been used to round corners and for clipping. The user interface consists of the controls fold for the folding amount, offset for offseting the signal before folding, and lowpass as a final stage one-pole filtering to control the character (too much folding might introduce unwanted higher harmonics for certain signals). The final output is dc-blocked. string-machine This is a virtual-analog string ensemble synthesizer. The implementation is based on a digital model designed by Peter Whiting. The improvement of the model adds various abilities, in particular a virtual-analog emulation of the bucket brigade delay circuit. Most of the DSP code is developed using Faust. Three VST or LV2 are generated: string-machine , string-machine-chorus and string-machine-chorus-stereo . metaFx The metaFx is a control surface for continuous sound transformations in real time, just like the metaSurface64. Like metaSurface64 , it has both its own loop generator and a multi-effects FX engine, but its operation is different, especially for the management of plugin chains and pads. Each mixer on this surface can directly control the gain and the attached plug-ins. It is also possible to control the tracks of an external sequencer (Ardour or Reaper). To do this, the application uses OSC controllable modules that come from the Faust language library that is embedded in the application. Its interest lies in the construction of a parallel sound processing chain in the form of a graph. Kymatica.com Jonatan Liljedahl at Kymatica AB makes iOS music apps, electronic music, and a little bit of audio hardware. The following iOS applications have DSP code developed using Faust: AU3FX:Push : AUv3 dynamics processor with noise gate, compressor/expander with external side-chain input, brick-wall look-ahead limiter and hard/soft clipper. AU3FX:Space : High quality tweakable AUv3 reverb with resonant filters. For everything between small rooms, resonators, and infinitely large spaces. AU3FX:Dub : Stereo AUv3 delay effect for everything from clean digital delays to filthy dub echoes, ping-pong flangers, and broken cassette tapes. AUFX:PeakQ : A versatile 4-band parametric stereo equalizer for everything between subtle frequency enhancements and agressive boosting/cutting or special resonator effects. Nemesis Nemesis is multichannel dsp platform for eurorack. It can be programmed with Faust . Sonobus SonoBus is an easy to use application for streaming high-quality, low-latency peer-to-peer audio between devices over the internet or a local network. Several DSP effects ( Compressor , Expander , Limiter , ParametricEQ , Reverb ) have been written in Faust , compiled as C++ code, and included in the JUCE project . XPlugs.lv2 This repository contain the LV2 plugins developed using libxputty/XUidesigner. The included makfile allows the build of all plugins against a single checkout of libxputty. Each plugin exists as its own submodule under this repository. Some of the DSP code has been written with Faust. Bass Preamp Drive The goal of this project is to digitally reproduce the behavior of a well-known electric bass preamp: Ampeg SVT3 Pro. This preamp has been copied by several manufacturers. So we have an almost perfect copy with the Bugera BVP5500 which has four preamplifier tubes. An analog copy is also available as a pedal, the Tech 21 BDDI. The project is based on advances in the simulation of analog circuits made available by the Guitarix project and the excellent Faust from Grame cncm. Drum Module This project aims at integrating a digital drum synthesizer using Faust and Miosix real time OS on an STM32F407VG Discovery Board. To do this, a user interface by means of buttons, sliders, encoders, and an LCD has been implemented to control the synthesizer. Moreover, a serial MIDI input port has been added in order to control the synthesizer externally by using an external sequencer or controller. Daisy based audio boards Daisy is an embedded platform for music. It features everything you need for creating high fidelity audio hardware devices. Just plug in a USB cable and start making sound! No soldering required. It can be programed with Faust using the faust2daisy tool. Elk Audio OS Elk is an Audio Operating System developed from the ground up to deliver real time audio performances in embedded systems and remote networks. It can run on several hardware . Faust can be used to generate VST2 plugins to run on the plaform. ER-301 Sound Computer The ER-301 is a voltage-controllable canvas for digital signal processing algorithms. It can be programed with Faust using the faust2er301 tool and some units are developed here . Note that it is still a WIP, read the discussion here . Zynthian platform Zynthian is a new class of musical device. A powerful multitimbral synthesizer and audio processor, capable of managing up to 16 audio chains simultaneously. Also, it's a MIDI processor and router, equipped with standard MIDI ports, USB, WIFI & wired networks. Zynthian is a community-driven project and it's 100% open source. The Zynthian platform can be programmed with Faust with some DSP examples here . GxPlugins.lv2 GxPlugins.lv2 is a set of more than 40 extra standalone lv2 plugins designed to compliment the Guitarix project. Each plugin exists as its own submodule under this repository. The DSP code has been written with Faust. Stone phaser A classic analog phaser effect. This is an analog phaser with similarity to the Small Stone. It has a color switch, which makes the phasing stronger when on, and adds some feedback controls. A stereo variant of the phaser is included. This effect is supported on MOD devices. The DSP code is developed in Faust . sfizz sfizz is a sample-based musical synthesizer. It features the well-established SFZ instrument format at its core, which permits to use existing instrument libraries, or create personal instruments with ease. Not only is sfizz ready-to-use as an instrument plugin of its own, the library allows developers to create instruments of their own, taking advantage of the abilities of SFZ. The sfizz project uses the SFZ parser and synth c++ library, providing AU / LV2 / VST3 plugins and JACK standalone client. Some effects are developed in Faust are well as several filters . Antescofo Antescofo is a coupling of a real-time listening machine with a reactive and timed synchronous language developed at IRCAM . The language is used for authoring of music pieces involving live musicians and computer processes, and the real-time system assures its correct performance and synchronization despite listening or performance errors. Antescofo audio DSP processes can be described with Faust , using libfaust dynamic version of the Faust compiler. Motion Vox A mobile music creation and performance workstation with a built-in motion-based controller, sequencer and synthesis engine. The controller unites XY pad, accelerometer and gyroscope events with complex data \ufb01ltering engine. Performance process consists of touching the active area on the screen with the index finger and moving the cursor while moving the device in space. Smartphone position in space and finger movement on a screen affect various parameters of sound or generate realtime MIDI output. The app was inspired by the SmartFaust project of GRAME. The audio engine of the app is made with FAUST. INScore INScore is an open source framework for the design of interactive, augmented, live music scores. Augmented music scores are graphic spaces providing representation, composition and manipulation of heterogeneous and arbitrary music objects (music scores but also images, text, signals...), both in the graphic and time domains. Audio DSP processes and effects can be described using Faust. The environment runs as a native application but also in the Web. Faust programs are only supported by the online version . Virtual Rhizome By Vincent Carinola . Virtual Rhizome responds to a proposal by Christophe Lebreton and Jean Geoffroy to compose a work for the original Smart Hand Computer system, developed at the GRAME-CNCM using the Faust language and allowing to play smartphones as an instrument. The work takes the form of a labyrinth, a kind of virtual architecture that could be compared to Borges' \"garden of branching paths\", within which the musician evolves by adapting his gestures to the constraints of different types of situations. Each situation is characterized by an autonomous functioning of the system, that the musician must apprehend in order to find the key allowing him to modify it and to move towards another situation. But in order to orientate himself well, he must create a mental representation of the structure of the work. The performer then becomes an explorer of a world that he unveils, but isn't that what he has always been? Virtual rhizome owes much to the availability and enthusiasm of Jean Geoffroy and Christophe Lebreton. It is amicably dedicated to them. SmartFaust SmartFaust is a concept of musical applications for smartphones. These applications have the particularity of only using the user's gestures and not by tapping on the device's screen. Made for iOS and Android, they can also use the motion sensors of these devices to make them real musical instruments. Smartfaust applications are based on the Faust (Functional Audio Stream) programming language developed by Grame over the last 15 years and recognized as a standard in the field of real-time signal processing for audio. The SmartFaust applications were first used for the creation of the pieces Mephisto (for drums and cell phone ensemble), Belzebuth (participative piece for public equipped with Smartphones), Iblis (for clarinet and cell phone ensemble) and B\u00e9lial (for harp and cell phone ensemble) written by the composer Xavier Garcia. From this same technology were later created the applications \"Geek Bagatelles\" (2016) and \"GameLan\" (2019). Download here: Android & iOS Trombone Simulator This simulator is a physical model of a trombone. Physical models of the lips, mouthpiece, slide, and bell are digitally simulated. The controls are listed at the top. The main controls are to move the cursor (or your finger on a touch device) left and right on the picture to adjust the embouchure, and up and down to extend and retract the slide. The diagonal colored lines are a guide to where the resonances are: playing over a resonance means that the embouchure and slide length are matched. Playing over white space means that one is between resonances and the note quality won't be as good. The big gray wedge on the upper right indicates that the resonances are very close together there. The vertical dashed lines indicate the rough locations of B-flat (thick lines) and F (thin lines). Other notes are unmarked, and likewise the slide positions. (Just like on a real trombone!) The off-key resonances (7th, 11th, 13th, and 14th) are marked in red. The g and f keys can be used to growl and flutter-tongue, respectively. The audio simulation is written in Faust, which conveniently compiles to WebAssembly and a Web Audio API wrapper. The overall approach used was a digital waveguide model, as described in J. O. Smith III's Digital Waveguide Theory. The lips and bell are adapted from F. Scott's masters thesis. Integrating 1-DoF force feedback interactions in self-contained DMIs By Mathias Kirkegaard . This thesis presents a system for designers of Digital Musical Instruments (DMIs) to explore the integration of 1 degree of freedom (DoF) force feedback interactions in new self-contained instruments. The system developed consists of an open-source graphical tool and a rotary force-feedback device made from commercially available components to facilitate the authoring of audio-haptic applications. Implementing an early prototype is used to inform the development of the graphical editing tool and its integration in an embedded audio-haptic environment using the functional programming language Faust for real-time signal processing. Beyond Key Velocity: Continuous Sensing for Expressive Control on the Hammond Organ and Digital Keyboards By Giulio Moro . In this thesis we seek to explore the potential for continuous key position to be used as an expressive control in keyboard musical instruments, and how pre- existing skills can be adapted to leverage this additional control. The nonlinear waveguide physical model of a flute has been developed in Faust. Guide de la synth\u00e8se sonore By Sebastien Clara . In this guide, I try to demystify how sound synthesis works. To do so, I present the fundamental principles of sound synthesis. I accompany these explanations with small sound applications that you can manipulate in your web browser and thus, you will be able to notice the impact of a parameter on the sound. Most of the sound examples are written in Faust and run in the web pages. This guide is currently only in french. PICO DSP PICO DSP is an open-source, Arduino-compatible ESP32 development board for audio and digital signal processing (DSP) applications. It offers an expansive audio-processing feature set on a small-format, breadboard-friendly device that provides audio inputs, audio outputs, a low-noise microphone array, an integrated test-speaker option, additional memory, battery-charge management, and ESD protection all on one tiny PCB. The board can be programmed using Faust . Soundjack The Soundjack realtime communication application is extended by a server cloud to handle up to 60 musicians of an orchestra, developed with the Faust programming language. Each musician is connected to a Soundjack UDP client. An individual stereo mix of the multiple audio streams originating from the multiple Soundjack clients has to be provided to each listening musician. An extended presentation of the system can be found in this IFC 2028 paper . studiox-switcher Studiox-switcher is an input switcher and silence detector for JACK. It can switch between 3 stereo inputs, a fallback channel is activated if the active input is below a volume threshold for some amount of seconds, and channels may be switched via OSC and HTTP. The core DSP engine is done via Faust for switching, silence detection and level metering. SynthSpace Synthspace is the ultimate virtual synthesizer. It combines the familiarity of real instruments with the possibilities of virtual worlds. Nodes for Synthspace can be developed in Faust . Bass21 This VST3 is a virtual-analog simulation of the famous Bass Driver DI Version 1 preamp pedal from Tech21. The discretization, while far from being exact, is moderately close to the original. The potentiometers are identical to these physically present on the BDDI pedal, apart from the pregain which is specific to this digital version. The DSP code is written in Faust. EchoMatrix The EchoMatrix was designed to provide some of the functionality of the Yamaha UD Stomp pedal as used be Alan Holdsworth. This project will be submitted to the KVR Developer Challenge 2021 contest to highlight the power of the Faust DSP development environment and the JUCE framework to create a non-trivial effect VST3 using a managable amount of Faust DSP code. The Striso board The Striso board is a very expressive music instrument which combines multidimensionally sensitive keys with an innovative note layout that helps understand the structures in music. The keys capture each subtle finger movement, which allows for levels of musical expression previously only known to acoustic instruments. Additionally, accents and sound effects can be added by shaking and moving the instrument as a whole. The internal sound is written in Faust, and is controlled directly by the signals from the keys and motion sensor. External synthesizers can be controlled using MPE MIDI, or using OSC which is easier to set up for Faust synthesizers. The firmware source code is released as open source. Live concatenative granular processing This algorithm addresses signal discontinuity and concatenation artefacts in real-time granular processing with rectangular windowing. By combining zero-crossing synchronicity, first-order derivative analysis, and Lagrange polynomials, we can generate streams of uncorrelated and non-overlapping sonic fragments with minimal low-order derivatives discontinuities. The resulting open-source algorithm, implemented in the Faust language, provides a versatile real-time software for dynamical looping, wavetable oscillation, and granulation with reduced artefacts due to rectangular windowing and no artefacts from overlap-add-to-one techniques commonly deployed in granular processing. fb_suppression ALS - Automatic Larsen Suppression algorithms implementing adaptive filtering through spectral centroid calculation, and adaptive frequency shifting through RMS calculation. ossia score Ossia score is a sequencer for audio-visual artists, designed to enable the creation of interactive shows, museum installations, intermedia digital artworks, interactive music and more in an intuitive user interface. Faust can be used to create advanced audio processes . A demo video of the Faust integration can be seen here . FASELUNARE Microcosmos Microcosmos is a small open-source electronic board, developed by \u200bFaselunare (Italy), aimed at prototyping electronic musical instruments and learning electronics, microcontroller programming and audio DSP, and programmable with Faust. A demo video of the project can be seen here . Audio Anywhere The goal of Audio Anywhere is to explore the idea of compile once, run anywhere for audio DSP code. Audio Anywhere combines Faust, for audio DSP code, and HTML5 to enable development of modern audio synthesis and effects tools. There are currently three main repos for this work: AA examples AA standalone app AA Wasmtime runtime The KeyWi An Expressive and Accessible Electronic Wind Instrument, where the sound is synthesized with Faust running on the Bela Mini processing board. React Web Audio Guitar Studio React Web Audio Guitar Studio is an online real-time Web Audio based all-in-one guitar studio, using native plugins written on Faust, compiled on-demand, and ran in a browser. JSPatcher JSPatcher is a Visual Programming Language (VPL) in Max/PureData style on the web. Customized AudioWorklet DSPs can be written with Faust. A presentation video can be seen here . Gwion Gwion is a programming language aimed at making music. It is strongly inspired by ChucK and can use a set of plugins for Gwion . One allows to use the libfaust library to JIT compile and run DSP code on the fly. The faust2gw tool allows to produce statically compiled modules. sonejostudios A set of tools written using Faust. Panoramix Stereo Panorama/Balance and Volume Automation Tool. Mixer4x A simple 4-channel stereo mixer. The main goal is to use it as a submixer on a 4 channel track, but you can use it everywhere you need a small 4 channel stereo mixer. faustdrumseq A very simple drum sequencer written with Faust, using the new soundfile object. MidiClockClick A simple metronom driven by MidiClock. SuperBeatRepeater Beat Repeater with Sidechain Beat Recognation and Midi-Clock Sync. Very useful i.e to add musical diversity by looping short parts of the stream (i.e drums). SuperCutSequencer Cut \"On/Off\" Sequencer (8 steps with smooth) synced to Midi-Clock Beats and Midi-Clock Start/Stop. Very useful i.e to add musical diversity in looped tracks (very nice with i.e bass lines). DeLooper Sample-accurate Looper/Delay with free mode and midi-clock sync mode. XYMatrix XY Surround Matrix for one Source (Mono Input) with 4 Outputs (Left, Right, Surround Left, Surround Right) and Position Lock. stm32-faust-synth STM32 synthesizer video is a short presentation of a polyphonic synthesizer based on STM32F405 \u00b5C. Faust is used for signal processing and a TLV320AIC23B stereo codec serves as DAC. Another more recent video is here . faustgen2~ The faustgen2~ object is a Faust external for Pd a.k.a. Pure Data , Miller Puckette's interactive multimedia programming environment. Amati Amati is a VST plugin for live-coding effects in the Faust programming language. As of now it only provides basic functionality. PureTones PureTones PureTones is a family of software tools for Indian Classical music. They are built based on an in-depth study and exploration of Indian Classical music to understand the role of harmonics, microtones and consonance in Indian Ragas and musical scales: PureTones Drone (using first tab) , is a digital Tanpura with controls for fine tuning the strings and adjusting their harmonic envelope. PureTones Musical Scale (using second tab) is a digital 12 note keyboard with controls for fine tuning each key to be consonant with an accompanying drone track. PureTones Sequencer (using third tab) is a sequencer which enables composition of melodies and musical works in Indian Classical music using notes from a fine tuned musical scale. The Ragatronics project combines Ragas from Indian Classical music with elements from Rock, Jazz and Electronic music. All applications have been developed using Faust and WebAudio tools. Making Sound Machines Making Sound Machines are a duo of makers from D\u00fcsseldorf, Germany. We build kits, modules and DIY projects, and use the projects we\u2019ve built to make music. Faust is used in several projects. master_me master_me is an automatic audio dynamics processor that smoothly balances sound during streaming events and live recordings. Preventing clipping and distortion, the software connects an effective leveling process with a mastering chain modeled after the analog audio path of Berlin-based Mastering Engineer Klaus Scheuermann. metaSurface64 metaSurface64 is a real-time continuous sound transformation control surface that features both its own loop generator for up to 64 voices and a multi-effects FX engine. The application embeds the libfaust dynamic version of the Faust compiler. Fragment Audio Server and Fragment Fragment Audio Server (FAS) is a high performance pixels-based graphical audio synthesizer implemented as a WebSocket server with the C language (C11). Faust , is embedded (when compiled with WITH_FAUST ) and allow to dynamically extend FAS bank generators and effects with custom one written with the Faust DSP specification language. FAS is the audio engine used in Fragment , the Collaborative Graphical Audio Synthesizer. Follow the demo here . Swanky Amp Swanky Amp is a tube amplifier simulation DSP plugin which aims to capture the details in the dynamics of tube amplifiers. The DSP is primarily written in Faust , whereas the UI is written in C++ using the JUCE . Follow the demo here . A commercial version is available here . Web Synth This is a web-based DAW (Digital Audio Workstation) written in Rust/WebAssembly and TypeScript with extensive Faust language integration with dynamic remote code compilation and executing via WebAssembly. Follow the demo here . DawDreamer DawDreamer is an audio-processing Python framework supporting core DAW features such as audio playback, VST MIDI instruments, VST effects, Faust , and parameter automation. DawDreamer is written with JUCE , with a user-friendly Python interface thanks to pybind11 . DawDreamer draws from an earlier VSTi audio \"renderer\", RenderMan . TouchDesigner TD-Faust enables Faust code to run inside TouchDesigner . Follow the demo here . Mephisto LV2 Mephisto LV2 a Just-in-Time Faust compiler embedded in an LV2 plugin. Write LV2 audio/cv instruments/filters directly in your host in Faust DSP language without any need to restart/reload host or plugin upon code changes. iPlug2 iPlug 2 is a simple-to-use C++ framework for developing cross platform audio plug-ins/apps and targeting multiple plug-in APIs with the same minimalistic code, support for the Faust programming language, and the libfaust JIT compiler. pMix pMix (short for preset mixer) is a sound design, composition and performance tool that facilitates the control of multiple parameters using an intuitive graphical interface. It includes a graphical patcher for creating a network of audio synthesis or processing nodes. A node could be a VST2, VST3, AU or LADSPA plug-in or it could a JIT compiled FAUST script. FAUST is a first class citizen in pMix and an integrated code editor and SVG display makes it a nice environment for FAUST development. Temper JUCE plugin Temper is a digital distortion audio plugin targeting VST, VST3, and AU for OS X and Windows. It builds upon traditional waveshaping techniques using modulated filter coefficients to produce a unique phase distortion. The primary signal processing loop is written with Faust, and compiled with JUCE for the various build targets. Faust Mass-Interaction mi_faust implements 1D mass-interaction models in the FAUST programming language. Starting from a scripted model description (see MIMS), mi_faust compiles a physical model into FAUST code. It handles this by generating routing functions between all the masses and all the interactions in the model. Head over to the FAUST community page to see examples of a series of instruments created in mi_faust, and available as web-apps ! Dynamic PedalBoard Dynamic PedalBoard allows users to plug different stompboxes together in a web browser. SHARC DSP Board The ADI SHARC DSP board fully supports Faust. Nuance Nuance is a pressure sensitive music controller that uses Faust for sound synthesis and processing. The PlateAxe The PlateAxe is a percussion instrument physical model controller using Faust for sound synthesis and processing. The BladeAxe The BladeAxe is an electric guitar physical model controller using Faust for sound synthesis and processing. Bart Brouns' Projects A collection of projects by Bart Brouns and based on Faust. EarTone Toolbox The Ear Tone Toolbox is a collection of unit generators for the production of auditory distortion product synthesis. AudioKit AudioKit allows developers to quickly add professional audio functionality to iOS, macOS, and Apple Watch apps. Radium Radium is a music editor with a new type of interface. It includes a Faust audio DSP development environment. Compared to the normal sequencer interface editing is quicker and more musical data fits on the screen. Compared to trackers, note positions and effects are edited graphically, which should be quicker, provide more vertical space and give a better musically overview. (Everything can also be edited by text, like in a normal tracker) Radium can also be used as a normal multitracker to mix and record audio. BELA Bela is a maker platform for creating beautifully responsive audio and interactive applications. Designed for artists, musicians, researchers and makers, Bela brings the power of ultra-low latency interactive audio and sensors to your digital projects. It can be programmed with Faust . HOA Library HOA Library allows musicians and composers to synthesize, transform and render sound fields in a creative and artistic way. This library facilitates the understanding and the appropriation of key concepts of ambisonics. Thanks to original graphical interfaces a lot of new signal processings are allowed like diffuse sound field synthesis, perspective distorsion or spatial filtering. HOA library is open-source and free and offers a set of C++ and FAUST classes and implementation for Max, PureData and Unity. Ambitools Ambitools is a collection of plug-ins and tools for 3D sound field synthesis using Higher Order Ambisonics (HOA). The plugins are written in the Faust language , which allows them to be compiled for a multitude of architectures and platforms (Windows, Mac, Linux, WebAudio, embedded systems, etc.) Moreover, the code is written in a scalable way: there is no limit to the maximum Ambisonic order! Other tools are also available, such as a 3D Visualizer written in the Processing language. Ambisonic Decoder Toolbox The Ambisonic Decoder Toolbox is a collection of MATLAB and GNU Octave functions for creating Ambisonic Decoders. Currently, it implements: (1) the AllRAD design technique, (2) inversion or mode-matching, (3) truncated mode-matching, constant energy, (4) linear combinations of 2 and 3, and (5) Slepian function basis (EPAD). The DSP code is written in MATLAB and Faust. Ambisonic.xyz A set of tools around Ambisonics. FaustPy FaustPy is a Python wrapper for Faust. It is implemented using the CFFI and hence creates the wrapper dynamically at run-time. Rebel Technology The OWL Pedal is an open source, programmable stage effects pedal, made for guitarists, musicians, hackers and programmers. Users can program their own effects, or download ready-made patches from our growing online patch library. faust-vst This project provides a VST plugin architecture for the Faust programming language. The package contains the Faust architecture, faustvst.cpp, the faust2faustvst helper script which provides a quick way to compile a plugin, a collection of sample plugins written in Faust, and a generic GNU Makefile for compiling and installing the plugins. faust-lv2 This project provides an LV2 plugin architecture for the Faust programming language. The package contains the Faust architecture and templates for the needed LV2 manifest (ttl) files, a collection of sample plugins written in Faust, and a generic GNU Makefile as well as a shell script to compile plugins using the architecture. RDK Reverb Design is about creating a spacial impression aimed at sweetening the listening experience for a given context. The ambiguity of auditory and visual cues in reproduced sound makes it necessary to create an auditory illusion: To make this illusion work, I propose an aesthetic concept of simplicity and intelligibility based on psychoacoustic facts and recording practice as professional producer. Foo YC20 The Foo YC20 is an open source implementation of the Yamaha YC-20 combo organ from 1969. Processing for the organ is based on original schematics and measurements from a working specimen. This instrument simulates the circutry as a whole to realisticly reproduce the features and flaws of the real deal. FaucK FaucK is a Chugin allowing to combine the powerful, succinct Functional AUdio STream (Faust) language with the strongly-timed ChucK audio programming language. FaucK allows programmers to on-the-fly evaluate Faust code directly from ChucK code and control Faust signal processors using ChucK's sample-precise timing and concurrency mechanisms. The goal is to create an amalgam that plays to the strengths of each language, giving rise to new possibilities for rapid prototyping, interaction design and controller mapping, pedagogy, and new ways of working with both Faust and ChucK. Snd-RT Snd-RT is the realtime extension for the sound editor SND and consists of two parts: the RT Engine - An engine for doing realtime signal processing. the RT Compiler - A compiler for a scheme-like programming language to generate realtime-safe code understood by the RT Engine. Pure Language [Pure is a modern-style functional programming language based on term rewriting. It offers equational definitions with pattern matching, full symbolic rewriting capabilities, dynamic typing, eager and lazy evaluation, lexical closures, built-in list and matrix support and an easy-to-use C interface. The interpreter uses LLVM as a backend to JIT-compile Pure programs to fast native code. It has been created by Albert Gr\u00e4f. pd-faust is a collection of Pd objects written using pd-pure which lets you run Faust programs inside Pd. It combines the functionality of pure-faust and faust2pd in a single package, and also features dynamic reloading of Faust plugins, automatic generation of controller GUIs and MIDI/OSC controller mappings, as well as OSC-based controller automation. It thus provides a complete solution for interactively developing Faust dsps in Pd. Guitarix An audio plug-in for guitar effects who's sound processing engine is written in Faust. moForte GeoShred An electric guitar app using physical modeling. Faust was used to implement its sound synthesis/processing engine. moForte PowerStomp An app implementing various guitar effects to be used on stage. moForte Guitar An app that can be used as an electric guitar and whose sound synthesis engine is implemented in Faust. FaustWorks An IDE for Faust. Allows Faust programmers to visualize block diagrams, corresponding C++ code, compile to various Faust targets, etc. FaustLive An on-the-fly compiler for the Faust programming language using the LLVM technology. \u200b","title":"Powered With Faust"},{"location":"community/made-with-faust/#powered-with-faust","text":"This page lists the projects using Faust in different ways: musical pieces or artistic projects, plugins, standalone applications, integration in audio programming environments, development tools, research (possibly non musical) projects, embedded devices, Web applications, etc.","title":"Powered With Faust"},{"location":"community/made-with-faust/#web-audio-modules","text":"Web Audio Modules are an open source framework facilitating the development of high-performance Web Audio plugins (instruments, realtime audio effects and MIDI processors). They can be developed using JavaScript and Web standards or compiled from C, C++ code, and domain-specific languages such as Faust or Csound. The Faust Web IDE contains an integrated GUI builder, read a tutorial here .","title":"Web Audio Modules"},{"location":"community/made-with-faust/#kapitonov-plugins-pack","text":"Set of 7 plugins for guitar sound processing, compiled in LADSPA and LV2 formats. Compatible with hosts such as Ardour, Qtractor, Carla, guitarix, jack-rack. The DSP of all of them is written in Faust.","title":"Kapitonov Plugins Pack"},{"location":"community/made-with-faust/#biosignals","text":"BioSignals is a data aquisition and processing device for EMG, ECG and EEG signals. Since it is using the OpenWare firmware, it can be programmed with Faust.","title":"BioSignals"},{"location":"community/made-with-faust/#scale-it","text":"Scale it is an open source program (written in graphical programming language Pure data and in Faust) that allows sonification of a signal distribution in real time. There are two different possibilities of sonification of the signal. One of the objects, tone, generates changes in pitch of a monophonic tone. The other object, chord, expresses the input value in width of polyphony. Scale it is being developed primarily for neurofeedback purposes. To allow straightforward and customizable instruments to carry sonic feedback about EEG activity in specific regions of the neocortex.","title":"Scale it"},{"location":"community/made-with-faust/#jacktrip","text":"JackTrip is a Linux, macOS, or Windows multi-machine audio system used for network music performance over the Internet. It supports any number of channels (as many as the computer/network can handle) of bidirectional, high quality, uncompressed audio signal streaming. Several DSP effects ( compressor , freeverb , zitarev , limiter ) are written in Faust, compiled as C++ code, and included in project sources .","title":"JackTrip"},{"location":"community/made-with-faust/#level-rider","text":"This is an audio plugin written in Faust that automates gain level adjustments, based on a target gain level, a time window over which overall loudness is calculated via RMS, and a maximum adjustment threshold. This plugin is comparable to Waves Vocal Rider or Waves Bass Rider in its functionality, but is free and open-source.","title":"Level Rider"},{"location":"community/made-with-faust/#whetstone-transient-shaper","text":"A free, open source transient shaping audio plugin that operates on a specified frequency band. Whetstone will extract a certain frequency band based on a low cutoff and high cutoff that you choose, apply transient shaping to it, and then reintegrate the shaped band back into the original signal. This plugin is meant to be comparable to the excellent Spiff plugin in its core functionality, but lacks many of the nice features and polished UI. The DSP is coded in Faust .","title":"Whetstone Transient Shaper"},{"location":"community/made-with-faust/#reverb-trickery","text":"A free, open source audio plugin implementing various creative reverb effects, including octave-shifted, distorted, hi-pass/low-passed, gated, and narrowing reverb, coded in Faust .","title":"Reverb Trickery"},{"location":"community/made-with-faust/#b259wf","text":"This is a model of the \"tibre\" circuit of the Buchla 259 Complex Wave Generator, made in Faust . The model follows the circuit modelling as seen on the paper Virtual Analog Buchkla 259 wavefolder , using 5 folds. The proposed 2-point BLAMP antialiasing method has been attempted for arbitrary sources as shown here , but it is not sufficient for high frequencies and/or more complex signals. Instead, filtering and light cubic nonlinearity distiorion has been used to round corners and for clipping. The user interface consists of the controls fold for the folding amount, offset for offseting the signal before folding, and lowpass as a final stage one-pole filtering to control the character (too much folding might introduce unwanted higher harmonics for certain signals). The final output is dc-blocked.","title":"b259wf"},{"location":"community/made-with-faust/#string-machine","text":"This is a virtual-analog string ensemble synthesizer. The implementation is based on a digital model designed by Peter Whiting. The improvement of the model adds various abilities, in particular a virtual-analog emulation of the bucket brigade delay circuit. Most of the DSP code is developed using Faust. Three VST or LV2 are generated: string-machine , string-machine-chorus and string-machine-chorus-stereo .","title":"string-machine"},{"location":"community/made-with-faust/#metafx","text":"The metaFx is a control surface for continuous sound transformations in real time, just like the metaSurface64. Like metaSurface64 , it has both its own loop generator and a multi-effects FX engine, but its operation is different, especially for the management of plugin chains and pads. Each mixer on this surface can directly control the gain and the attached plug-ins. It is also possible to control the tracks of an external sequencer (Ardour or Reaper). To do this, the application uses OSC controllable modules that come from the Faust language library that is embedded in the application. Its interest lies in the construction of a parallel sound processing chain in the form of a graph.","title":"metaFx"},{"location":"community/made-with-faust/#kymaticacom","text":"Jonatan Liljedahl at Kymatica AB makes iOS music apps, electronic music, and a little bit of audio hardware. The following iOS applications have DSP code developed using Faust: AU3FX:Push : AUv3 dynamics processor with noise gate, compressor/expander with external side-chain input, brick-wall look-ahead limiter and hard/soft clipper. AU3FX:Space : High quality tweakable AUv3 reverb with resonant filters. For everything between small rooms, resonators, and infinitely large spaces. AU3FX:Dub : Stereo AUv3 delay effect for everything from clean digital delays to filthy dub echoes, ping-pong flangers, and broken cassette tapes. AUFX:PeakQ : A versatile 4-band parametric stereo equalizer for everything between subtle frequency enhancements and agressive boosting/cutting or special resonator effects.","title":"Kymatica.com"},{"location":"community/made-with-faust/#nemesis","text":"Nemesis is multichannel dsp platform for eurorack. It can be programmed with Faust .","title":"Nemesis"},{"location":"community/made-with-faust/#sonobus","text":"SonoBus is an easy to use application for streaming high-quality, low-latency peer-to-peer audio between devices over the internet or a local network. Several DSP effects ( Compressor , Expander , Limiter , ParametricEQ , Reverb ) have been written in Faust , compiled as C++ code, and included in the JUCE project .","title":"Sonobus"},{"location":"community/made-with-faust/#xplugslv2","text":"This repository contain the LV2 plugins developed using libxputty/XUidesigner. The included makfile allows the build of all plugins against a single checkout of libxputty. Each plugin exists as its own submodule under this repository. Some of the DSP code has been written with Faust.","title":"XPlugs.lv2"},{"location":"community/made-with-faust/#bass-preamp-drive","text":"The goal of this project is to digitally reproduce the behavior of a well-known electric bass preamp: Ampeg SVT3 Pro. This preamp has been copied by several manufacturers. So we have an almost perfect copy with the Bugera BVP5500 which has four preamplifier tubes. An analog copy is also available as a pedal, the Tech 21 BDDI. The project is based on advances in the simulation of analog circuits made available by the Guitarix project and the excellent Faust from Grame cncm.","title":"Bass Preamp Drive"},{"location":"community/made-with-faust/#drum-module","text":"This project aims at integrating a digital drum synthesizer using Faust and Miosix real time OS on an STM32F407VG Discovery Board. To do this, a user interface by means of buttons, sliders, encoders, and an LCD has been implemented to control the synthesizer. Moreover, a serial MIDI input port has been added in order to control the synthesizer externally by using an external sequencer or controller.","title":"Drum Module"},{"location":"community/made-with-faust/#daisy-based-audio-boards","text":"Daisy is an embedded platform for music. It features everything you need for creating high fidelity audio hardware devices. Just plug in a USB cable and start making sound! No soldering required. It can be programed with Faust using the faust2daisy tool.","title":"Daisy based audio boards"},{"location":"community/made-with-faust/#elk-audio-os","text":"Elk is an Audio Operating System developed from the ground up to deliver real time audio performances in embedded systems and remote networks. It can run on several hardware . Faust can be used to generate VST2 plugins to run on the plaform.","title":"Elk Audio OS"},{"location":"community/made-with-faust/#er-301-sound-computer","text":"The ER-301 is a voltage-controllable canvas for digital signal processing algorithms. It can be programed with Faust using the faust2er301 tool and some units are developed here . Note that it is still a WIP, read the discussion here .","title":"ER-301 Sound Computer"},{"location":"community/made-with-faust/#zynthian-platform","text":"Zynthian is a new class of musical device. A powerful multitimbral synthesizer and audio processor, capable of managing up to 16 audio chains simultaneously. Also, it's a MIDI processor and router, equipped with standard MIDI ports, USB, WIFI & wired networks. Zynthian is a community-driven project and it's 100% open source. The Zynthian platform can be programmed with Faust with some DSP examples here .","title":"Zynthian platform"},{"location":"community/made-with-faust/#gxpluginslv2","text":"GxPlugins.lv2 is a set of more than 40 extra standalone lv2 plugins designed to compliment the Guitarix project. Each plugin exists as its own submodule under this repository. The DSP code has been written with Faust.","title":"GxPlugins.lv2"},{"location":"community/made-with-faust/#stone-phaser","text":"A classic analog phaser effect. This is an analog phaser with similarity to the Small Stone. It has a color switch, which makes the phasing stronger when on, and adds some feedback controls. A stereo variant of the phaser is included. This effect is supported on MOD devices. The DSP code is developed in Faust .","title":"Stone phaser"},{"location":"community/made-with-faust/#sfizz","text":"sfizz is a sample-based musical synthesizer. It features the well-established SFZ instrument format at its core, which permits to use existing instrument libraries, or create personal instruments with ease. Not only is sfizz ready-to-use as an instrument plugin of its own, the library allows developers to create instruments of their own, taking advantage of the abilities of SFZ. The sfizz project uses the SFZ parser and synth c++ library, providing AU / LV2 / VST3 plugins and JACK standalone client. Some effects are developed in Faust are well as several filters .","title":"sfizz"},{"location":"community/made-with-faust/#antescofo","text":"Antescofo is a coupling of a real-time listening machine with a reactive and timed synchronous language developed at IRCAM . The language is used for authoring of music pieces involving live musicians and computer processes, and the real-time system assures its correct performance and synchronization despite listening or performance errors. Antescofo audio DSP processes can be described with Faust , using libfaust dynamic version of the Faust compiler.","title":"Antescofo"},{"location":"community/made-with-faust/#motion-vox","text":"A mobile music creation and performance workstation with a built-in motion-based controller, sequencer and synthesis engine. The controller unites XY pad, accelerometer and gyroscope events with complex data \ufb01ltering engine. Performance process consists of touching the active area on the screen with the index finger and moving the cursor while moving the device in space. Smartphone position in space and finger movement on a screen affect various parameters of sound or generate realtime MIDI output. The app was inspired by the SmartFaust project of GRAME. The audio engine of the app is made with FAUST.","title":"Motion Vox"},{"location":"community/made-with-faust/#inscore","text":"INScore is an open source framework for the design of interactive, augmented, live music scores. Augmented music scores are graphic spaces providing representation, composition and manipulation of heterogeneous and arbitrary music objects (music scores but also images, text, signals...), both in the graphic and time domains. Audio DSP processes and effects can be described using Faust. The environment runs as a native application but also in the Web. Faust programs are only supported by the online version .","title":"INScore"},{"location":"community/made-with-faust/#virtual-rhizome","text":"By Vincent Carinola . Virtual Rhizome responds to a proposal by Christophe Lebreton and Jean Geoffroy to compose a work for the original Smart Hand Computer system, developed at the GRAME-CNCM using the Faust language and allowing to play smartphones as an instrument. The work takes the form of a labyrinth, a kind of virtual architecture that could be compared to Borges' \"garden of branching paths\", within which the musician evolves by adapting his gestures to the constraints of different types of situations. Each situation is characterized by an autonomous functioning of the system, that the musician must apprehend in order to find the key allowing him to modify it and to move towards another situation. But in order to orientate himself well, he must create a mental representation of the structure of the work. The performer then becomes an explorer of a world that he unveils, but isn't that what he has always been? Virtual rhizome owes much to the availability and enthusiasm of Jean Geoffroy and Christophe Lebreton. It is amicably dedicated to them.","title":"Virtual Rhizome"},{"location":"community/made-with-faust/#smartfaust","text":"SmartFaust is a concept of musical applications for smartphones. These applications have the particularity of only using the user's gestures and not by tapping on the device's screen. Made for iOS and Android, they can also use the motion sensors of these devices to make them real musical instruments. Smartfaust applications are based on the Faust (Functional Audio Stream) programming language developed by Grame over the last 15 years and recognized as a standard in the field of real-time signal processing for audio. The SmartFaust applications were first used for the creation of the pieces Mephisto (for drums and cell phone ensemble), Belzebuth (participative piece for public equipped with Smartphones), Iblis (for clarinet and cell phone ensemble) and B\u00e9lial (for harp and cell phone ensemble) written by the composer Xavier Garcia. From this same technology were later created the applications \"Geek Bagatelles\" (2016) and \"GameLan\" (2019). Download here: Android & iOS","title":"SmartFaust"},{"location":"community/made-with-faust/#trombone-simulator","text":"This simulator is a physical model of a trombone. Physical models of the lips, mouthpiece, slide, and bell are digitally simulated. The controls are listed at the top. The main controls are to move the cursor (or your finger on a touch device) left and right on the picture to adjust the embouchure, and up and down to extend and retract the slide. The diagonal colored lines are a guide to where the resonances are: playing over a resonance means that the embouchure and slide length are matched. Playing over white space means that one is between resonances and the note quality won't be as good. The big gray wedge on the upper right indicates that the resonances are very close together there. The vertical dashed lines indicate the rough locations of B-flat (thick lines) and F (thin lines). Other notes are unmarked, and likewise the slide positions. (Just like on a real trombone!) The off-key resonances (7th, 11th, 13th, and 14th) are marked in red. The g and f keys can be used to growl and flutter-tongue, respectively. The audio simulation is written in Faust, which conveniently compiles to WebAssembly and a Web Audio API wrapper. The overall approach used was a digital waveguide model, as described in J. O. Smith III's Digital Waveguide Theory. The lips and bell are adapted from F. Scott's masters thesis.","title":"Trombone Simulator"},{"location":"community/made-with-faust/#integrating-1-dof-force-feedback-interactions-in-self-contained-dmis","text":"By Mathias Kirkegaard . This thesis presents a system for designers of Digital Musical Instruments (DMIs) to explore the integration of 1 degree of freedom (DoF) force feedback interactions in new self-contained instruments. The system developed consists of an open-source graphical tool and a rotary force-feedback device made from commercially available components to facilitate the authoring of audio-haptic applications. Implementing an early prototype is used to inform the development of the graphical editing tool and its integration in an embedded audio-haptic environment using the functional programming language Faust for real-time signal processing.","title":"Integrating 1-DoF force feedback interactions in self-contained DMIs"},{"location":"community/made-with-faust/#beyond-key-velocity-continuous-sensing-for-expressive-control-on-the-hammond-organ-and-digital-keyboards","text":"By Giulio Moro . In this thesis we seek to explore the potential for continuous key position to be used as an expressive control in keyboard musical instruments, and how pre- existing skills can be adapted to leverage this additional control. The nonlinear waveguide physical model of a flute has been developed in Faust.","title":"Beyond Key Velocity: Continuous Sensing for Expressive Control on the Hammond Organ and Digital Keyboards"},{"location":"community/made-with-faust/#guide-de-la-synthese-sonore","text":"By Sebastien Clara . In this guide, I try to demystify how sound synthesis works. To do so, I present the fundamental principles of sound synthesis. I accompany these explanations with small sound applications that you can manipulate in your web browser and thus, you will be able to notice the impact of a parameter on the sound. Most of the sound examples are written in Faust and run in the web pages. This guide is currently only in french.","title":"Guide de la synth\u00e8se sonore"},{"location":"community/made-with-faust/#pico-dsp","text":"PICO DSP is an open-source, Arduino-compatible ESP32 development board for audio and digital signal processing (DSP) applications. It offers an expansive audio-processing feature set on a small-format, breadboard-friendly device that provides audio inputs, audio outputs, a low-noise microphone array, an integrated test-speaker option, additional memory, battery-charge management, and ESD protection all on one tiny PCB. The board can be programmed using Faust .","title":"PICO DSP"},{"location":"community/made-with-faust/#soundjack","text":"The Soundjack realtime communication application is extended by a server cloud to handle up to 60 musicians of an orchestra, developed with the Faust programming language. Each musician is connected to a Soundjack UDP client. An individual stereo mix of the multiple audio streams originating from the multiple Soundjack clients has to be provided to each listening musician. An extended presentation of the system can be found in this IFC 2028 paper .","title":"Soundjack"},{"location":"community/made-with-faust/#studiox-switcher","text":"Studiox-switcher is an input switcher and silence detector for JACK. It can switch between 3 stereo inputs, a fallback channel is activated if the active input is below a volume threshold for some amount of seconds, and channels may be switched via OSC and HTTP. The core DSP engine is done via Faust for switching, silence detection and level metering.","title":"studiox-switcher"},{"location":"community/made-with-faust/#synthspace","text":"Synthspace is the ultimate virtual synthesizer. It combines the familiarity of real instruments with the possibilities of virtual worlds. Nodes for Synthspace can be developed in Faust .","title":"SynthSpace"},{"location":"community/made-with-faust/#bass21","text":"This VST3 is a virtual-analog simulation of the famous Bass Driver DI Version 1 preamp pedal from Tech21. The discretization, while far from being exact, is moderately close to the original. The potentiometers are identical to these physically present on the BDDI pedal, apart from the pregain which is specific to this digital version. The DSP code is written in Faust.","title":"Bass21"},{"location":"community/made-with-faust/#echomatrix","text":"The EchoMatrix was designed to provide some of the functionality of the Yamaha UD Stomp pedal as used be Alan Holdsworth. This project will be submitted to the KVR Developer Challenge 2021 contest to highlight the power of the Faust DSP development environment and the JUCE framework to create a non-trivial effect VST3 using a managable amount of Faust DSP code.","title":"EchoMatrix"},{"location":"community/made-with-faust/#the-striso-board","text":"The Striso board is a very expressive music instrument which combines multidimensionally sensitive keys with an innovative note layout that helps understand the structures in music. The keys capture each subtle finger movement, which allows for levels of musical expression previously only known to acoustic instruments. Additionally, accents and sound effects can be added by shaking and moving the instrument as a whole. The internal sound is written in Faust, and is controlled directly by the signals from the keys and motion sensor. External synthesizers can be controlled using MPE MIDI, or using OSC which is easier to set up for Faust synthesizers. The firmware source code is released as open source.","title":"The Striso board"},{"location":"community/made-with-faust/#live-concatenative-granular-processing","text":"This algorithm addresses signal discontinuity and concatenation artefacts in real-time granular processing with rectangular windowing. By combining zero-crossing synchronicity, first-order derivative analysis, and Lagrange polynomials, we can generate streams of uncorrelated and non-overlapping sonic fragments with minimal low-order derivatives discontinuities. The resulting open-source algorithm, implemented in the Faust language, provides a versatile real-time software for dynamical looping, wavetable oscillation, and granulation with reduced artefacts due to rectangular windowing and no artefacts from overlap-add-to-one techniques commonly deployed in granular processing.","title":"Live concatenative granular processing"},{"location":"community/made-with-faust/#fb_suppression","text":"ALS - Automatic Larsen Suppression algorithms implementing adaptive filtering through spectral centroid calculation, and adaptive frequency shifting through RMS calculation.","title":"fb_suppression"},{"location":"community/made-with-faust/#ossia-score","text":"Ossia score is a sequencer for audio-visual artists, designed to enable the creation of interactive shows, museum installations, intermedia digital artworks, interactive music and more in an intuitive user interface. Faust can be used to create advanced audio processes . A demo video of the Faust integration can be seen here .","title":"ossia score"},{"location":"community/made-with-faust/#faselunare-microcosmos","text":"Microcosmos is a small open-source electronic board, developed by \u200bFaselunare (Italy), aimed at prototyping electronic musical instruments and learning electronics, microcontroller programming and audio DSP, and programmable with Faust. A demo video of the project can be seen here .","title":"FASELUNARE Microcosmos"},{"location":"community/made-with-faust/#audio-anywhere","text":"The goal of Audio Anywhere is to explore the idea of compile once, run anywhere for audio DSP code. Audio Anywhere combines Faust, for audio DSP code, and HTML5 to enable development of modern audio synthesis and effects tools. There are currently three main repos for this work: AA examples AA standalone app AA Wasmtime runtime","title":"Audio Anywhere"},{"location":"community/made-with-faust/#the-keywi","text":"An Expressive and Accessible Electronic Wind Instrument, where the sound is synthesized with Faust running on the Bela Mini processing board.","title":"The KeyWi"},{"location":"community/made-with-faust/#react-web-audio-guitar-studio","text":"React Web Audio Guitar Studio is an online real-time Web Audio based all-in-one guitar studio, using native plugins written on Faust, compiled on-demand, and ran in a browser.","title":"React Web Audio Guitar Studio"},{"location":"community/made-with-faust/#jspatcher","text":"JSPatcher is a Visual Programming Language (VPL) in Max/PureData style on the web. Customized AudioWorklet DSPs can be written with Faust. A presentation video can be seen here .","title":"JSPatcher"},{"location":"community/made-with-faust/#gwion","text":"Gwion is a programming language aimed at making music. It is strongly inspired by ChucK and can use a set of plugins for Gwion . One allows to use the libfaust library to JIT compile and run DSP code on the fly. The faust2gw tool allows to produce statically compiled modules.","title":"Gwion"},{"location":"community/made-with-faust/#sonejostudios","text":"A set of tools written using Faust.","title":"sonejostudios"},{"location":"community/made-with-faust/#panoramix","text":"Stereo Panorama/Balance and Volume Automation Tool.","title":"Panoramix"},{"location":"community/made-with-faust/#mixer4x","text":"A simple 4-channel stereo mixer. The main goal is to use it as a submixer on a 4 channel track, but you can use it everywhere you need a small 4 channel stereo mixer.","title":"Mixer4x"},{"location":"community/made-with-faust/#faustdrumseq","text":"A very simple drum sequencer written with Faust, using the new soundfile object.","title":"faustdrumseq"},{"location":"community/made-with-faust/#midiclockclick","text":"A simple metronom driven by MidiClock.","title":"MidiClockClick"},{"location":"community/made-with-faust/#superbeatrepeater","text":"Beat Repeater with Sidechain Beat Recognation and Midi-Clock Sync. Very useful i.e to add musical diversity by looping short parts of the stream (i.e drums).","title":"SuperBeatRepeater"},{"location":"community/made-with-faust/#supercutsequencer","text":"Cut \"On/Off\" Sequencer (8 steps with smooth) synced to Midi-Clock Beats and Midi-Clock Start/Stop. Very useful i.e to add musical diversity in looped tracks (very nice with i.e bass lines).","title":"SuperCutSequencer"},{"location":"community/made-with-faust/#delooper","text":"Sample-accurate Looper/Delay with free mode and midi-clock sync mode.","title":"DeLooper"},{"location":"community/made-with-faust/#xymatrix","text":"XY Surround Matrix for one Source (Mono Input) with 4 Outputs (Left, Right, Surround Left, Surround Right) and Position Lock.","title":"XYMatrix"},{"location":"community/made-with-faust/#stm32-faust-synth","text":"STM32 synthesizer video is a short presentation of a polyphonic synthesizer based on STM32F405 \u00b5C. Faust is used for signal processing and a TLV320AIC23B stereo codec serves as DAC. Another more recent video is here .","title":"stm32-faust-synth"},{"location":"community/made-with-faust/#faustgen2","text":"The faustgen2~ object is a Faust external for Pd a.k.a. Pure Data , Miller Puckette's interactive multimedia programming environment.","title":"faustgen2~"},{"location":"community/made-with-faust/#amati","text":"Amati is a VST plugin for live-coding effects in the Faust programming language. As of now it only provides basic functionality.","title":"Amati"},{"location":"community/made-with-faust/#puretones","text":"PureTones PureTones is a family of software tools for Indian Classical music. They are built based on an in-depth study and exploration of Indian Classical music to understand the role of harmonics, microtones and consonance in Indian Ragas and musical scales: PureTones Drone (using first tab) , is a digital Tanpura with controls for fine tuning the strings and adjusting their harmonic envelope. PureTones Musical Scale (using second tab) is a digital 12 note keyboard with controls for fine tuning each key to be consonant with an accompanying drone track. PureTones Sequencer (using third tab) is a sequencer which enables composition of melodies and musical works in Indian Classical music using notes from a fine tuned musical scale. The Ragatronics project combines Ragas from Indian Classical music with elements from Rock, Jazz and Electronic music. All applications have been developed using Faust and WebAudio tools.","title":"PureTones"},{"location":"community/made-with-faust/#making-sound-machines","text":"Making Sound Machines are a duo of makers from D\u00fcsseldorf, Germany. We build kits, modules and DIY projects, and use the projects we\u2019ve built to make music. Faust is used in several projects.","title":"Making Sound Machines"},{"location":"community/made-with-faust/#master_me","text":"master_me is an automatic audio dynamics processor that smoothly balances sound during streaming events and live recordings. Preventing clipping and distortion, the software connects an effective leveling process with a mastering chain modeled after the analog audio path of Berlin-based Mastering Engineer Klaus Scheuermann.","title":"master_me"},{"location":"community/made-with-faust/#metasurface64","text":"metaSurface64 is a real-time continuous sound transformation control surface that features both its own loop generator for up to 64 voices and a multi-effects FX engine. The application embeds the libfaust dynamic version of the Faust compiler.","title":"metaSurface64"},{"location":"community/made-with-faust/#fragment-audio-server-and-fragment","text":"Fragment Audio Server (FAS) is a high performance pixels-based graphical audio synthesizer implemented as a WebSocket server with the C language (C11). Faust , is embedded (when compiled with WITH_FAUST ) and allow to dynamically extend FAS bank generators and effects with custom one written with the Faust DSP specification language. FAS is the audio engine used in Fragment , the Collaborative Graphical Audio Synthesizer. Follow the demo here .","title":"Fragment Audio Server and Fragment"},{"location":"community/made-with-faust/#swanky-amp","text":"Swanky Amp is a tube amplifier simulation DSP plugin which aims to capture the details in the dynamics of tube amplifiers. The DSP is primarily written in Faust , whereas the UI is written in C++ using the JUCE . Follow the demo here . A commercial version is available here .","title":"Swanky Amp"},{"location":"community/made-with-faust/#web-synth","text":"This is a web-based DAW (Digital Audio Workstation) written in Rust/WebAssembly and TypeScript with extensive Faust language integration with dynamic remote code compilation and executing via WebAssembly. Follow the demo here .","title":"Web Synth"},{"location":"community/made-with-faust/#dawdreamer","text":"DawDreamer is an audio-processing Python framework supporting core DAW features such as audio playback, VST MIDI instruments, VST effects, Faust , and parameter automation. DawDreamer is written with JUCE , with a user-friendly Python interface thanks to pybind11 . DawDreamer draws from an earlier VSTi audio \"renderer\", RenderMan .","title":"DawDreamer"},{"location":"community/made-with-faust/#touchdesigner","text":"TD-Faust enables Faust code to run inside TouchDesigner . Follow the demo here .","title":"TouchDesigner"},{"location":"community/made-with-faust/#mephisto-lv2","text":"Mephisto LV2 a Just-in-Time Faust compiler embedded in an LV2 plugin. Write LV2 audio/cv instruments/filters directly in your host in Faust DSP language without any need to restart/reload host or plugin upon code changes.","title":"Mephisto LV2"},{"location":"community/made-with-faust/#iplug2","text":"iPlug 2 is a simple-to-use C++ framework for developing cross platform audio plug-ins/apps and targeting multiple plug-in APIs with the same minimalistic code, support for the Faust programming language, and the libfaust JIT compiler.","title":"iPlug2"},{"location":"community/made-with-faust/#pmix","text":"pMix (short for preset mixer) is a sound design, composition and performance tool that facilitates the control of multiple parameters using an intuitive graphical interface. It includes a graphical patcher for creating a network of audio synthesis or processing nodes. A node could be a VST2, VST3, AU or LADSPA plug-in or it could a JIT compiled FAUST script. FAUST is a first class citizen in pMix and an integrated code editor and SVG display makes it a nice environment for FAUST development.","title":"pMix"},{"location":"community/made-with-faust/#temper-juce-plugin","text":"Temper is a digital distortion audio plugin targeting VST, VST3, and AU for OS X and Windows. It builds upon traditional waveshaping techniques using modulated filter coefficients to produce a unique phase distortion. The primary signal processing loop is written with Faust, and compiled with JUCE for the various build targets.","title":"Temper JUCE plugin"},{"location":"community/made-with-faust/#faust-mass-interaction","text":"mi_faust implements 1D mass-interaction models in the FAUST programming language. Starting from a scripted model description (see MIMS), mi_faust compiles a physical model into FAUST code. It handles this by generating routing functions between all the masses and all the interactions in the model. Head over to the FAUST community page to see examples of a series of instruments created in mi_faust, and available as web-apps !","title":"Faust Mass-Interaction"},{"location":"community/made-with-faust/#dynamic-pedalboard","text":"Dynamic PedalBoard allows users to plug different stompboxes together in a web browser.","title":"Dynamic PedalBoard"},{"location":"community/made-with-faust/#sharc-dsp-board","text":"The ADI SHARC DSP board fully supports Faust.","title":"SHARC DSP Board"},{"location":"community/made-with-faust/#nuance","text":"Nuance is a pressure sensitive music controller that uses Faust for sound synthesis and processing.","title":"Nuance"},{"location":"community/made-with-faust/#the-plateaxe","text":"The PlateAxe is a percussion instrument physical model controller using Faust for sound synthesis and processing.","title":"The PlateAxe"},{"location":"community/made-with-faust/#the-bladeaxe","text":"The BladeAxe is an electric guitar physical model controller using Faust for sound synthesis and processing.","title":"The BladeAxe"},{"location":"community/made-with-faust/#bart-brouns-projects","text":"A collection of projects by Bart Brouns and based on Faust.","title":"Bart Brouns' Projects"},{"location":"community/made-with-faust/#eartone-toolbox","text":"The Ear Tone Toolbox is a collection of unit generators for the production of auditory distortion product synthesis.","title":"EarTone Toolbox"},{"location":"community/made-with-faust/#audiokit","text":"AudioKit allows developers to quickly add professional audio functionality to iOS, macOS, and Apple Watch apps.","title":"AudioKit"},{"location":"community/made-with-faust/#radium","text":"Radium is a music editor with a new type of interface. It includes a Faust audio DSP development environment. Compared to the normal sequencer interface editing is quicker and more musical data fits on the screen. Compared to trackers, note positions and effects are edited graphically, which should be quicker, provide more vertical space and give a better musically overview. (Everything can also be edited by text, like in a normal tracker) Radium can also be used as a normal multitracker to mix and record audio.","title":"Radium"},{"location":"community/made-with-faust/#bela","text":"Bela is a maker platform for creating beautifully responsive audio and interactive applications. Designed for artists, musicians, researchers and makers, Bela brings the power of ultra-low latency interactive audio and sensors to your digital projects. It can be programmed with Faust .","title":"BELA"},{"location":"community/made-with-faust/#hoa-library","text":"HOA Library allows musicians and composers to synthesize, transform and render sound fields in a creative and artistic way. This library facilitates the understanding and the appropriation of key concepts of ambisonics. Thanks to original graphical interfaces a lot of new signal processings are allowed like diffuse sound field synthesis, perspective distorsion or spatial filtering. HOA library is open-source and free and offers a set of C++ and FAUST classes and implementation for Max, PureData and Unity.","title":"HOA Library"},{"location":"community/made-with-faust/#ambitools","text":"Ambitools is a collection of plug-ins and tools for 3D sound field synthesis using Higher Order Ambisonics (HOA). The plugins are written in the Faust language , which allows them to be compiled for a multitude of architectures and platforms (Windows, Mac, Linux, WebAudio, embedded systems, etc.) Moreover, the code is written in a scalable way: there is no limit to the maximum Ambisonic order! Other tools are also available, such as a 3D Visualizer written in the Processing language.","title":"Ambitools"},{"location":"community/made-with-faust/#ambisonic-decoder-toolbox","text":"The Ambisonic Decoder Toolbox is a collection of MATLAB and GNU Octave functions for creating Ambisonic Decoders. Currently, it implements: (1) the AllRAD design technique, (2) inversion or mode-matching, (3) truncated mode-matching, constant energy, (4) linear combinations of 2 and 3, and (5) Slepian function basis (EPAD). The DSP code is written in MATLAB and Faust.","title":"Ambisonic Decoder Toolbox"},{"location":"community/made-with-faust/#ambisonicxyz","text":"A set of tools around Ambisonics.","title":"Ambisonic.xyz"},{"location":"community/made-with-faust/#faustpy","text":"FaustPy is a Python wrapper for Faust. It is implemented using the CFFI and hence creates the wrapper dynamically at run-time.","title":"FaustPy"},{"location":"community/made-with-faust/#rebel-technology","text":"The OWL Pedal is an open source, programmable stage effects pedal, made for guitarists, musicians, hackers and programmers. Users can program their own effects, or download ready-made patches from our growing online patch library.","title":"Rebel Technology"},{"location":"community/made-with-faust/#faust-vst","text":"This project provides a VST plugin architecture for the Faust programming language. The package contains the Faust architecture, faustvst.cpp, the faust2faustvst helper script which provides a quick way to compile a plugin, a collection of sample plugins written in Faust, and a generic GNU Makefile for compiling and installing the plugins.","title":"faust-vst"},{"location":"community/made-with-faust/#faust-lv2","text":"This project provides an LV2 plugin architecture for the Faust programming language. The package contains the Faust architecture and templates for the needed LV2 manifest (ttl) files, a collection of sample plugins written in Faust, and a generic GNU Makefile as well as a shell script to compile plugins using the architecture.","title":"faust-lv2"},{"location":"community/made-with-faust/#rdk","text":"Reverb Design is about creating a spacial impression aimed at sweetening the listening experience for a given context. The ambiguity of auditory and visual cues in reproduced sound makes it necessary to create an auditory illusion: To make this illusion work, I propose an aesthetic concept of simplicity and intelligibility based on psychoacoustic facts and recording practice as professional producer.","title":"RDK"},{"location":"community/made-with-faust/#foo-yc20","text":"The Foo YC20 is an open source implementation of the Yamaha YC-20 combo organ from 1969. Processing for the organ is based on original schematics and measurements from a working specimen. This instrument simulates the circutry as a whole to realisticly reproduce the features and flaws of the real deal.","title":"Foo YC20"},{"location":"community/made-with-faust/#fauck","text":"FaucK is a Chugin allowing to combine the powerful, succinct Functional AUdio STream (Faust) language with the strongly-timed ChucK audio programming language. FaucK allows programmers to on-the-fly evaluate Faust code directly from ChucK code and control Faust signal processors using ChucK's sample-precise timing and concurrency mechanisms. The goal is to create an amalgam that plays to the strengths of each language, giving rise to new possibilities for rapid prototyping, interaction design and controller mapping, pedagogy, and new ways of working with both Faust and ChucK.","title":"FaucK"},{"location":"community/made-with-faust/#snd-rt","text":"Snd-RT is the realtime extension for the sound editor SND and consists of two parts: the RT Engine - An engine for doing realtime signal processing. the RT Compiler - A compiler for a scheme-like programming language to generate realtime-safe code understood by the RT Engine.","title":"Snd-RT"},{"location":"community/made-with-faust/#pure-language","text":"[Pure is a modern-style functional programming language based on term rewriting. It offers equational definitions with pattern matching, full symbolic rewriting capabilities, dynamic typing, eager and lazy evaluation, lexical closures, built-in list and matrix support and an easy-to-use C interface. The interpreter uses LLVM as a backend to JIT-compile Pure programs to fast native code. It has been created by Albert Gr\u00e4f. pd-faust is a collection of Pd objects written using pd-pure which lets you run Faust programs inside Pd. It combines the functionality of pure-faust and faust2pd in a single package, and also features dynamic reloading of Faust plugins, automatic generation of controller GUIs and MIDI/OSC controller mappings, as well as OSC-based controller automation. It thus provides a complete solution for interactively developing Faust dsps in Pd.","title":"Pure Language"},{"location":"community/made-with-faust/#guitarix","text":"An audio plug-in for guitar effects who's sound processing engine is written in Faust.","title":"Guitarix"},{"location":"community/made-with-faust/#moforte-geoshred","text":"An electric guitar app using physical modeling. Faust was used to implement its sound synthesis/processing engine.","title":"moForte GeoShred"},{"location":"community/made-with-faust/#moforte-powerstomp","text":"An app implementing various guitar effects to be used on stage.","title":"moForte PowerStomp"},{"location":"community/made-with-faust/#moforte-guitar","text":"An app that can be used as an electric guitar and whose sound synthesis engine is implemented in Faust.","title":"moForte Guitar"},{"location":"community/made-with-faust/#faustworks","text":"An IDE for Faust. Allows Faust programmers to visualize block diagrams, corresponding C++ code, compile to various Faust targets, etc.","title":"FaustWorks"},{"location":"community/made-with-faust/#faustlive","text":"An on-the-fly compiler for the Faust programming language using the LLVM technology. \u200b","title":"FaustLive"},{"location":"community/news/","text":"Faust News 2018-07-23: Faust's Evolution View the evolution of the Faust project from 2004 to 2018. The visualization was done using Gource . Here is the command used (as suggested by fullybacked ): gource --hide dirnames,filenames --seconds-per-day 0.1 --auto-skip-seconds 1 -1920x1024 -o - | ffmpeg -y -r 60 -f image2pipe -vcodec ppm -i - -vcodec libx264 -preset ultrafast -pix_fmt yuv420p -crf 1 -threads 0 -bf 0 faust-hd.mp4 2018-07-23: Faust Award 2018 The Faust Open Source Software Competition aims at promoting innovative high-quality free audio software developed with Faust, a functional programming language for realtime signal processing and sound synthesis. The competition is sponsored by GRAME , Centre National de Cr\u00e9ation Musicale. Faust Award 2018 to iPlug 2 The Faust Award 2018 was attributed by an international committee composed of : Jean-Louis Giavitto (IRCAM, Paris, France), Albert Graef (Johannes Gutenberg U., Mainz, Germany), Pierre Jouvelot (Ecole des Mines, Paris, France), Victor Lazzarini (Maynooth U., Maynooth, Ireland), Romain Michon (Stanford U., Palo Alto, USA) Yann Orlarey (GRAME, Lyon, France), Laurent Pottier (U. Jean Monnet, Saint-Etienne, France), Julius Smith (Stanford U., Palo Alto, USA) to iPlug 2 a free open source C++ audio plug-in framework, allowing developers to create audio plug-ins and apps across a wide range of formats from the same code, including graphical user interface and DSP components. Amongst many other new features and a reworked code base, version 2 includes support for FAUST, allowing sections of audio DSP to be implemented using the FAUST language, and easily integrated with other C++ elements. iPlug 2 is developed by Oliver Larkin and Alex Harker from the original iPlug, by Cockos inc. that was open sourced in 2008. The project is under active development and will be publicly released at the end of 2018. The jury praised the quality, the ambition, and the usefulness of iPlug 2 as a Faust development framework! Check the demo here . We hope that the Faust Award will help the authors to fully finalize the project. Faust Student Software Competition to Cloud Generator In parallel to the main competition, the Faust Student Software Competition , is intended to promote small, but innovative Faust applications, typically developed in the framework of student projects. The student prize 2018 was awarded to Cloud Generator a nine-voice polyphonic synthesizer developed by Rittik Wystup. The jury praised the audio quality and the care taken by Rittik Wystup in his project! Check the Cloud Generator demo here . 2018-07-10: International Faust Conference 2018 International Faust Conference IFC18 : July 17-18, 2018 The International Faust Conference IFC18 will take place at the Johannes Gutenberg University of Mainz (Germany) on July 17-18, 2018. It aims at gathering developers and users of the Faust programming language to present current projects and discuss future directions for Faust and its community. Participants will be able to share their work through paper presentations. A series of round tables on various topics will serve as a platform to brainstorm on Faust's features, semantics, tools, applications, etc. to determine future directions for this language. Open spaces for demos and workshops will be available for participants to openly share their ongoing projects with the rest of the community. As a special event, the winner of GRAME's Faust Open-Source Software Competition will be announced during IFC18 . IFC-18 is free and everyone is welcome to attend! Please register here 2018-02-18: Faust Award 2018 Faust Award 2018: deadline June 1, 2018 The Faust Open-Source Software Competition is intended to promote innovative high-quality free audio software developed with the Faust programming language, as well as development tools built around the Faust compiler itself. The Faust Open-Source Software award will be attributed to the best submission by an international committee of leading experts in the field. The competition is sponsored by Grame, centre national de cr\u00e9ation musicale. The winning software will receive a 2000\u20ac price to encourage its authors. The results will be announced July 17, 2018 during the International Faust Conference in Mainz IFC18 . To participate, the software must be provided with source code and licensed with a Free/Open Source license. A substantial part of the software must be written in Faust and the Faust source code must be provided. As part of the review process, the software will be built from the sources. All source code, license, video demonstration, installation instructions, and any other documentation must be available on a public web page. License compatibility with other open source software is encouraged. Dependencies on non-open source third-party software are discouraged, with the exception of operating systems and freely available commercial packages. Authors are required to prepare a video demonstrating the software. This video must be done carefully, and should convincingly present the qualities of the software. The submission must also contain any useful documentation, including examples of how the provided software might be used, existing prototypes that use the software, download statistics or other public usage information. The criteria for judging submissions includes broad applicability and potential impact, novelty, technical depth, reusability, etc. Junior Competition In parallel to the Faust Open-Source Software Competition we have a junior competition, the Faust Student Software Competition, with a 200\u20ac prize for the winner. The Faust Student Software Competition is intended to promote interesting audio processing and synthesis applications written in Faust in a single file in less than 1000 words. The word count is done after removing the comments from the code: cat foo.dsp | stripcmt | wc -w. The use of the standard Faust libraries is strongly encouraged. They don't take part in the word count. Important dates Start of the competition: February 18, 2018 Software Submission Deadline: June 1, 2018 Results of the competition: July 17, 2018 Submission Guidelines Authors interested in participating in the Faust Open Source Software Competition or the Faust Student Software Competition should send a submission email to faustaward@grame.fr with a PDF file attached containing the following information: Title of submission, Category of submission ( Faust Open Source Software Competition or Faust Student Software Competition ), Name, email and affiliation of the main author, Names, emails and affiliations of other authors, A permanent link for the open source software (e.g., Sourceforge, GitHub, Google Code, etc.), A permanent link for the video demonstration (e.g., YouTube, Vimeo, etc.), A link to a compressed archive file that contains the software (source code, documentation, build/install instructions, and licenses). Comprehensive and clear build/install instructions will be a crucial component of any submission. The committee will make a reasonable effort to build the software for the top contributions, but if they are unable to make the software run, it will be excluded from the competition. International Committee Jean-Louis Giavitto (IRCAM, Paris, France), Albert Gr\u00e4f (Johannes Gutenberg U., Mainz, Germany), Pierre Jouvelot (Ecole des Mines, Paris, France), Victor Lazzarini (Maynooth U., Maynooth, Ireland), Romain Michon (CCRMA, Stanford , USA) Yann Orlarey (Grame, Lyon, France), Laurent Pottier (U. Jean Monnet, Saint Etienne, France), Julius Smith (CCRMA, Stanford , USA) Previous Winners 2015: Guitarix , by Hermann Meyer and Andreas Degert 2016: Ambitools , by Pierre Lecomte; Student prize: TouchVoices , by Pierre-Adrien Th\u00e9o. 2017-12-12: WebAudio wasm benchmark pages and tools WebAudio wasm benchmark pages and tools WebAudio wasm benchmark pages and tools allow to test statically generated HTML pages from Faust DSP. Audio generating pages in ScriptProcessor or AudioWorklet mode can be tested first. DSP CPU benchmark pages can be used to test the perfomance of wasm code across different browsers. Tools to generate new DSP CPU benchmark pages are also available, and finally a page allowing to test the dynamic compilation chain can be acccesed. Simple pages Simple pages can be used to test simple monophonic and polyphonic DSP, generated as ScriptProcessor or AudioWorklet WebAudio nodes. statically generated OSC as a ScriptProcessor node statically generated MIDI controllable Organ as a ScriptProcessor node Note that as 12/12/17, AudioWorklet pages can ony be tested with Chrome Canary. Be sure to activate AudioWorklet mode first. On a MacBook Pro OSX El Capitan 2,2 GHz Intel Core i7, we still hear audio glitches when testing them , for example when opening the JavaScript console, or interacting with other applications (like scrolling in the XCode editor, scrolling in the terminal...) statically generated OSC as an AudioWorlet node statically generated MIDI controllable Organ as an AudioWorlet node Polyphonic MIDI aware pages More complex statically generated polyphonic MIDI aware pages can be tested. ScriptProcessor based pages: modules/clarinetMIDI.html modules/elecGuitarMIDI.html modules/violinMIDI.html AudioWorklet based pages: modules-worklet/clarinetMIDI.html modules-worklet/elecGuitarMIDI.html modules-worklet/violinMIDI.html Benchmark pages A set of statically generated pages allow to measure the DSP CPU use of Faust generated WebAssemby code. The compute method is repeatedly called in a loop (taking 100% of a core) which duration is measured. Results as MBytes/sec as well a DSP CPU load in % of a 1024 frames, 44.1 kHz audio buffer are displayed. On the following pages, just hit the Start benchmark button, and wait for the result to be displayed. Note that since the computation is done in the main JavaScript thread, don't disturb your machine too much to get a reliable result. The pages can typically be used to compare the performances of different browsers: bench/clarinetMIDI.html bench/djembe.html bench/filterBank.html bench/freeverb.html bench/frenchBell.html bench/guitarEffectChain.html bench/karplus.html bench/karplus32.html bench/kisana.html bench/spectralLevel.html bench/stunedBar6.html bench/violinMIDI.html bench/zitaRev.html Testing the denormal issue A specific problem occurs when audio computation produces denormal float values, which is quite common with recursive filters, and can be extremely costly to compute on some processors like the Intel family for instance. Even with the software FTZ mode, we still see huge DSP CPU issue in some cases like this djembe physical model based on simple biquad filters: modules/djembe.html On OSX for instance, open the Activity Monitor tool and look as your browser CPU use. Then hit the checkbox to start playing, and hit it again to stop it. Silence should be produced, but actually very small sample values (= subnormals) are generated. If your machine uses an Intel CPU, you will see CPU raise quite rapidly ! (tested on a MacBook Pro OSX El Capitan 2,2 GHz Intel Core i7). Benchmark tools For developers, benchmark tools allow to generate HTML pages to test your DSP. Look in particular at the faust2benchwasm script. Dynamic compilation chain testing page A more complete testing page for monophonic and polyphonic MIDI aware DSP, ScriptProcessor or AudioWorklet mode, FTZ selection mode is available here . 2017-11-07: 1st International Faust Conference 1st International Faust Conference - Johannes Gutenberg University, Mainz (Germany), July 17-18, 2018 The International Faust Conference IFC-18 will take place at the Johannes Gutenberg University of Mainz (Germany) on July 17-18, 2018. It aims at gathering developers and users of the Faust programming language to present current projects and discuss future directions for Faust and its community. Participants will be able to share their work through paper presentations. A series of round tables on various topics will serve as a platform to brainstorm on Faust's features, semantics, tools, applications, etc. to determine future directions for this language. Open spaces for demos and workshops will be available for participants to openly share their ongoing projects with the rest of the community. As a special event, the winner of GRAME's Faust Open-Source Software Competition will be announced during IFC-18. IFC-18 is free and everyone is welcome to attend! Call for Papers We welcome submissions from academic, professional, independent programmers, artists, etc. We solicit original papers centered around the Faust programming language in the following categories: Original research Technology tutorial Artistic project report (e.g., installation, composition, etc.) Paper should be up to 14 pages in length, non anonymous, and formatted according to this template . Submissions should be carried out via our EasyChair portal . All submissions are subject to peer review. Acceptance may be conditional upon changes being made to the paper as directed by reviewers. Accepted papers will be published on-line as well as in the IFC-18 proceedings paper version. They will be presented by their author(s) at IFC-18 as 15 minutes presentations (+ 5 minutes for questions). Feel free to contact us if you have any question. Important Dates Papers submission deadline: March 2, 2018 Notification of Acceptance: May 1, 2018 Camera-Ready Version: June 1, 2018 Call for Round Table Topics A series of round tables on the following themes will take place both afternoons of IFC-18: Faust Tools (e.g., Architectures, IDE, Faust Code Generator, On-Line Services, etc.) DSP in Faust and Faust Libraries (e.g., New Algorithms, New Libraries, Missing Functions, etc.) Faust Compiler and Semantics Other Topics/Open Session We solicit topic suggestions from the Faust community for each of these themes. Topics can be submitted by means of this Google form . They will be introduced during the round tables by the session chair. Contact Please, address your questions to: ifc18@muwiinfa.geschichte.uni-mainz.de Conference website: http://www.ifc18.uni-mainz.de 2017-10-20: New Faust Editor New Faust Editor We are very happy to announce the online Faust Editor . It can be used to edit , compile and run Faust code from any recent Web Browser with WebAssembly support. This editor works completely on the client side and it is therefore very convenient for situations with many simultaneous users (workshops, classrooms, etc.). It embeds the latest version of the Faust compiler with an efficient WebAssembly backend and offers polyphonic MIDI support. Features The editor engine is based on codemirror . It offers syntax highlighting , auto completion and direct access to the online documentation . The documentation command (ctrl-d) uses the function name at the cursor position to locate to the relevant information. Recommended Browsers The recommended browsers are the latest versions of Firefox and Chrome. Chrome is recommended for MIDI, but it requires an https connexion to use the audio inputs. On the other hand MIDI is not supported by Firefox. Useful links Editor : the official link, https://grame-cncm.github.io/fausteditorweb/ : an alternative link on GitHub. Because this is an https address, audio inputs will work (but not the export function), https://github.com/grame-cncm/fausteditorweb : the GitHub repository. 2017-09-15: Performances of audio DSP code compiled in WebAssembly Performances of audio DSP code compiled in WebAssembly Porting and running large C/C++ code base on the Web have been the subject of several competing projects in the recent years, from Google NaCl/PNaCl to Mozilla asm.js . Recently standardized WebAssembly language inherits from ideas experimented in both approaches, with the Mozilla vision finnally winning as Robert O'Callahan explains here . Coupled with the WebAudio API , running real-time audio code in the Web now appears to be an achievable goal. WebAssembly is a hot topic in the JavaScript ecosystem. The WebAudio community is eagerly waiting for the AudioWorklet specification, with its promised reduced latency and glitch-free audio rendering, to land in browser development versions, and be tested. Porting well established C/C++ codebase with Emscripten , like the Csound framework as an example, or using DSL languages like Faust, will then naturally beneficiate from improved and more stable performances. The Faust ecosystem already allows to generate static or dynamically compiled WebAssembly based WebAudio nodes . These nodes are still using the deprecated ScriptProcessor WebAudio interface. Premillinary work has been started to be ready as soon at the AudioWorklet model will be testable. In the meantime, work have been started using the WAVM , a standalone VM for WebAssembly, that can load both the standard binary and text wasm format, compiling it in native code using the LLVM chain (generating LLVM IR and compiling it on the fly to native code using LLVM JIT compiler), and running it at (near) native speed. Glue code to load and run Faust generated wasm modules has been written. Validation and benchmarking tools have been developed. Performances comparison with the C++ and LLVM IR Faust backends is the subject of this post. Comparing the Faust C++, LLVM IR and wast/wasm backends The WebAssembly approach promises near native performances for C/C++ written code compiled to WebAssembly using the Emscripten tool chain. Other languages like Rust (using the mir2wasm tool) experiment direct WebAssembly generation. It seems clear that as WebAssembly specification and implementation stabilize, more and more languages will directly generate wasm to be deployed in browsers. The question of the quality of code generation at each step of the compilation chain will rapidly emerge. While WebAssembly is initially designed to run on the Web, it may be deployed in non Web environnement like nodejs , or even in standalone VM like WAVM . Thus WebAssembly becomes a portable binary format that can be used in a large variety of situations. This is especially of interest for a DSL language like Faust. Faust wast/wasm backend Faust wast/wasm backend directly produce WebAssembly code from the Faust internal FIR (Faust Imperative Representation) code. Generated modules are rather light since they define a very simple ABI to be used by the loader code. Two generation models have been defined: in monophonic mode the wast/mast module internally allocates a memory block to be used for the DSP state (controllers, delays lines, waveforms...) as well as audio buffers. in polyphonic mode, the memory block will be allocated by the loader environnement. This block will typically be sized to contain all the needed voices for the polyphonic DSP. In both cases, a full description of the DSP state as a JSON string is generated in the module data segment (including memory indexes of all controllers). Loader code will get and decode this JSON description, and use whatever parts of the description it needs to run the DSP code. In particular, control memory zones (corresponding to the UI items like buttons, sliders, bargraph...) can be directly read/written by the wrapper code. Benchmark of C++, LLVM IR and wast/wasm generated code Since Faust already generates C++ or LLVM IR code, the performances of those two backends can be compared with the new wasm one. Using the WAVM C++ written machine allows to deploy the same measuring code . The first benchmark compares the speed of C++, LLVM IR and wasm backends running a set of DSP, running on a MacBook Pro 2,2 GHz Core I7 with OSX El capitan. The same 4.0 version of LLVM toolchain has been used with the three backend. C++ and LLVM IR code has been compiled with the -Ofast optimization flag, the WAVM runtime is the standard version one (without any specific audio optimization, see later): The diagrams clearly shows that the wasm code is still slower than C++ or LLVM IR code, but speed difference is not so high in most cases. Some DSP behaviours need to be understood in more details. Optimizing the WAVM runtime for audio code The WAVM runtime strictly conforms to the WebAssembly specification, thus behaving as a interesting base reference. In the audio domain, the deployed code is usually compiled with specific optimization flags. Since C++ WAVM runtime can be hacked quite easily, we did several changes into the reference implementation to gain some speed: removing the atomic flag in all load/store that are added to pass all spec WebAssembly tests. adding the equivalent of -fast-math compilation flag that have to be done at LLVM IR and JIT (= native) generation steps. and finally simplifying some mathematical operators, using their standard definition instead of the specific WAVM coded ones that strictly implement WebAssembly official semantic (see for instance the definition of f32.min/f32.max operations). Here is the diagram of DSP examples run with reference WAVM runtime, and the three specific optimizations: After generating the LLVM IR code, the WAVM runtime runs a set of LLVM IR to IR optimizations passes. It remains to be tested if adding more optimization passes (especially the auto-vectorizations ones) could help producing even better code. WebAssembly module optimization with Binaryen Binaryen is a compiler and toolchain infrastructure library for WebAssembly , written in C++. We tested the wasm-opt tool at -O3 level on Faust generated wasm modules to estimate which speedup we can expect. The following diagram shows limited gains, with no more than 5% in some of the tested cases: Float denormal handling A specific problem occurs when audio computation produces denormal float values, which is quite common with recursive filters, and can be extremely costly to compute on some processors like the Intel family for instance. A Flush To Zero (FTZ) mode for denormals can usually be set at hardware level, but it not yet available in the WebAssembly MVP version, which strictly conform to the IEEE 754 norm 8. Thus an automatic software strategy which consists in adding FTZ code in all recursive loops has been implemented in the Faust compiler. To activate it, the -ftz compilation parameter must be used at compilation time. The -ftz 1 mode adds a test in each recursive loop which uses the fabs function and a threshold to detect subnormal samples (slower). The -ftz 2 mode adds a test in each recursive loop which uses a mask to detect subnormal samples (faster). Even if using software ftz is not strictly needed in our benchmark chain (since the C++ WAVM uses the ftz hardware protection mode), we can still compare the speed of the different ftz options. Here is the result of code generated with -ftz from 0 to 2: Comparing three browsers on OSX El Capitan HTML test pages were prepared to compare the performances of the three main browsers on OSX El Capitan. The DSP code is compiled with float denormal protection on (-ftz 2). The generated wasm module compute method is called repeatedly in a timed loop, using successive slices of a big allocated circular audio buffer to avoid cache effects. Here are the results: The fasted one (Chrome for now) can be compared with C++, LLVM IR, WAVM native engines, all compiled with float denormal protection on (-ftz 2): Comments and Conclusion Testing wasm JIT machines inside browsers is not an easy task. The C++ WAVM runtime revealed to be an excellent tool to compare the Faust C++, LLVM IR and wasm backend. Since its code can be easily adapted, one can estimate also what can be expected deploying wasm DSP modules in pure native environments , outside of the browser, where some audio specific optimizations may be considered. Measures done on a set of Faust DSP show that WebAssembly code still run slower than C++ or LLVM IR generated code in most cases, up to almost 66% slower in the less favorable examples. This value will typically be a bit worse when deploying in browsers, since float denormal protection code has to be used . Benchmarks in browser wasm runtime still need to be done to confirm or refine these findings. Comparing the Chrome , Firefox and WebKit browsers on OSX El Capitan shows that Chrome is currently the fastest engine in most cases, with Firefox and WebKit quite similar (with a slight plus for WebKit). Comparing the Chrome browser with native engines shows results from 4,8 times slower (filterBank.dsp), 2,8 times slower (sTunedBar6.dsp) up to much more favorable cases (karplus32.dsp). Note that filterBank.dsp example is a bit of a pathological case, since Chrome is significantly slower than Firefox and WebKit in this case, and filterBank.dsp uses a lot of pow(10, x) code that is rewritten an optimized as exp10(x) with the C++ backend path. 2017-08-18: Deploying Faust DSP on the Web Deploying Faust DSP on the Web EDIT : we are at the Web Audio conference 2017, and it appears that the way we currently extend the ScripProcessorNode with Faust code is not the Right Way... Part of the post concerning the exposed API will probably change a bit in the near future... Using latest developments done for the Web (the new WebAssembly backends and libfaust library compiled in WebAssembly with Emscripten), statically and dynamically Faust generated WebAudio nodes can be easily produced and deployed on the Web. Deploying statically compiled Faust WebAudio nodes From a foo.dsp source file, JavaScript and the associated WebAssembly files can be produced with the following script: faust2wasm foo.dsp This will generate a foo.wasm file with the WebAssembly module as binary code, as well as a foo.js wrapper file containing the code needed to turn the Faust DSP in a fully working WebAudio node (using an extended ScriptProcessor node). The name of the Faust DSP code file is used to define the final ScriptProcessorNode constructor name. So for instance if osc.dsp file is compiled, the following faust.createosc function will be generated: /** * Create a 'monophonic' ScriptProcessorNode Web Audio object * by loading and compiling the Faust wasm file * * @param context - the Web Audio context * @param buffer_size - the buffer_size in frames * @param callback - a callback taking the created ScriptProcessorNode as parameter, * or null in case of error */ faust.createosc = function(context, buffer_size, callback) The resulting object is an extended ScriptProcessorNode, to be used as a regular node (like connected to other WebAudio nodes), but which also adds the Faust specific API as defined in the equivalent C++ generated dsp class (see the architecture/faust/dsp/dsp.h header for more technical details), as well as JavaScript more specific functions. For instance the following ones will have to be used to control the node: var paths = node.getParams(); // get the set of paths to read/write input control parameters Then knowing the path for a given parameter, the following function is used to change the parameter value: node.setParamValue(\"/Oscillator/freq\", 0.6); A full JSON description of the node with the complete UI, can be retrieved with: var json = node.getJSON(); The complete usable API is fully documented in the generated JavaScript file in the Public API to be used to control the WebAudio node section. A simple example Web page A simple Web page using the files generated by faust2wasm on the noise.dsp file can be defined with the following parts: <!-- Load 'faust2wasm' script generated .js file --> <script src=\"noise.js\"></script> A slider to control the noise volume parameter is defined with: <P> Noise volume: <input type=\"range\" oninput=\"changeVolume(event) \"min=\"0\" max=\"1\" value=\"0.5\" step=\"0.01\"/> The WebAudio context is created and the noise slide hander is defined with: var isWebKitAudio = (typeof (webkitAudioContext) !== \"undefined\"); var audio_context = (isWebKitAudio) ? new webkitAudioContext() : new AudioContext(); var noise = null; // Slider handler to change the 'noise' volume function changeVolume(event) { noise.setParamValue(\"/Noise/Volume\", parseFloat(event.target.value)); } A startnoise function which creates the Faust WebAudio node is defined with: function startnoise() { // Create the Faust generated node faust.createnoise(audio_context, 1024, function (node) { noise = node; console.log(noise.getJSON()); // Print paths to be used with 'setParamValue' console.log(noise.getParams()); // Connect it to output as a regular WebAudio node noise.connect(audio_context.destination); }); } An finally the load handler is defined to activate the code: window.addEventListener(\"load\", startnoise); Look at the Noise and OSC online pages for the complete code. Note that pages loading an additional .wasm file cannot directly be loaded in Chrome. You'll have to start a local server (using the python -m SimpleHTTPServer command for instance) and access them with their http:// based URL. Generating Polyphonic WebAudio nodes Assuming that the compiled Faust DSP file is polyphonic ready , a polyphonic ready WebAudio node can be created with the -poly parameter, and will generate the following constructor for the node (where the mydsp part will be replaced by the actual DSP name): /** * Create a 'polyphonic' ScriptProcessorNode Web Audio object * by loading and compiling the Faust wasm file * to be use for the voice, and allocating the number of needed voices * * @param context - the Web Audio context * @param buffer_size - the buffer_size in frames * @param polyphony - the number of polyphonic voices * @param callback - a callback taking the created ScriptProcessorNode * as parameter, or null in case of error */ faust.createmydsp_poly = function(context, buffer_size, polyphony, callback) Polyphonic nodes have an extended API to be controled with MIDI messages: /** * Instantiates a new polyphonic voice. * * @param channel - the MIDI channel (0..15, not used for now) * @param pitch - the MIDI pitch (0..127) * @param velocity - the MIDI velocity (0..127) */ keyOn = function (channel, pitch, velocity) /** * De-instantiates a polyphonic voice. * * @param channel - the MIDI channel (0..15, not used for now) * @param pitch - the MIDI pitch (0..127) * @param velocity - the MIDI velocity (0..127) */ keyOff = function (channel, pitch, velocity) /** * Gently terminates all the active voices. */ allNotesOff = function () Look at the JavaScript public documentation section for the complete description. Extended control with -comb parameter The faust2wasm tool can be used with the -comb parameter to compile several DSP files and contatenate all JavaScript code in a unique resulting comb.js file (possibly to be used in -poly mode also). Generating fully working self-contained HTML pages The faust2webaudiowasm script can be used to generate a fully working self-contained HTML page, with a SVG/CSS a Graphical User Interface. From the osc.dsp Faust DSP source file, it will generate an osc.html file: faust2webaudiowasm osc.dsp Assuming that the compiled Faust DSP file is polyphonic ready, the -poly parameter can be used to generate a polyphonic MIDI controlable instrument, to be used with a MIDI application or device. The -links generates the DSP processor SVG representation, and links to the original DSP file as well as generated SVG files, so that the HTML page can possibly be deployed as a reusable Faust DSP resource. WebAssembly module optimization Assuming that you have Binaryen tools installed on your machine, the faust2wasm and faust2webaudiowasm scripts can take an additional -opt parameter to allow WebAssembly module optimization. Deploying dynamically compiled Faust WebAudio nodes Since the libfaust library is available for the Web, it becomes possible to embed the complete dynamic compilation chain in a Web page , from the Faust DSP source to the executable WebAudio node. First the following resources (located on the Faust GitHub in architecture/webaudio folder) have to be loaded in the page: <!-- Load 'libfaust' library and wrapper code --> <script src=\"libfaust-wasm.js\"></script> <script src=\"webaudio-wasm-wrapper.js\"></script> Then the two following functions are used to generate factories, creating later on monophonic or polyphonic instances (this is necessary because of the way internal WebAssembly memory is managed): /** * Create a DSP factory from source code as a string to be used to create monophonic DSP * * @param code - the source code as a string * @param argv - an array of parameters to be given to the Faust compiler * @param callback - a callback taking the created DSP factory as parameter, * or null in case of error */ faust.createDSPFactory = function (code, argv, callback) /** * Create a DSP factory from source code as a string to be used to create polyphonic DSP * * @param code - the source code as a string * @param argv - an array of parameters to be given to the Faust compiler * @param callback - a callback taking the created DSP factory as parameter, * or null in case of error */ faust.createPolyDSPFactory = function (code, argv, callback) The two following functions are used to generate monophonic or polyphonic Faust WebAudio nodes: /** * Create a ScriptProcessorNode Web Audio object from a factory * * @param factory - the DSP factory * @param context - the Web Audio context * @param buffer_size - the buffer_size in frames * @param callback - a callback taking the created ScriptProcessorNode as parameter, * or null in case of error */ faust.createDSPInstance = function (factory, context, buffer_size, callback) /** * Create a 'polyphonic' 'ScriptProcessorNode Web Audio object from a factory * * @param factory - the DSP factory * @param context - the Web Audio context * @param buffer_size - the buffer_size in frames * @param polyphony - the number of polyphonic voices * @param callback - a callback taking the created ScriptProcessorNode as parameter, * or null in case of error */ faust.createPolyDSPInstance = function (factory, context, buffer_size, polyphony, callback) The resulting nodes have the same API as statically compiled nodes described in the first section, so can be controlled the same way, including the polyphonic ones. Here is a code example using faust.createDSPFactory and faust.createDSPInstance : var isWebKitAudio = (typeof (webkitAudioContext) !== \"undefined\"); var audio_context = (isWebKitAudio) ? new webkitAudioContext() : new AudioContext(); var dsp_code = \"import(\\\"stdfaust.lib\\\"); vol = hslider(\\\"volume [unit:dB]\\\", 0, -96, 0, 0.1) : ba.db2linear : si.smoo; freq = hslider(\\\"freq [unit:Hz]\\\", 1000, 20, 24000, 1); process = vgroup(\\\"Oscillator\\\", os.osc(freq) * vol);\"; var osc = null; var libraries_url = \"/modules/libraries/\"; function startosc() { // Prepare argv list var argv = []; argv.push(\"-ftz\"); argv.push(\"2\"); argv.push(\"-I\"); argv.push(libraries_url); // Dynamically create the Faust generated node from explicit DSP source in 'dsp_code' faust.createDSPFactory(dsp_code, argv, function (factory) { faust.createDSPInstance(factory, audio_context, 1024 function (node) { osc = node; console.log(osc.getJSON()); // Print paths to be used with 'setParamValue' console.log(osc.getParams()); // Connect it to output as a regular WebAudio node osc.connect(audio_context.destination); })}); } The Dynamic OSC page demonstrates the dynamic OSC complete code (based on the example seen before). The Dynamic Organ page demonstrates a polyphonic organ instrument, which loads a DSP from an url, and ready to be controlled with a MIDI device or application. Look at the Dynamic Faust compiler page for a more complete use-case of the dynamic compiler. Float denormal handling A specific problem occurs when audio computation produces denormal float values, which is quite common with recursive filters, and can be extremely costly to compute on some processors like the Intel family for instance. A Flush To Zero (FTZ) mode for denormals can usually be set at hardware level, but it not yet available in the WebAssembly MVP version, which strictly conform to the IEEE 754 norm 8. Thus an automatic software strategy which consists in adding FTZ code in all recursive loops has been implemented in the Faust compiler. To activate it, the -ftz compilation parameter must be used at compilation time. The -ftz 1 mode adds a test in each recursive loop which uses the fabs function and a threshold to detect subnormal samples (slower). The -ftz 2 mode adds a test in each recursive loop which uses a mask to detect subnormal samples (faster). Use for example the following line to active software denormal handing when using faust2wasm tool: faust2wasm -ftz 2 foo.dsp The same for the faust2webaudiowasm tool: faust2webaudiowasm -ftz 2 foo.dsp For dynamic compilation, the -ftz v flag will have to be added in the argv parameter in faust.createDSPFactory or faust.createPolyDSPFactory , like for instance: faust.createPolyFactory(dsp_code, ['-ftz', '2'], callback); 2017-06-16: Using a custom memory allocator Using a custom memory allocator From a DSP source file, the Faust compiler typically generates a C++ class. When a rdtable item is used on the source code, the C++ class will contain a table shared by all instances of the class. By default, this table is generated as a static class array, and so allocated in the application global static memory. In some specific case (usually in more constrained deployment cases), managing where this data is allocated is crucial. By extension this post explains how a custom memory allocator can be used to precisely control the DSP memory allocation. Faust -mem option to control memory related code generation A new -mem compiler parameter has been added in the Faust compiler, starting from the 0.9.103 version (or 2.1.4 in Faust2 branch). This parameter will change the way static shared tables are generated. The table is allocated as a class static pointer allocated using a custom memory allocator , which has the following propotype: struct dsp_memory_manager { virtual ~dsp_memory_manager() {} virtual void* allocate(size_t size) = 0; virtual void destroy(void* ptr) = 0; }; Taking the following Faust DSP example: process = (waveform {10,20,30,40,50,60,70}, %(7)~+(3) : rdtable), (waveform {1.1,2.2,3.3,4.4,5.5,6.6,7.7}, %(7)~+(3) : rdtable); Here is the generated code in default mode: ... int mydsp::itbl0[7]; float mydsp::ftbl0[7]; static void classInit(int samplingFreq) { SIG0 sig0; sig0.init(samplingFreq); sig0.fill(7,itbl0); SIG1 sig1; sig1.init(samplingFreq); sig1.fill(7,ftbl0); } virtual void init(int samplingFreq) { classInit(samplingFreq); instanceInit(samplingFreq); } virtual void instanceInit(int samplingFreq) { instanceConstants(samplingFreq); instanceResetUserInterface(); instanceClear(); } ... The two itbl0 and ftbl0 tables are static class arrays. They are filled in the classInit method. The architecture code will typically call the init method (which calls classInit ) on a given DSP, to allocate class related arrays and the DSP itself. If several DSP are going to be allocated, calling classInit only once then the instanceInit method on each allocated DSP is the way to go. In the new -mem mode, the generated C++ code is now: ... int* mydsp::itbl0 = 0; float* mydsp::ftbl0 = 0; dsp_memory_manager* mydsp::fManager = 0; static void classInit(int samplingFreq) { SIG0 sig0; itbl0 = static_cast<int*>(fManager->allocate(sizeof(int) * 7)); sig0.init(samplingFreq); sig0.fill(7,itbl0); SIG1 sig1; ftbl0 = static_cast<float*>(fManager->allocate(sizeof(float) * 7)); sig1.init(samplingFreq); sig1.fill(7,ftbl0); } static void classDestroy() { fManager->destroy(itbl0); fManager->destroy(ftbl0); } virtual void init(int samplingFreq) {} virtual void instanceInit(int samplingFreq) { instanceConstants(samplingFreq); instanceResetUserInterface(); instanceClear(); } ... The two itbl0 and ftbl0 tables are generated a class static pointers. The classInit method takes the additional dsp_memory_manager object used to allocate tables. A new classDestroy method is available to deallocate the tables. Finally the init method is now empty, since the architecure file is supposed to use the classInit/classDestroy method once to allocate and deallocate static tables, and the instanceInit method on each allocated DSP. Control of the DSP memory allocation An architecture file can now define its custom memory manager by subclassing the dsp_memory_manager abstract base class, and implement the two required allocate and destroy methods. Here is an example of a simple heap allocating manager: struct malloc_memory_manager : public dsp_memory_manager { virtual void* allocate(size_t size) { void* res = malloc(size); cout << \"malloc_manager: \" << size << endl; return res; } virtual void destroy(void* ptr) { cout << \"free_manager\" << endl; free(ptr); } }; Controlling the table memory allocation To control table memory allocation, the architecture file will have to do: // Allocate a custom memory allocator malloc_memory_manager manager; // Setup manager for the class mydsp::fManager = &manager; // Allocate the dsp instance using regular C++ new mydsp* dsp = new mydsp(); // Allocate static tables (using the custom memory allocator) mydsp::classInit(48000); // Initialise the given instance dsp->instanceInit(48000); ... ... // Deallocate the dsp instance using regular C++ delete delete dsp; // Deallocate static tables (using the custom memory allocator) mydsp::classDestroy(); Controlling the complete DSP memory allocation Full control the DSP memory allocation can be done using C++ placement new : #include <new> // Allocate a custom memory allocator malloc_memory_manager manager; // Setup manager for the class mydsp::fManager = &manager; // Placement new using the custom allocator mydsp* dsp = new(manager.allocate(sizeof(mydsp))) mydsp(); // Allocate static tables (using the custom memory allocator) mydsp::classInit(48000); // Initialise the given instance dsp->instanceInit(48000); ... ... // Calling the destructor dsp->~mydsp(); // Deallocate the pointer itself using the custom memory allocator manager.destroy(dsp); // Deallocate static tables (using the custom memory allocator) mydsp::classDestroy(); More complex custom memory allocators can be developed by refining this malloc_memory_manager example, possibly defining real-time memory allocators...etc... The OWL architecture file already uses this new custom memory allocator model. This is a work in progress: in the Faust2 branch, this model is still not supported yet beside the C++ backend custom memory allocator is not yet supported is additional DSP classes (like the mydsp_poly defined in the achitecture/faust/dsp/poly-dsp.h header). 2017-04-26: Optimizing the DSP CPU usage Optimizing the DSP CPU usage The Faust compiler has as lot of different compilation parameters to play with. Discovering them for a given DSP program is something that can be automated. Two measure_dsp and dsp_optimizer classes are available for developers to measure DSP CPU use directly in their code. Two more friendly faustbench and faustbench-llvm tools have been developed using them. They allow to discover the best Faust compiler parameters, to be used later on with faust2xx scripts, faustgen~ Max/MSP external or FaustLive . The measure_dsp and dsp_optimizer DSP decorator classes The measure_dsp class defined in the faust/dsp/dsp-bench.h file allows to decorate a given DSP object and measure its compute method CPU consumption. Results are given in Megabytes/seconds (higher is better). Here is a C++ code example of its use: static void bench(dsp* dsp, const string& name) { // Init the DSP dsp->init(48000); // Wraps it with a 'measure_dsp' decorator measure_dsp mes(dsp, 1024, 5); // Measure the CPU use mes.measure(); // Print the stats cout << name << \" CPU use : \" << mes.getStats() << endl; } Only part of the Faust2 branch and defined in the faust/dsp/dsp-optimizer.h file, the dsp_optimizer class uses the libfaust library and its LLVM backend to dynamically compile DSP objects produced with different Faust compiler options, and then measure their DSP CPU. Here is a C++ code example of its use: static void dynamic_bench(const string& dsp_source) { // Init the DSP optimizer with the dsp_source to compile // (either the filename or source code string) dsp_optimizer optimizer(dsp_source, \"/usr/local/share/faust\", \"\", 1024); double value; // Discover the best set of parameters vector<string> options = optimizer.findOptimizedParameters(value); // Print the result cout << \"Best value is for '\" << argv[1] << \"' is : \" << value << \" with \"; for (int i = 0; i < options.size(); i++) { cout << options[i] << \" \"; } cout << endl; } Using the faustbench tool The faustbench tool uses the C++ backend to generate a set of C++ files produced with different Faust compiler options. All files are then compiled in a unique binary that will measure DSP CPU of all versions of the compiled DSP. The tool is supposed to be launched in a terminal, but it can be used to generate an iOS project, ready to be launched and tested in Xcode. Here are the available options: faustbench [-ios] [Additional Faust options (-vec -vs 8...)] <file.dsp> Use '-ios' to generate an iOS project Use 'export CXX=/path/to/compiler' before running faustbench to change the C++ compiler Use 'export CXXFLAGS=options' before running faustbench to change the C++ compiler options Here is a trace of its use: faustbench karplus32.dsp Selected compiler is g++ with CXXFLAGS = -Ofast -scal : 77.5123 -vec -lv 0 -vs 4 : 64.2194 -vec -lv 0 -vs 8 : 80.8951 -vec -lv 0 -vs 16 : 106.244 ..... -vec -lv 1 -vs 128 -g : 130.635 -vec -lv 1 -vs 256 -g : 134.335 -vec -lv 1 -vs 512 -g : 135.352 Best value is : 136.235 with -vec -lv 0 -vs 512 Using the faustbench-llvm tool Available in the faust2 branch only, the faustbench-llvm tool uses the libfaust library and its LLVM backend to dynamically compile DSP objects produced with different Faust compiler options, and then measure their DSP CPU. In the main Faust folder, use make bench && sudo make install to build and install the tool. Here is a trace of its use: faustbench-llvm karplus32.dsp Estimate timing parameters -scal : 21.1269 duration = 0.102801 count = 24318 Discover best parameters option -scal : 21.1034 -vec -lv 0 -vs 4 : 42.0734 -vec -lv 0 -vs 8 : 55.3725 -vec -lv 0 -vs 16 : 85.3855 ..... -vec -lv 1 -vs 128 -dfs : 133.974 -vec -lv 1 -vs 256 -dfs : 139.12 -vec -lv 1 -vs 512 -dfs : 91.8424 Refined with -mcd -vec -lv 0 -vs 256 -g -mcd 2 : 83.5555 -vec -lv 0 -vs 256 -g -mcd 4 : 138.519 -vec -lv 0 -vs 256 -g -mcd 8 : 140.122 -vec -lv 0 -vs 256 -g -mcd 16 : 141.558 -vec -lv 0 -vs 256 -g -mcd 32 : 139.454 -vec -lv 0 -vs 256 -g -mcd 64 : 143.405 -vec -lv 0 -vs 256 -g -mcd 128 : 142.975 -vec -lv 0 -vs 256 -g -mcd 256 : 139.345 Best value is for 'karplus32.dsp' is : 142.473 with -vec -lv 0 -vs 256 -dfs -mcd 64 w 2017-02-21: Faust meets JUCE JUCE is an open-source cross-platform C++ application framework, used for the development of desktop and mobile applications. JUCE is used in particular for its GUI and plugins libraries. A set of architecture files have been developed to deploy standalone or plugins built from Faust code. They allow to automatically generate the GUI from the Faust program, possibly supporting polyphonic instruments, and be controlled by MIDI or OSC messages. The architecture files are then combined to produce ready to compile JUCE applications or plugins, using tools that are part of the Faust distribution. They can also be accessed using the Faust online compiler. faust2juce script faust2juce transforms a Faust DSP program into a fully working JUCE standalone application or plugin, which can possibly be controlled with MIDI or OSC messages. Read its complete description here . You'll have to get a recent github version of Faust tree to use it. Using the online compiler The Faust online compiler has been updated to provide new 'juce' targets. Note that only some of the possible compilation options are availble for now: the application target produces a standalone MIDI controlable application (using Faust polyphonic code if the Faust source code is polyphonic aware) the plug-in target produces a MIDI controlable mono or polyphonic plugin (using Faust polyphonic code if the Faust source code is polyphonic aware) the jsynth target produces a MIDI controlable mono or polyphonic plugin (using JUCE polyphonic Synthesizer if the Faust source code is polyphonic aware) Directly using faust2juce provides the full control of the generated target with access to all possible compilation parameters. Graph of Faust generated plugins Here is an example of three Faust generated plugins running in JUCE plugin host: Using libfaust and LLVM An alternative to faust2juce static-compilation model, is to use Oliver Larkin's juce_faustllvm module, also used in his pMix2 tool . 2017-01-13: Faust WebAssembly backend Faust WebAssembly backend WebAssembly was born with the premise of creating a safe, portable and fast to load and execute format suitable for the web. WebAssembly its not a programing language but a compilation target with a text and binary specs. That means that other low level languages like C/C++, Rust, Swift, etc. can compile to WebAssembly. Specified and developed by principal browser compagnies (Google, Mozilla, Microsoft and Apple), this new format aims to finally replace the more hackish \"asm.js\" format initialy developed by Mozilla. Development versions of Chrome and Firefox can already execute it. To get an early preview of this experimental technology, at your own risk: on Chrome Canary , open chrome://flags/#enable-webassembly and enable the switch on Firefox Nightly , open about:config and set javascript.options.wasm to true See a preview of Microsoft Edge support and follow Safari support on WebKit\u2019s feature status . WebAssembly backends New WebAssembly backends have been added in the faust2 development branch. They allow to generate textual or binary WebAssembly code. 'wast' textual backend The 'wast' backend allows to generate textual WebAssembly code (in s-expression like format). Note that as of january 2017, the official textual format is not yet fully specified, thus we follow the format used in the binaryen tool . Use the following command to generate the textual output in the terminal for a given foo.dsp file. faust -lang wast foo.dsp The following command: faust -lang wast foo.dsp -o foo.wast will generate the foo.wast textual WebAssembly output file as well as an additional foo.js JavaScript file containing glue code. 'wasm' binary backend The 'wasm' backend allows to generate binary WebAssembly code. Use the following command to generate the binary output in the terminal for a given foo.dsp file. faust -lang wasm foo.dsp The following command: faust -lang wasm foo.dsp -o foo.wasm will generate the foo.wast binary WebAssembly output file as well as an additional foo.js JavaScript file containing glue code. Generating static HTML pages WebAssembly code can be feeded into WebAudio JavaScript nodes, which can then be used like any other native WebAudio node. Two scripts are available to generate static WebAudio html pages from a given foo.dsp source file with the generated html/css/svg user interface: faust2webaudiowast foo.dsp will generate the textual WebAssembly output, use binaryen wasm-as tool to convert the wast to wasm format (you'll have to compile and install the binaryen tools on your machine), and produce a self-contained html page. faust2webaudiowasm foo.dsp will generate the binary WebAssembly output that can directly be loaded by the produced self-contained html page. Page containing polyphonic instruments can be generated with the following commands: faust2webaudiowast -poly foo.dsp to use the 'wast' backend and a polyphonic ready foo.dsp, and create a self-contained html page ready to be used with a MIDI instrument. faust2webaudiowasm -poly foo.dsp to use the 'wasm' backend and a polyphonic ready foo.dsp, and create a self-contained html page ready to be used with a MIDI instrument. 2016-10-17: Faust Award 2016 The Faust Open Source Software Competition aims at promoting innovative high-quality free audio software developed with Faust, a functional programming language for realtime signal processing and sound synthesis. The competition is sponsored by GRAME , Centre National de Cr\u00e9ation Musicale Faust Award 2016 to Ambitools The Faust Award 2016 was attributed by an international committee composed of : Jean-Louis Giavitto (IRCAM, Paris, France), Albert Graef (Johannes Gutenberg U., Mainz, Germany), Pierre Jouvelot (Ecole des Mines, Paris, France), Victor Lazzarini (Maynooth U., Maynooth, Ireland), Romain Michon (Stanford U., Palo Alto, USA) Yann Orlarey (GRAME, Lyon, France), Dave Phillips (musician, journalist, and educator, USA) Laurent Pottier (U. Jean Monnet, Saint-Etienne, France), Julius Smith (Stanford U., Palo Alto, USA) to Ambitools , a set of tools for real-time 3D sound field synthesis using higher order ambisonics (HOA). Ambitools is developed by Pierre Lecomte, a PhD candidate at Conservatoire National des Arts et M\u00e9tiers and Sherbrooke University. The core of the sound processing is written in Faust. The tools contain HOA encoders, decoders, binaural-filters, HOA signals transformations, spherical VU-Meter, etc. and can be compiled in various plug-ins format under Windows, Mac OSX, and Linux. The jury praised the quality and the usefulness of Ambitools: a really useful and technically advanced Faust app and an impressive technical achievement ! Check the demo . The committee was also very impressed by the quality of two other projects : Voice of Faust , a voice synthesizer/effects machine by Bart Brouns ( demo ). PMix , a graphical patcher, preset interpolator and JIT compiler for FAUST by Oliver Larkin ( demo ). Faust Student Software Competition to TouchVoices In parallel to the main competition, we introduced this year a junior competition: the Faust Student Software Competition , intended to promote small but interesting Faust applications, typically written as student projects. The student prize was awarded to TouchVoices (by Pierre-Adrien Th\u00e9o, RIM Master student at University Jean Monnet) a real-time web application allowing to capture, playback and transform sound loops. Here is a video of Pierre-Adrien Th\u00e9o during a performance with TouchVoices . A very close competitor was SuperBeatRepeater (by Vincent Rateau, of SuperDirt fame), a sample accurate beat repeater. Don't miss the demo ! 2016-08-30: The first FAUST book is Korean ! The first FAUST book is Korean ! \u201c Sound Programming using FAUST \u201d, written by Jin-Wook Chae , an experienced audio developer and sound engineer (right) and Hyun-Hoo Jung (left), is the very first book ever published on FAUST. While the book is written in Korean, I was able to really appreciate the choice of the examples and the elegance as well as the high quality of the code. I am sure it will be an invaluable tool to promote FAUST in Korea among sound engineering, computer music students and more generally any person interested in sound programming. This book is for people desiring to produce musical instruments or sound processors. I have always been instructing my students that the ultimate importance is to discover interesting ideas about the sound. In spite of that, I have often relied on an unflattering response such as \"you may need to learn a programming language like C/C++...\" when a student asked for help with how to execute his/her ideas related to sound. Now I am pleased to recommend the use of FAUST to bring such ideas into execution. This is an easy self-study guide that can help to do just that. Now I can confidently tell anybody pursuing sound or electronic music that their exciting and brilliant idea about sound is what truly counts! So, really, how do we execute our ideas? Today I am introducing you to FAUST and to this book which you will find immensely helpful in terms of how to use FAUST to bring your fabulous ideas into reality. Jinwook Chae 2016-06-30: Faust interpreter backend A new 'interpreter' backend has been added in the faust2 development branch. It allows to execute Faust programs without using the LLVM dynamic compiler chain. Interpreter compilation chain The dynamic compilation chain allows developers to embed the Faust compiler technology directly in their application or plugins. Faust2 development branch uses an intermediate FIR representation (Faust Imperative Representation), which can be translated to several output languages. An LLVM backend has been previously developed to allows applications to compile a DSP source into executable code in memory, bypassing the external compiler requirement. In some specific situations, embedding the LLVM chain is not possible : for instance Apple does not allow to deploy dynamic compilers on iOS. Thus having an interpreter backend allows to get around this problem and still make Faust code run on those platforms. Interpreter backend The interpreter backend translates the FIR intermediate language into instructions for a virtual machine. A pure C++ interpreter for this instruction set has been implemented. Running and performances The interpreter backend translates the FIR intermediate language into bytecode for a virtual machine. It allows to run programs about 4 to 5 slower than native speed . Moreover this interpreter can be compiled in a special 'trace' mode to automatically detect various execution errors : invalid heap access, mathematical errors or warnings (division by zero, integer overloading....) which helps us to check the compiler semantic and code generation quality. Deployment for developers Given a Faust source code (as a file or a string), calling the createInterpreterDSPFactoryXXX function runs the compilation chain (Faust + interpreter) and generates the \u201cprototype\u201d of the class, as a interpreter-dsp-factory pointer. class interpreter_dsp_factory : public dsp_factory { public: /* Return Factory name */ std::string getName(); /* Return Factory SHA key */ std::string getSHAKey(); /* Return Factory expanded DSP code */ std::string getDSPCode(); /* Creates a new dsp instance */ dsp* createDSPInstance(); }; Note that the library keeps an internal cache of all allocated factories so that the compilation of the same DSP code, that is same source code and same set of 'normalized' (= sorted in a canonical order) compilations options, will return the same (reference counted) factory pointer. You will have to explicitly use deleteInterpreterDSPFactory to properly decrement the reference counter when the factory is no more needed. You can get a unique SHA1 key of the created factory using its getSHAKey method. Next, the createDSPInstance function, corresponding to the new className of C++, instantiates a interpreter-dsp pointer to be used through its interface, connected to the audio chain and controller interfaces. When finished, simply use delete to destroy the dsp instance. class interpreter_dsp : public dsp { public: void metadata(Meta* m); int getNumInputs(); int getNumOutputs(); void init(int samplingRate); void instanceInit(int samplingRate); dsp* clone(); void buildUserInterface(UI* inter); int getSampleRate(); void compute(int count, FAUSTFLOAT** input, FAUSTFLOAT** output); }; Since interpreter_dsp is a subclass of the dsp base class, an object of this type can be used with all already available audio and UI classes, in essence reusing all architecture files already developed for the static C++ class compilation scheme (like OSCUI, httpdUI interfaces etc.), see Developing a new architecture file . Saving/restoring the factory After the DSP factory has been compiled, your application or plugin may want to save/restore it in order to save Faust to interpreter bytecode compilation at next use. To get the internal factory compiled code, several functions are available: writeInterpreterDSPFactoryToMachine allows to get the interpreter bytecode as a string, writeInterpreterDSPFactoryToMachineFile allows to save the interpreter bytecode in a file, To re-create a DSP factory from a previously saved code, several functions are available: readInterpreterDSPFactoryFromMachine allows to create a DSP factory from a string containing the interpreter bytecode, readInterpreterDSPFactoryFromMachineFile allows to create a DSP factory from a file containing the interpreter bytecode. The complete API is available and documented in the installed faust/dsp/interpreter-dsp.h header. 2016-04-07: Faust and the Web Audio API Faust and the Web Audio API (3) The Faust compiler can now directly be used in a Web page. Thanks to the Emscripten compiler, the Faust compiler itself can be compiled to asm.js JavaScript. This has been done by compiling the libfaust C++ library to the libfaust.js JavaScript library, that exports a unique entry point. Compiling DSP to JavaScript (asm.js) The libfaust.js exported function createAsmCDSPFactoryFromString(...) allows to create a DSP factory from a given DSP program as a source string and a set of compilations parameters, uses the Faust compiler asm.js backend, and produces the complete asm.js module and additional pure JavaScript methods as a string. Then calling JavaScript 'eval' function on this string compiles it in the browser. The dynamically created asm.js module and additional pure JavaScript methods can then be used. This internal code in then wrapped with additional JavaScript code. A DSP \u201cfactory\u201d will be created from the DSP source code with the following 'synchronous' code (if using the 'libfaust.js' library): var factory = faust.createDSPFactory(code, arguments); or possibly (if using the 'libfaustworker.js' library in the 'asynchronous' model): faust.createDSPFactory(code, arguments, callback); where 'code' is the DSP source as a string, and 'arguments' is an array of parameters to be given to the Faust compiler (like '-vec', '-vs 512'...), and 'callback' is a function taking the created 'factory' as argument. When no more used, you'll have to explicitly use the following code the deallocate the factory: faust.deleteDSPFactory(factory); Your application may want to save the already compiled factory as asm.js/JavaScript code to speed-up possible restore at later time: var machine_code = faust.writeDSPFactoryToMachine(factory); And restore the factory with the following code: var factory = faust.readDSPFactoryFromMachine(machine_code); Using DSP instances A fully working DSP \u201cinstance\u201d as a Web Audio node is then created with the code: var dsp = faust.createDSPInstance(factory, audio_context, buffer_size); When no more used, you'll have to explicitly use the following code to deallocate the instance: faust.deleteDSPInstance(dsp); This instance can be used like the statically compiled one, as previously described in this page . Polyphonic instruments Polyphonic instruments can be produced. For a given 'factory' the following code will create a 16 voices polyphonic instance: var dsp = faust.createPolyDSPInstance(factory, audio_context, buffer_size, 16); This instance can be used like the statically compiled one, as previously described in this page . Using Faust JavaScript library The Emscripten compiled Faust library can be used in two ways. Either using the 'libfaust.js' library: <script src=\"libfaust.js\"></script> <script src=\"webaudio-asm-wrapper.js\"></script> or if using worker mode with the following code which loads the 'libfaustworker.js' library: <script src=\"webaudio/webaudio-asm-worker-wrapper.js\"></script> 2016-02-05: Faust Award 2016 Faust Award 2016: deadline June 1, 2016 The Faust Open-Source Software Competition is intended to promote innovative high-quality free audio software developed with the Faust programming language, as well as development tools build around the Faust compiler itself. The Faust Open-Source Software award will be attributed to the best submission by an international committee of leading experts in the field. The competition is sponsored by Grame, centre national de cr\u00e9ation musicale. The winning software will receive a 2000\u20ac price to encourage its authors. The results will be announced July 15, 2016. To participate, the software must be provided with source code and licensed with a Free/Open Source license. A substantial part of the software must be written in Faust and the Faust source code must be provided. As part of the review process, the software will be built from the sources. All source code, license, video demonstration, installation instructions, and any other documentation must be available on a public web page. License compatibility with other open source software is encouraged. Dependencies on non-open source third-party software are discouraged, with the exception of operating systems and freely available commercial packages. Authors are required to prepare a video demonstrating the software. This video must be done carefully, and should convincingly present the qualities of the software. The submission must also contain any useful documentation, including examples of how the provided software might be used, existing prototypes that use the software, download statistics or other public usage information. The criteria for judging submissions includes broad applicability and potential impact, novelty, technical depth, reusability, etc. Junior Competition In parallel to the Faust Open-Source Software Competition we introduce this year a junior competition, the Faust Student Software Competition, with a 200\u20ac prize for the winner. The Faust Student Software Competition is intended to promote interesting audio processing and synthesis applications written in Faust in a single file in less than 1000 words. The word count is done after removing the comments from the code: cat foo.dsp | stripcmt | wc -w. The use of the standard Faust libraries is strongly encouraged. They don't take part in the word count. Important dates Start of the competition: February 8, 2016 Software Submission Deadline: June 1, 2016 Results of the competition: July 1, 2016 Submission Guidelines Authors interested in participating in the Faust Open Source Software Competition or the Faust Student Software Competition should send a submission email to faustaward@grame.fr with a PDF file attached containing the following information: Title of submission, Category of submission ( Faust Open Source Software Competition or Faust Student Software Competition ), Name, email and affiliation of the main author, Names, emails and affiliations of other authors, A permanent link for the open source software (e.g., Sourceforge, GitHub, Google Code, etc.), A permanent link for the video demonstration (e.g., YouTube, Vimeo, etc.), A link to a compressed archive file that contains the software (source code, documentation, build/install instructions, and licenses). Comprehensive and clear build/install instructions will be a crucial component of any submission. The committee will make a reasonable effort to build the software for the top contributions, but if they are unable to make the software run, it will be excluded from the competition. International Committee Jean-Louis Giavitto (IRCAM, Paris, France), Albert Gr\u00e4f (Johannes Gutenberg U., Mainz, Germany), Pierre Jouvelot (Ecole des Mines, Paris, France), Victor Lazzarini (Maynooth U., Maynooth, Ireland), Romain Michon (CCRMA, Stanford , USA) Yann Orlarey (Grame, Lyon, France), Dave Phillips (Musician/Journalist, Findlay, USA) Laurent Pottier (U. Jean Monnet, Saint Etienne, France), Julius Smith (CCRMA, Stanford , USA) Previous Winners 2015: Guitarix , by Hermann Meyer and Andreas Degert","title":"News up to 2018"},{"location":"community/news/#faust-news","text":"","title":"Faust News"},{"location":"community/news/#2018-07-23-fausts-evolution","text":"View the evolution of the Faust project from 2004 to 2018. The visualization was done using Gource . Here is the command used (as suggested by fullybacked ): gource --hide dirnames,filenames --seconds-per-day 0.1 --auto-skip-seconds 1 -1920x1024 -o - | ffmpeg -y -r 60 -f image2pipe -vcodec ppm -i - -vcodec libx264 -preset ultrafast -pix_fmt yuv420p -crf 1 -threads 0 -bf 0 faust-hd.mp4","title":"2018-07-23: Faust's Evolution"},{"location":"community/news/#2018-07-23-faust-award-2018","text":"The Faust Open Source Software Competition aims at promoting innovative high-quality free audio software developed with Faust, a functional programming language for realtime signal processing and sound synthesis. The competition is sponsored by GRAME , Centre National de Cr\u00e9ation Musicale.","title":"2018-07-23: Faust Award 2018"},{"location":"community/news/#faust-award-2018-to-iplug-2","text":"The Faust Award 2018 was attributed by an international committee composed of : Jean-Louis Giavitto (IRCAM, Paris, France), Albert Graef (Johannes Gutenberg U., Mainz, Germany), Pierre Jouvelot (Ecole des Mines, Paris, France), Victor Lazzarini (Maynooth U., Maynooth, Ireland), Romain Michon (Stanford U., Palo Alto, USA) Yann Orlarey (GRAME, Lyon, France), Laurent Pottier (U. Jean Monnet, Saint-Etienne, France), Julius Smith (Stanford U., Palo Alto, USA) to iPlug 2 a free open source C++ audio plug-in framework, allowing developers to create audio plug-ins and apps across a wide range of formats from the same code, including graphical user interface and DSP components. Amongst many other new features and a reworked code base, version 2 includes support for FAUST, allowing sections of audio DSP to be implemented using the FAUST language, and easily integrated with other C++ elements. iPlug 2 is developed by Oliver Larkin and Alex Harker from the original iPlug, by Cockos inc. that was open sourced in 2008. The project is under active development and will be publicly released at the end of 2018. The jury praised the quality, the ambition, and the usefulness of iPlug 2 as a Faust development framework! Check the demo here . We hope that the Faust Award will help the authors to fully finalize the project.","title":"Faust Award 2018 to iPlug 2"},{"location":"community/news/#faust-student-software-competition-to-cloud-generator","text":"In parallel to the main competition, the Faust Student Software Competition , is intended to promote small, but innovative Faust applications, typically developed in the framework of student projects. The student prize 2018 was awarded to Cloud Generator a nine-voice polyphonic synthesizer developed by Rittik Wystup. The jury praised the audio quality and the care taken by Rittik Wystup in his project! Check the Cloud Generator demo here .","title":"Faust Student Software Competition to Cloud Generator"},{"location":"community/news/#2018-07-10-international-faust-conference-2018","text":"","title":"2018-07-10: International Faust Conference 2018"},{"location":"community/news/#international-faust-conference-ifc18-july-17-18-2018","text":"The International Faust Conference IFC18 will take place at the Johannes Gutenberg University of Mainz (Germany) on July 17-18, 2018. It aims at gathering developers and users of the Faust programming language to present current projects and discuss future directions for Faust and its community. Participants will be able to share their work through paper presentations. A series of round tables on various topics will serve as a platform to brainstorm on Faust's features, semantics, tools, applications, etc. to determine future directions for this language. Open spaces for demos and workshops will be available for participants to openly share their ongoing projects with the rest of the community. As a special event, the winner of GRAME's Faust Open-Source Software Competition will be announced during IFC18 . IFC-18 is free and everyone is welcome to attend! Please register here","title":"International Faust Conference IFC18: July 17-18, 2018"},{"location":"community/news/#2018-02-18-faust-award-2018","text":"","title":"2018-02-18: Faust Award 2018"},{"location":"community/news/#faust-award-2018-deadline-june-1-2018","text":"The Faust Open-Source Software Competition is intended to promote innovative high-quality free audio software developed with the Faust programming language, as well as development tools built around the Faust compiler itself. The Faust Open-Source Software award will be attributed to the best submission by an international committee of leading experts in the field. The competition is sponsored by Grame, centre national de cr\u00e9ation musicale. The winning software will receive a 2000\u20ac price to encourage its authors. The results will be announced July 17, 2018 during the International Faust Conference in Mainz IFC18 . To participate, the software must be provided with source code and licensed with a Free/Open Source license. A substantial part of the software must be written in Faust and the Faust source code must be provided. As part of the review process, the software will be built from the sources. All source code, license, video demonstration, installation instructions, and any other documentation must be available on a public web page. License compatibility with other open source software is encouraged. Dependencies on non-open source third-party software are discouraged, with the exception of operating systems and freely available commercial packages. Authors are required to prepare a video demonstrating the software. This video must be done carefully, and should convincingly present the qualities of the software. The submission must also contain any useful documentation, including examples of how the provided software might be used, existing prototypes that use the software, download statistics or other public usage information. The criteria for judging submissions includes broad applicability and potential impact, novelty, technical depth, reusability, etc.","title":"Faust Award 2018: deadline June 1, 2018"},{"location":"community/news/#junior-competition","text":"In parallel to the Faust Open-Source Software Competition we have a junior competition, the Faust Student Software Competition, with a 200\u20ac prize for the winner. The Faust Student Software Competition is intended to promote interesting audio processing and synthesis applications written in Faust in a single file in less than 1000 words. The word count is done after removing the comments from the code: cat foo.dsp | stripcmt | wc -w. The use of the standard Faust libraries is strongly encouraged. They don't take part in the word count.","title":"Junior Competition"},{"location":"community/news/#important-dates","text":"Start of the competition: February 18, 2018 Software Submission Deadline: June 1, 2018 Results of the competition: July 17, 2018","title":"Important dates"},{"location":"community/news/#submission-guidelines","text":"Authors interested in participating in the Faust Open Source Software Competition or the Faust Student Software Competition should send a submission email to faustaward@grame.fr with a PDF file attached containing the following information: Title of submission, Category of submission ( Faust Open Source Software Competition or Faust Student Software Competition ), Name, email and affiliation of the main author, Names, emails and affiliations of other authors, A permanent link for the open source software (e.g., Sourceforge, GitHub, Google Code, etc.), A permanent link for the video demonstration (e.g., YouTube, Vimeo, etc.), A link to a compressed archive file that contains the software (source code, documentation, build/install instructions, and licenses). Comprehensive and clear build/install instructions will be a crucial component of any submission. The committee will make a reasonable effort to build the software for the top contributions, but if they are unable to make the software run, it will be excluded from the competition.","title":"Submission Guidelines"},{"location":"community/news/#international-committee","text":"Jean-Louis Giavitto (IRCAM, Paris, France), Albert Gr\u00e4f (Johannes Gutenberg U., Mainz, Germany), Pierre Jouvelot (Ecole des Mines, Paris, France), Victor Lazzarini (Maynooth U., Maynooth, Ireland), Romain Michon (CCRMA, Stanford , USA) Yann Orlarey (Grame, Lyon, France), Laurent Pottier (U. Jean Monnet, Saint Etienne, France), Julius Smith (CCRMA, Stanford , USA)","title":"International Committee"},{"location":"community/news/#previous-winners","text":"2015: Guitarix , by Hermann Meyer and Andreas Degert 2016: Ambitools , by Pierre Lecomte; Student prize: TouchVoices , by Pierre-Adrien Th\u00e9o.","title":"Previous Winners"},{"location":"community/news/#2017-12-12-webaudio-wasm-benchmark-pages-and-tools","text":"","title":"2017-12-12: WebAudio wasm benchmark pages and tools"},{"location":"community/news/#webaudio-wasm-benchmark-pages-and-tools","text":"WebAudio wasm benchmark pages and tools allow to test statically generated HTML pages from Faust DSP. Audio generating pages in ScriptProcessor or AudioWorklet mode can be tested first. DSP CPU benchmark pages can be used to test the perfomance of wasm code across different browsers. Tools to generate new DSP CPU benchmark pages are also available, and finally a page allowing to test the dynamic compilation chain can be acccesed.","title":"WebAudio wasm benchmark pages and tools"},{"location":"community/news/#simple-pages","text":"Simple pages can be used to test simple monophonic and polyphonic DSP, generated as ScriptProcessor or AudioWorklet WebAudio nodes. statically generated OSC as a ScriptProcessor node statically generated MIDI controllable Organ as a ScriptProcessor node Note that as 12/12/17, AudioWorklet pages can ony be tested with Chrome Canary. Be sure to activate AudioWorklet mode first. On a MacBook Pro OSX El Capitan 2,2 GHz Intel Core i7, we still hear audio glitches when testing them , for example when opening the JavaScript console, or interacting with other applications (like scrolling in the XCode editor, scrolling in the terminal...) statically generated OSC as an AudioWorlet node statically generated MIDI controllable Organ as an AudioWorlet node","title":"Simple pages"},{"location":"community/news/#polyphonic-midi-aware-pages","text":"More complex statically generated polyphonic MIDI aware pages can be tested. ScriptProcessor based pages: modules/clarinetMIDI.html modules/elecGuitarMIDI.html modules/violinMIDI.html AudioWorklet based pages: modules-worklet/clarinetMIDI.html modules-worklet/elecGuitarMIDI.html modules-worklet/violinMIDI.html","title":"Polyphonic MIDI aware pages"},{"location":"community/news/#benchmark-pages","text":"A set of statically generated pages allow to measure the DSP CPU use of Faust generated WebAssemby code. The compute method is repeatedly called in a loop (taking 100% of a core) which duration is measured. Results as MBytes/sec as well a DSP CPU load in % of a 1024 frames, 44.1 kHz audio buffer are displayed. On the following pages, just hit the Start benchmark button, and wait for the result to be displayed. Note that since the computation is done in the main JavaScript thread, don't disturb your machine too much to get a reliable result. The pages can typically be used to compare the performances of different browsers: bench/clarinetMIDI.html bench/djembe.html bench/filterBank.html bench/freeverb.html bench/frenchBell.html bench/guitarEffectChain.html bench/karplus.html bench/karplus32.html bench/kisana.html bench/spectralLevel.html bench/stunedBar6.html bench/violinMIDI.html bench/zitaRev.html","title":"Benchmark pages"},{"location":"community/news/#testing-the-denormal-issue","text":"A specific problem occurs when audio computation produces denormal float values, which is quite common with recursive filters, and can be extremely costly to compute on some processors like the Intel family for instance. Even with the software FTZ mode, we still see huge DSP CPU issue in some cases like this djembe physical model based on simple biquad filters: modules/djembe.html On OSX for instance, open the Activity Monitor tool and look as your browser CPU use. Then hit the checkbox to start playing, and hit it again to stop it. Silence should be produced, but actually very small sample values (= subnormals) are generated. If your machine uses an Intel CPU, you will see CPU raise quite rapidly ! (tested on a MacBook Pro OSX El Capitan 2,2 GHz Intel Core i7).","title":"Testing the denormal issue"},{"location":"community/news/#benchmark-tools","text":"For developers, benchmark tools allow to generate HTML pages to test your DSP. Look in particular at the faust2benchwasm script.","title":"Benchmark tools"},{"location":"community/news/#dynamic-compilation-chain-testing-page","text":"A more complete testing page for monophonic and polyphonic MIDI aware DSP, ScriptProcessor or AudioWorklet mode, FTZ selection mode is available here .","title":"Dynamic compilation chain testing page"},{"location":"community/news/#2017-11-07-1st-international-faust-conference","text":"","title":"2017-11-07: 1st International Faust Conference"},{"location":"community/news/#1st-international-faust-conference-johannes-gutenberg-university-mainz-germany-july-17-18-2018","text":"The International Faust Conference IFC-18 will take place at the Johannes Gutenberg University of Mainz (Germany) on July 17-18, 2018. It aims at gathering developers and users of the Faust programming language to present current projects and discuss future directions for Faust and its community. Participants will be able to share their work through paper presentations. A series of round tables on various topics will serve as a platform to brainstorm on Faust's features, semantics, tools, applications, etc. to determine future directions for this language. Open spaces for demos and workshops will be available for participants to openly share their ongoing projects with the rest of the community. As a special event, the winner of GRAME's Faust Open-Source Software Competition will be announced during IFC-18. IFC-18 is free and everyone is welcome to attend!","title":"1st International Faust Conference - Johannes Gutenberg University, Mainz (Germany), July 17-18, 2018"},{"location":"community/news/#call-for-papers","text":"We welcome submissions from academic, professional, independent programmers, artists, etc. We solicit original papers centered around the Faust programming language in the following categories: Original research Technology tutorial Artistic project report (e.g., installation, composition, etc.) Paper should be up to 14 pages in length, non anonymous, and formatted according to this template . Submissions should be carried out via our EasyChair portal . All submissions are subject to peer review. Acceptance may be conditional upon changes being made to the paper as directed by reviewers. Accepted papers will be published on-line as well as in the IFC-18 proceedings paper version. They will be presented by their author(s) at IFC-18 as 15 minutes presentations (+ 5 minutes for questions). Feel free to contact us if you have any question.","title":"Call for Papers"},{"location":"community/news/#important-dates_1","text":"Papers submission deadline: March 2, 2018 Notification of Acceptance: May 1, 2018 Camera-Ready Version: June 1, 2018","title":"Important Dates"},{"location":"community/news/#call-for-round-table-topics","text":"A series of round tables on the following themes will take place both afternoons of IFC-18: Faust Tools (e.g., Architectures, IDE, Faust Code Generator, On-Line Services, etc.) DSP in Faust and Faust Libraries (e.g., New Algorithms, New Libraries, Missing Functions, etc.) Faust Compiler and Semantics Other Topics/Open Session We solicit topic suggestions from the Faust community for each of these themes. Topics can be submitted by means of this Google form . They will be introduced during the round tables by the session chair.","title":"Call for Round Table Topics"},{"location":"community/news/#contact","text":"Please, address your questions to: ifc18@muwiinfa.geschichte.uni-mainz.de Conference website: http://www.ifc18.uni-mainz.de","title":"Contact"},{"location":"community/news/#2017-10-20-new-faust-editor","text":"","title":"2017-10-20: New Faust Editor"},{"location":"community/news/#new-faust-editor","text":"We are very happy to announce the online Faust Editor . It can be used to edit , compile and run Faust code from any recent Web Browser with WebAssembly support. This editor works completely on the client side and it is therefore very convenient for situations with many simultaneous users (workshops, classrooms, etc.). It embeds the latest version of the Faust compiler with an efficient WebAssembly backend and offers polyphonic MIDI support.","title":"New Faust Editor"},{"location":"community/news/#features","text":"The editor engine is based on codemirror . It offers syntax highlighting , auto completion and direct access to the online documentation . The documentation command (ctrl-d) uses the function name at the cursor position to locate to the relevant information.","title":"Features"},{"location":"community/news/#recommended-browsers","text":"The recommended browsers are the latest versions of Firefox and Chrome. Chrome is recommended for MIDI, but it requires an https connexion to use the audio inputs. On the other hand MIDI is not supported by Firefox.","title":"Recommended Browsers"},{"location":"community/news/#useful-links","text":"Editor : the official link, https://grame-cncm.github.io/fausteditorweb/ : an alternative link on GitHub. Because this is an https address, audio inputs will work (but not the export function), https://github.com/grame-cncm/fausteditorweb : the GitHub repository.","title":"Useful links"},{"location":"community/news/#2017-09-15-performances-of-audio-dsp-code-compiled-in-webassembly","text":"","title":"2017-09-15: Performances of audio DSP code compiled in WebAssembly"},{"location":"community/news/#performances-of-audio-dsp-code-compiled-in-webassembly","text":"Porting and running large C/C++ code base on the Web have been the subject of several competing projects in the recent years, from Google NaCl/PNaCl to Mozilla asm.js . Recently standardized WebAssembly language inherits from ideas experimented in both approaches, with the Mozilla vision finnally winning as Robert O'Callahan explains here . Coupled with the WebAudio API , running real-time audio code in the Web now appears to be an achievable goal. WebAssembly is a hot topic in the JavaScript ecosystem. The WebAudio community is eagerly waiting for the AudioWorklet specification, with its promised reduced latency and glitch-free audio rendering, to land in browser development versions, and be tested. Porting well established C/C++ codebase with Emscripten , like the Csound framework as an example, or using DSL languages like Faust, will then naturally beneficiate from improved and more stable performances. The Faust ecosystem already allows to generate static or dynamically compiled WebAssembly based WebAudio nodes . These nodes are still using the deprecated ScriptProcessor WebAudio interface. Premillinary work has been started to be ready as soon at the AudioWorklet model will be testable. In the meantime, work have been started using the WAVM , a standalone VM for WebAssembly, that can load both the standard binary and text wasm format, compiling it in native code using the LLVM chain (generating LLVM IR and compiling it on the fly to native code using LLVM JIT compiler), and running it at (near) native speed. Glue code to load and run Faust generated wasm modules has been written. Validation and benchmarking tools have been developed. Performances comparison with the C++ and LLVM IR Faust backends is the subject of this post.","title":"Performances of audio DSP code compiled in WebAssembly"},{"location":"community/news/#comparing-the-faust-c-llvm-ir-and-wastwasm-backends","text":"The WebAssembly approach promises near native performances for C/C++ written code compiled to WebAssembly using the Emscripten tool chain. Other languages like Rust (using the mir2wasm tool) experiment direct WebAssembly generation. It seems clear that as WebAssembly specification and implementation stabilize, more and more languages will directly generate wasm to be deployed in browsers. The question of the quality of code generation at each step of the compilation chain will rapidly emerge. While WebAssembly is initially designed to run on the Web, it may be deployed in non Web environnement like nodejs , or even in standalone VM like WAVM . Thus WebAssembly becomes a portable binary format that can be used in a large variety of situations. This is especially of interest for a DSL language like Faust.","title":"Comparing the Faust C++, LLVM IR and wast/wasm backends"},{"location":"community/news/#faust-wastwasm-backend","text":"Faust wast/wasm backend directly produce WebAssembly code from the Faust internal FIR (Faust Imperative Representation) code. Generated modules are rather light since they define a very simple ABI to be used by the loader code. Two generation models have been defined: in monophonic mode the wast/mast module internally allocates a memory block to be used for the DSP state (controllers, delays lines, waveforms...) as well as audio buffers. in polyphonic mode, the memory block will be allocated by the loader environnement. This block will typically be sized to contain all the needed voices for the polyphonic DSP. In both cases, a full description of the DSP state as a JSON string is generated in the module data segment (including memory indexes of all controllers). Loader code will get and decode this JSON description, and use whatever parts of the description it needs to run the DSP code. In particular, control memory zones (corresponding to the UI items like buttons, sliders, bargraph...) can be directly read/written by the wrapper code.","title":"Faust wast/wasm backend"},{"location":"community/news/#benchmark-of-c-llvm-ir-and-wastwasm-generated-code","text":"Since Faust already generates C++ or LLVM IR code, the performances of those two backends can be compared with the new wasm one. Using the WAVM C++ written machine allows to deploy the same measuring code . The first benchmark compares the speed of C++, LLVM IR and wasm backends running a set of DSP, running on a MacBook Pro 2,2 GHz Core I7 with OSX El capitan. The same 4.0 version of LLVM toolchain has been used with the three backend. C++ and LLVM IR code has been compiled with the -Ofast optimization flag, the WAVM runtime is the standard version one (without any specific audio optimization, see later): The diagrams clearly shows that the wasm code is still slower than C++ or LLVM IR code, but speed difference is not so high in most cases. Some DSP behaviours need to be understood in more details.","title":"Benchmark of C++, LLVM IR and wast/wasm generated code"},{"location":"community/news/#optimizing-the-wavm-runtime-for-audio-code","text":"The WAVM runtime strictly conforms to the WebAssembly specification, thus behaving as a interesting base reference. In the audio domain, the deployed code is usually compiled with specific optimization flags. Since C++ WAVM runtime can be hacked quite easily, we did several changes into the reference implementation to gain some speed: removing the atomic flag in all load/store that are added to pass all spec WebAssembly tests. adding the equivalent of -fast-math compilation flag that have to be done at LLVM IR and JIT (= native) generation steps. and finally simplifying some mathematical operators, using their standard definition instead of the specific WAVM coded ones that strictly implement WebAssembly official semantic (see for instance the definition of f32.min/f32.max operations). Here is the diagram of DSP examples run with reference WAVM runtime, and the three specific optimizations: After generating the LLVM IR code, the WAVM runtime runs a set of LLVM IR to IR optimizations passes. It remains to be tested if adding more optimization passes (especially the auto-vectorizations ones) could help producing even better code.","title":"Optimizing the WAVM runtime for audio code"},{"location":"community/news/#webassembly-module-optimization-with-binaryen","text":"Binaryen is a compiler and toolchain infrastructure library for WebAssembly , written in C++. We tested the wasm-opt tool at -O3 level on Faust generated wasm modules to estimate which speedup we can expect. The following diagram shows limited gains, with no more than 5% in some of the tested cases:","title":"WebAssembly module optimization with Binaryen"},{"location":"community/news/#float-denormal-handling","text":"A specific problem occurs when audio computation produces denormal float values, which is quite common with recursive filters, and can be extremely costly to compute on some processors like the Intel family for instance. A Flush To Zero (FTZ) mode for denormals can usually be set at hardware level, but it not yet available in the WebAssembly MVP version, which strictly conform to the IEEE 754 norm 8. Thus an automatic software strategy which consists in adding FTZ code in all recursive loops has been implemented in the Faust compiler. To activate it, the -ftz compilation parameter must be used at compilation time. The -ftz 1 mode adds a test in each recursive loop which uses the fabs function and a threshold to detect subnormal samples (slower). The -ftz 2 mode adds a test in each recursive loop which uses a mask to detect subnormal samples (faster). Even if using software ftz is not strictly needed in our benchmark chain (since the C++ WAVM uses the ftz hardware protection mode), we can still compare the speed of the different ftz options. Here is the result of code generated with -ftz from 0 to 2:","title":"Float denormal handling"},{"location":"community/news/#comparing-three-browsers-on-osx-el-capitan","text":"HTML test pages were prepared to compare the performances of the three main browsers on OSX El Capitan. The DSP code is compiled with float denormal protection on (-ftz 2). The generated wasm module compute method is called repeatedly in a timed loop, using successive slices of a big allocated circular audio buffer to avoid cache effects. Here are the results: The fasted one (Chrome for now) can be compared with C++, LLVM IR, WAVM native engines, all compiled with float denormal protection on (-ftz 2):","title":"Comparing three browsers on OSX El Capitan"},{"location":"community/news/#comments-and-conclusion","text":"Testing wasm JIT machines inside browsers is not an easy task. The C++ WAVM runtime revealed to be an excellent tool to compare the Faust C++, LLVM IR and wasm backend. Since its code can be easily adapted, one can estimate also what can be expected deploying wasm DSP modules in pure native environments , outside of the browser, where some audio specific optimizations may be considered. Measures done on a set of Faust DSP show that WebAssembly code still run slower than C++ or LLVM IR generated code in most cases, up to almost 66% slower in the less favorable examples. This value will typically be a bit worse when deploying in browsers, since float denormal protection code has to be used . Benchmarks in browser wasm runtime still need to be done to confirm or refine these findings. Comparing the Chrome , Firefox and WebKit browsers on OSX El Capitan shows that Chrome is currently the fastest engine in most cases, with Firefox and WebKit quite similar (with a slight plus for WebKit). Comparing the Chrome browser with native engines shows results from 4,8 times slower (filterBank.dsp), 2,8 times slower (sTunedBar6.dsp) up to much more favorable cases (karplus32.dsp). Note that filterBank.dsp example is a bit of a pathological case, since Chrome is significantly slower than Firefox and WebKit in this case, and filterBank.dsp uses a lot of pow(10, x) code that is rewritten an optimized as exp10(x) with the C++ backend path.","title":"Comments and Conclusion"},{"location":"community/news/#2017-08-18-deploying-faust-dsp-on-the-web","text":"","title":"2017-08-18: Deploying Faust DSP on the Web"},{"location":"community/news/#deploying-faust-dsp-on-the-web","text":"EDIT : we are at the Web Audio conference 2017, and it appears that the way we currently extend the ScripProcessorNode with Faust code is not the Right Way... Part of the post concerning the exposed API will probably change a bit in the near future... Using latest developments done for the Web (the new WebAssembly backends and libfaust library compiled in WebAssembly with Emscripten), statically and dynamically Faust generated WebAudio nodes can be easily produced and deployed on the Web.","title":"Deploying Faust DSP on the Web"},{"location":"community/news/#deploying-statically-compiled-faust-webaudio-nodes","text":"From a foo.dsp source file, JavaScript and the associated WebAssembly files can be produced with the following script: faust2wasm foo.dsp This will generate a foo.wasm file with the WebAssembly module as binary code, as well as a foo.js wrapper file containing the code needed to turn the Faust DSP in a fully working WebAudio node (using an extended ScriptProcessor node). The name of the Faust DSP code file is used to define the final ScriptProcessorNode constructor name. So for instance if osc.dsp file is compiled, the following faust.createosc function will be generated: /** * Create a 'monophonic' ScriptProcessorNode Web Audio object * by loading and compiling the Faust wasm file * * @param context - the Web Audio context * @param buffer_size - the buffer_size in frames * @param callback - a callback taking the created ScriptProcessorNode as parameter, * or null in case of error */ faust.createosc = function(context, buffer_size, callback) The resulting object is an extended ScriptProcessorNode, to be used as a regular node (like connected to other WebAudio nodes), but which also adds the Faust specific API as defined in the equivalent C++ generated dsp class (see the architecture/faust/dsp/dsp.h header for more technical details), as well as JavaScript more specific functions. For instance the following ones will have to be used to control the node: var paths = node.getParams(); // get the set of paths to read/write input control parameters Then knowing the path for a given parameter, the following function is used to change the parameter value: node.setParamValue(\"/Oscillator/freq\", 0.6); A full JSON description of the node with the complete UI, can be retrieved with: var json = node.getJSON(); The complete usable API is fully documented in the generated JavaScript file in the Public API to be used to control the WebAudio node section.","title":"Deploying statically compiled Faust WebAudio nodes"},{"location":"community/news/#a-simple-example-web-page","text":"A simple Web page using the files generated by faust2wasm on the noise.dsp file can be defined with the following parts: <!-- Load 'faust2wasm' script generated .js file --> <script src=\"noise.js\"></script> A slider to control the noise volume parameter is defined with: <P> Noise volume: <input type=\"range\" oninput=\"changeVolume(event) \"min=\"0\" max=\"1\" value=\"0.5\" step=\"0.01\"/> The WebAudio context is created and the noise slide hander is defined with: var isWebKitAudio = (typeof (webkitAudioContext) !== \"undefined\"); var audio_context = (isWebKitAudio) ? new webkitAudioContext() : new AudioContext(); var noise = null; // Slider handler to change the 'noise' volume function changeVolume(event) { noise.setParamValue(\"/Noise/Volume\", parseFloat(event.target.value)); } A startnoise function which creates the Faust WebAudio node is defined with: function startnoise() { // Create the Faust generated node faust.createnoise(audio_context, 1024, function (node) { noise = node; console.log(noise.getJSON()); // Print paths to be used with 'setParamValue' console.log(noise.getParams()); // Connect it to output as a regular WebAudio node noise.connect(audio_context.destination); }); } An finally the load handler is defined to activate the code: window.addEventListener(\"load\", startnoise); Look at the Noise and OSC online pages for the complete code. Note that pages loading an additional .wasm file cannot directly be loaded in Chrome. You'll have to start a local server (using the python -m SimpleHTTPServer command for instance) and access them with their http:// based URL.","title":"A simple example Web page"},{"location":"community/news/#generating-polyphonic-webaudio-nodes","text":"Assuming that the compiled Faust DSP file is polyphonic ready , a polyphonic ready WebAudio node can be created with the -poly parameter, and will generate the following constructor for the node (where the mydsp part will be replaced by the actual DSP name): /** * Create a 'polyphonic' ScriptProcessorNode Web Audio object * by loading and compiling the Faust wasm file * to be use for the voice, and allocating the number of needed voices * * @param context - the Web Audio context * @param buffer_size - the buffer_size in frames * @param polyphony - the number of polyphonic voices * @param callback - a callback taking the created ScriptProcessorNode * as parameter, or null in case of error */ faust.createmydsp_poly = function(context, buffer_size, polyphony, callback) Polyphonic nodes have an extended API to be controled with MIDI messages: /** * Instantiates a new polyphonic voice. * * @param channel - the MIDI channel (0..15, not used for now) * @param pitch - the MIDI pitch (0..127) * @param velocity - the MIDI velocity (0..127) */ keyOn = function (channel, pitch, velocity) /** * De-instantiates a polyphonic voice. * * @param channel - the MIDI channel (0..15, not used for now) * @param pitch - the MIDI pitch (0..127) * @param velocity - the MIDI velocity (0..127) */ keyOff = function (channel, pitch, velocity) /** * Gently terminates all the active voices. */ allNotesOff = function () Look at the JavaScript public documentation section for the complete description.","title":"Generating Polyphonic WebAudio nodes"},{"location":"community/news/#extended-control-with-comb-parameter","text":"The faust2wasm tool can be used with the -comb parameter to compile several DSP files and contatenate all JavaScript code in a unique resulting comb.js file (possibly to be used in -poly mode also).","title":"Extended control with -comb parameter"},{"location":"community/news/#generating-fully-working-self-contained-html-pages","text":"The faust2webaudiowasm script can be used to generate a fully working self-contained HTML page, with a SVG/CSS a Graphical User Interface. From the osc.dsp Faust DSP source file, it will generate an osc.html file: faust2webaudiowasm osc.dsp Assuming that the compiled Faust DSP file is polyphonic ready, the -poly parameter can be used to generate a polyphonic MIDI controlable instrument, to be used with a MIDI application or device. The -links generates the DSP processor SVG representation, and links to the original DSP file as well as generated SVG files, so that the HTML page can possibly be deployed as a reusable Faust DSP resource.","title":"Generating fully working self-contained HTML pages"},{"location":"community/news/#webassembly-module-optimization","text":"Assuming that you have Binaryen tools installed on your machine, the faust2wasm and faust2webaudiowasm scripts can take an additional -opt parameter to allow WebAssembly module optimization.","title":"WebAssembly module optimization"},{"location":"community/news/#deploying-dynamically-compiled-faust-webaudio-nodes","text":"Since the libfaust library is available for the Web, it becomes possible to embed the complete dynamic compilation chain in a Web page , from the Faust DSP source to the executable WebAudio node. First the following resources (located on the Faust GitHub in architecture/webaudio folder) have to be loaded in the page: <!-- Load 'libfaust' library and wrapper code --> <script src=\"libfaust-wasm.js\"></script> <script src=\"webaudio-wasm-wrapper.js\"></script> Then the two following functions are used to generate factories, creating later on monophonic or polyphonic instances (this is necessary because of the way internal WebAssembly memory is managed): /** * Create a DSP factory from source code as a string to be used to create monophonic DSP * * @param code - the source code as a string * @param argv - an array of parameters to be given to the Faust compiler * @param callback - a callback taking the created DSP factory as parameter, * or null in case of error */ faust.createDSPFactory = function (code, argv, callback) /** * Create a DSP factory from source code as a string to be used to create polyphonic DSP * * @param code - the source code as a string * @param argv - an array of parameters to be given to the Faust compiler * @param callback - a callback taking the created DSP factory as parameter, * or null in case of error */ faust.createPolyDSPFactory = function (code, argv, callback) The two following functions are used to generate monophonic or polyphonic Faust WebAudio nodes: /** * Create a ScriptProcessorNode Web Audio object from a factory * * @param factory - the DSP factory * @param context - the Web Audio context * @param buffer_size - the buffer_size in frames * @param callback - a callback taking the created ScriptProcessorNode as parameter, * or null in case of error */ faust.createDSPInstance = function (factory, context, buffer_size, callback) /** * Create a 'polyphonic' 'ScriptProcessorNode Web Audio object from a factory * * @param factory - the DSP factory * @param context - the Web Audio context * @param buffer_size - the buffer_size in frames * @param polyphony - the number of polyphonic voices * @param callback - a callback taking the created ScriptProcessorNode as parameter, * or null in case of error */ faust.createPolyDSPInstance = function (factory, context, buffer_size, polyphony, callback) The resulting nodes have the same API as statically compiled nodes described in the first section, so can be controlled the same way, including the polyphonic ones. Here is a code example using faust.createDSPFactory and faust.createDSPInstance : var isWebKitAudio = (typeof (webkitAudioContext) !== \"undefined\"); var audio_context = (isWebKitAudio) ? new webkitAudioContext() : new AudioContext(); var dsp_code = \"import(\\\"stdfaust.lib\\\"); vol = hslider(\\\"volume [unit:dB]\\\", 0, -96, 0, 0.1) : ba.db2linear : si.smoo; freq = hslider(\\\"freq [unit:Hz]\\\", 1000, 20, 24000, 1); process = vgroup(\\\"Oscillator\\\", os.osc(freq) * vol);\"; var osc = null; var libraries_url = \"/modules/libraries/\"; function startosc() { // Prepare argv list var argv = []; argv.push(\"-ftz\"); argv.push(\"2\"); argv.push(\"-I\"); argv.push(libraries_url); // Dynamically create the Faust generated node from explicit DSP source in 'dsp_code' faust.createDSPFactory(dsp_code, argv, function (factory) { faust.createDSPInstance(factory, audio_context, 1024 function (node) { osc = node; console.log(osc.getJSON()); // Print paths to be used with 'setParamValue' console.log(osc.getParams()); // Connect it to output as a regular WebAudio node osc.connect(audio_context.destination); })}); } The Dynamic OSC page demonstrates the dynamic OSC complete code (based on the example seen before). The Dynamic Organ page demonstrates a polyphonic organ instrument, which loads a DSP from an url, and ready to be controlled with a MIDI device or application. Look at the Dynamic Faust compiler page for a more complete use-case of the dynamic compiler.","title":"Deploying dynamically compiled Faust WebAudio nodes"},{"location":"community/news/#float-denormal-handling_1","text":"A specific problem occurs when audio computation produces denormal float values, which is quite common with recursive filters, and can be extremely costly to compute on some processors like the Intel family for instance. A Flush To Zero (FTZ) mode for denormals can usually be set at hardware level, but it not yet available in the WebAssembly MVP version, which strictly conform to the IEEE 754 norm 8. Thus an automatic software strategy which consists in adding FTZ code in all recursive loops has been implemented in the Faust compiler. To activate it, the -ftz compilation parameter must be used at compilation time. The -ftz 1 mode adds a test in each recursive loop which uses the fabs function and a threshold to detect subnormal samples (slower). The -ftz 2 mode adds a test in each recursive loop which uses a mask to detect subnormal samples (faster). Use for example the following line to active software denormal handing when using faust2wasm tool: faust2wasm -ftz 2 foo.dsp The same for the faust2webaudiowasm tool: faust2webaudiowasm -ftz 2 foo.dsp For dynamic compilation, the -ftz v flag will have to be added in the argv parameter in faust.createDSPFactory or faust.createPolyDSPFactory , like for instance: faust.createPolyFactory(dsp_code, ['-ftz', '2'], callback);","title":"Float denormal handling"},{"location":"community/news/#2017-06-16-using-a-custom-memory-allocator","text":"","title":"2017-06-16: Using a custom memory allocator"},{"location":"community/news/#using-a-custom-memory-allocator","text":"From a DSP source file, the Faust compiler typically generates a C++ class. When a rdtable item is used on the source code, the C++ class will contain a table shared by all instances of the class. By default, this table is generated as a static class array, and so allocated in the application global static memory. In some specific case (usually in more constrained deployment cases), managing where this data is allocated is crucial. By extension this post explains how a custom memory allocator can be used to precisely control the DSP memory allocation.","title":"Using a custom memory allocator"},{"location":"community/news/#faust-mem-option-to-control-memory-related-code-generation","text":"A new -mem compiler parameter has been added in the Faust compiler, starting from the 0.9.103 version (or 2.1.4 in Faust2 branch). This parameter will change the way static shared tables are generated. The table is allocated as a class static pointer allocated using a custom memory allocator , which has the following propotype: struct dsp_memory_manager { virtual ~dsp_memory_manager() {} virtual void* allocate(size_t size) = 0; virtual void destroy(void* ptr) = 0; }; Taking the following Faust DSP example: process = (waveform {10,20,30,40,50,60,70}, %(7)~+(3) : rdtable), (waveform {1.1,2.2,3.3,4.4,5.5,6.6,7.7}, %(7)~+(3) : rdtable); Here is the generated code in default mode: ... int mydsp::itbl0[7]; float mydsp::ftbl0[7]; static void classInit(int samplingFreq) { SIG0 sig0; sig0.init(samplingFreq); sig0.fill(7,itbl0); SIG1 sig1; sig1.init(samplingFreq); sig1.fill(7,ftbl0); } virtual void init(int samplingFreq) { classInit(samplingFreq); instanceInit(samplingFreq); } virtual void instanceInit(int samplingFreq) { instanceConstants(samplingFreq); instanceResetUserInterface(); instanceClear(); } ... The two itbl0 and ftbl0 tables are static class arrays. They are filled in the classInit method. The architecture code will typically call the init method (which calls classInit ) on a given DSP, to allocate class related arrays and the DSP itself. If several DSP are going to be allocated, calling classInit only once then the instanceInit method on each allocated DSP is the way to go. In the new -mem mode, the generated C++ code is now: ... int* mydsp::itbl0 = 0; float* mydsp::ftbl0 = 0; dsp_memory_manager* mydsp::fManager = 0; static void classInit(int samplingFreq) { SIG0 sig0; itbl0 = static_cast<int*>(fManager->allocate(sizeof(int) * 7)); sig0.init(samplingFreq); sig0.fill(7,itbl0); SIG1 sig1; ftbl0 = static_cast<float*>(fManager->allocate(sizeof(float) * 7)); sig1.init(samplingFreq); sig1.fill(7,ftbl0); } static void classDestroy() { fManager->destroy(itbl0); fManager->destroy(ftbl0); } virtual void init(int samplingFreq) {} virtual void instanceInit(int samplingFreq) { instanceConstants(samplingFreq); instanceResetUserInterface(); instanceClear(); } ... The two itbl0 and ftbl0 tables are generated a class static pointers. The classInit method takes the additional dsp_memory_manager object used to allocate tables. A new classDestroy method is available to deallocate the tables. Finally the init method is now empty, since the architecure file is supposed to use the classInit/classDestroy method once to allocate and deallocate static tables, and the instanceInit method on each allocated DSP.","title":"Faust -mem option to control memory related code generation"},{"location":"community/news/#control-of-the-dsp-memory-allocation","text":"An architecture file can now define its custom memory manager by subclassing the dsp_memory_manager abstract base class, and implement the two required allocate and destroy methods. Here is an example of a simple heap allocating manager: struct malloc_memory_manager : public dsp_memory_manager { virtual void* allocate(size_t size) { void* res = malloc(size); cout << \"malloc_manager: \" << size << endl; return res; } virtual void destroy(void* ptr) { cout << \"free_manager\" << endl; free(ptr); } };","title":"Control of the DSP memory allocation"},{"location":"community/news/#controlling-the-table-memory-allocation","text":"To control table memory allocation, the architecture file will have to do: // Allocate a custom memory allocator malloc_memory_manager manager; // Setup manager for the class mydsp::fManager = &manager; // Allocate the dsp instance using regular C++ new mydsp* dsp = new mydsp(); // Allocate static tables (using the custom memory allocator) mydsp::classInit(48000); // Initialise the given instance dsp->instanceInit(48000); ... ... // Deallocate the dsp instance using regular C++ delete delete dsp; // Deallocate static tables (using the custom memory allocator) mydsp::classDestroy();","title":"Controlling the table memory allocation"},{"location":"community/news/#controlling-the-complete-dsp-memory-allocation","text":"Full control the DSP memory allocation can be done using C++ placement new : #include <new> // Allocate a custom memory allocator malloc_memory_manager manager; // Setup manager for the class mydsp::fManager = &manager; // Placement new using the custom allocator mydsp* dsp = new(manager.allocate(sizeof(mydsp))) mydsp(); // Allocate static tables (using the custom memory allocator) mydsp::classInit(48000); // Initialise the given instance dsp->instanceInit(48000); ... ... // Calling the destructor dsp->~mydsp(); // Deallocate the pointer itself using the custom memory allocator manager.destroy(dsp); // Deallocate static tables (using the custom memory allocator) mydsp::classDestroy(); More complex custom memory allocators can be developed by refining this malloc_memory_manager example, possibly defining real-time memory allocators...etc... The OWL architecture file already uses this new custom memory allocator model. This is a work in progress: in the Faust2 branch, this model is still not supported yet beside the C++ backend custom memory allocator is not yet supported is additional DSP classes (like the mydsp_poly defined in the achitecture/faust/dsp/poly-dsp.h header).","title":"Controlling the complete DSP memory allocation"},{"location":"community/news/#2017-04-26-optimizing-the-dsp-cpu-usage","text":"","title":"2017-04-26: Optimizing the DSP CPU usage"},{"location":"community/news/#optimizing-the-dsp-cpu-usage","text":"The Faust compiler has as lot of different compilation parameters to play with. Discovering them for a given DSP program is something that can be automated. Two measure_dsp and dsp_optimizer classes are available for developers to measure DSP CPU use directly in their code. Two more friendly faustbench and faustbench-llvm tools have been developed using them. They allow to discover the best Faust compiler parameters, to be used later on with faust2xx scripts, faustgen~ Max/MSP external or FaustLive .","title":"Optimizing the DSP CPU usage"},{"location":"community/news/#the-measure_dsp-and-dsp_optimizer-dsp-decorator-classes","text":"The measure_dsp class defined in the faust/dsp/dsp-bench.h file allows to decorate a given DSP object and measure its compute method CPU consumption. Results are given in Megabytes/seconds (higher is better). Here is a C++ code example of its use: static void bench(dsp* dsp, const string& name) { // Init the DSP dsp->init(48000); // Wraps it with a 'measure_dsp' decorator measure_dsp mes(dsp, 1024, 5); // Measure the CPU use mes.measure(); // Print the stats cout << name << \" CPU use : \" << mes.getStats() << endl; } Only part of the Faust2 branch and defined in the faust/dsp/dsp-optimizer.h file, the dsp_optimizer class uses the libfaust library and its LLVM backend to dynamically compile DSP objects produced with different Faust compiler options, and then measure their DSP CPU. Here is a C++ code example of its use: static void dynamic_bench(const string& dsp_source) { // Init the DSP optimizer with the dsp_source to compile // (either the filename or source code string) dsp_optimizer optimizer(dsp_source, \"/usr/local/share/faust\", \"\", 1024); double value; // Discover the best set of parameters vector<string> options = optimizer.findOptimizedParameters(value); // Print the result cout << \"Best value is for '\" << argv[1] << \"' is : \" << value << \" with \"; for (int i = 0; i < options.size(); i++) { cout << options[i] << \" \"; } cout << endl; }","title":"The measure_dsp and dsp_optimizer DSP decorator classes"},{"location":"community/news/#using-the-faustbench-tool","text":"The faustbench tool uses the C++ backend to generate a set of C++ files produced with different Faust compiler options. All files are then compiled in a unique binary that will measure DSP CPU of all versions of the compiled DSP. The tool is supposed to be launched in a terminal, but it can be used to generate an iOS project, ready to be launched and tested in Xcode. Here are the available options: faustbench [-ios] [Additional Faust options (-vec -vs 8...)] <file.dsp> Use '-ios' to generate an iOS project Use 'export CXX=/path/to/compiler' before running faustbench to change the C++ compiler Use 'export CXXFLAGS=options' before running faustbench to change the C++ compiler options Here is a trace of its use: faustbench karplus32.dsp Selected compiler is g++ with CXXFLAGS = -Ofast -scal : 77.5123 -vec -lv 0 -vs 4 : 64.2194 -vec -lv 0 -vs 8 : 80.8951 -vec -lv 0 -vs 16 : 106.244 ..... -vec -lv 1 -vs 128 -g : 130.635 -vec -lv 1 -vs 256 -g : 134.335 -vec -lv 1 -vs 512 -g : 135.352 Best value is : 136.235 with -vec -lv 0 -vs 512","title":"Using the faustbench tool"},{"location":"community/news/#using-the-faustbench-llvm-tool","text":"Available in the faust2 branch only, the faustbench-llvm tool uses the libfaust library and its LLVM backend to dynamically compile DSP objects produced with different Faust compiler options, and then measure their DSP CPU. In the main Faust folder, use make bench && sudo make install to build and install the tool. Here is a trace of its use: faustbench-llvm karplus32.dsp Estimate timing parameters -scal : 21.1269 duration = 0.102801 count = 24318 Discover best parameters option -scal : 21.1034 -vec -lv 0 -vs 4 : 42.0734 -vec -lv 0 -vs 8 : 55.3725 -vec -lv 0 -vs 16 : 85.3855 ..... -vec -lv 1 -vs 128 -dfs : 133.974 -vec -lv 1 -vs 256 -dfs : 139.12 -vec -lv 1 -vs 512 -dfs : 91.8424 Refined with -mcd -vec -lv 0 -vs 256 -g -mcd 2 : 83.5555 -vec -lv 0 -vs 256 -g -mcd 4 : 138.519 -vec -lv 0 -vs 256 -g -mcd 8 : 140.122 -vec -lv 0 -vs 256 -g -mcd 16 : 141.558 -vec -lv 0 -vs 256 -g -mcd 32 : 139.454 -vec -lv 0 -vs 256 -g -mcd 64 : 143.405 -vec -lv 0 -vs 256 -g -mcd 128 : 142.975 -vec -lv 0 -vs 256 -g -mcd 256 : 139.345 Best value is for 'karplus32.dsp' is : 142.473 with -vec -lv 0 -vs 256 -dfs -mcd 64 w","title":"Using the faustbench-llvm tool"},{"location":"community/news/#2017-02-21-faust-meets-juce","text":"JUCE is an open-source cross-platform C++ application framework, used for the development of desktop and mobile applications. JUCE is used in particular for its GUI and plugins libraries. A set of architecture files have been developed to deploy standalone or plugins built from Faust code. They allow to automatically generate the GUI from the Faust program, possibly supporting polyphonic instruments, and be controlled by MIDI or OSC messages. The architecture files are then combined to produce ready to compile JUCE applications or plugins, using tools that are part of the Faust distribution. They can also be accessed using the Faust online compiler.","title":"2017-02-21: Faust meets JUCE"},{"location":"community/news/#faust2juce-script","text":"faust2juce transforms a Faust DSP program into a fully working JUCE standalone application or plugin, which can possibly be controlled with MIDI or OSC messages. Read its complete description here . You'll have to get a recent github version of Faust tree to use it.","title":"faust2juce script"},{"location":"community/news/#using-the-online-compiler","text":"The Faust online compiler has been updated to provide new 'juce' targets. Note that only some of the possible compilation options are availble for now: the application target produces a standalone MIDI controlable application (using Faust polyphonic code if the Faust source code is polyphonic aware) the plug-in target produces a MIDI controlable mono or polyphonic plugin (using Faust polyphonic code if the Faust source code is polyphonic aware) the jsynth target produces a MIDI controlable mono or polyphonic plugin (using JUCE polyphonic Synthesizer if the Faust source code is polyphonic aware) Directly using faust2juce provides the full control of the generated target with access to all possible compilation parameters.","title":"Using the online compiler"},{"location":"community/news/#graph-of-faust-generated-plugins","text":"Here is an example of three Faust generated plugins running in JUCE plugin host:","title":"Graph of Faust generated plugins"},{"location":"community/news/#using-libfaust-and-llvm","text":"An alternative to faust2juce static-compilation model, is to use Oliver Larkin's juce_faustllvm module, also used in his pMix2 tool .","title":"Using libfaust and LLVM"},{"location":"community/news/#2017-01-13-faust-webassembly-backend","text":"","title":"2017-01-13: Faust WebAssembly backend"},{"location":"community/news/#faust-webassembly-backend","text":"WebAssembly was born with the premise of creating a safe, portable and fast to load and execute format suitable for the web. WebAssembly its not a programing language but a compilation target with a text and binary specs. That means that other low level languages like C/C++, Rust, Swift, etc. can compile to WebAssembly. Specified and developed by principal browser compagnies (Google, Mozilla, Microsoft and Apple), this new format aims to finally replace the more hackish \"asm.js\" format initialy developed by Mozilla. Development versions of Chrome and Firefox can already execute it. To get an early preview of this experimental technology, at your own risk: on Chrome Canary , open chrome://flags/#enable-webassembly and enable the switch on Firefox Nightly , open about:config and set javascript.options.wasm to true See a preview of Microsoft Edge support and follow Safari support on WebKit\u2019s feature status .","title":"Faust WebAssembly backend"},{"location":"community/news/#webassembly-backends","text":"New WebAssembly backends have been added in the faust2 development branch. They allow to generate textual or binary WebAssembly code.","title":"WebAssembly backends"},{"location":"community/news/#wast-textual-backend","text":"The 'wast' backend allows to generate textual WebAssembly code (in s-expression like format). Note that as of january 2017, the official textual format is not yet fully specified, thus we follow the format used in the binaryen tool . Use the following command to generate the textual output in the terminal for a given foo.dsp file. faust -lang wast foo.dsp The following command: faust -lang wast foo.dsp -o foo.wast will generate the foo.wast textual WebAssembly output file as well as an additional foo.js JavaScript file containing glue code.","title":"'wast' textual backend"},{"location":"community/news/#wasm-binary-backend","text":"The 'wasm' backend allows to generate binary WebAssembly code. Use the following command to generate the binary output in the terminal for a given foo.dsp file. faust -lang wasm foo.dsp The following command: faust -lang wasm foo.dsp -o foo.wasm will generate the foo.wast binary WebAssembly output file as well as an additional foo.js JavaScript file containing glue code.","title":"'wasm' binary backend"},{"location":"community/news/#generating-static-html-pages","text":"WebAssembly code can be feeded into WebAudio JavaScript nodes, which can then be used like any other native WebAudio node. Two scripts are available to generate static WebAudio html pages from a given foo.dsp source file with the generated html/css/svg user interface: faust2webaudiowast foo.dsp will generate the textual WebAssembly output, use binaryen wasm-as tool to convert the wast to wasm format (you'll have to compile and install the binaryen tools on your machine), and produce a self-contained html page. faust2webaudiowasm foo.dsp will generate the binary WebAssembly output that can directly be loaded by the produced self-contained html page. Page containing polyphonic instruments can be generated with the following commands: faust2webaudiowast -poly foo.dsp to use the 'wast' backend and a polyphonic ready foo.dsp, and create a self-contained html page ready to be used with a MIDI instrument. faust2webaudiowasm -poly foo.dsp to use the 'wasm' backend and a polyphonic ready foo.dsp, and create a self-contained html page ready to be used with a MIDI instrument.","title":"Generating static HTML pages"},{"location":"community/news/#2016-10-17-faust-award-2016","text":"The Faust Open Source Software Competition aims at promoting innovative high-quality free audio software developed with Faust, a functional programming language for realtime signal processing and sound synthesis. The competition is sponsored by GRAME , Centre National de Cr\u00e9ation Musicale","title":"2016-10-17: Faust Award 2016"},{"location":"community/news/#faust-award-2016-to-ambitools","text":"The Faust Award 2016 was attributed by an international committee composed of : Jean-Louis Giavitto (IRCAM, Paris, France), Albert Graef (Johannes Gutenberg U., Mainz, Germany), Pierre Jouvelot (Ecole des Mines, Paris, France), Victor Lazzarini (Maynooth U., Maynooth, Ireland), Romain Michon (Stanford U., Palo Alto, USA) Yann Orlarey (GRAME, Lyon, France), Dave Phillips (musician, journalist, and educator, USA) Laurent Pottier (U. Jean Monnet, Saint-Etienne, France), Julius Smith (Stanford U., Palo Alto, USA) to Ambitools , a set of tools for real-time 3D sound field synthesis using higher order ambisonics (HOA). Ambitools is developed by Pierre Lecomte, a PhD candidate at Conservatoire National des Arts et M\u00e9tiers and Sherbrooke University. The core of the sound processing is written in Faust. The tools contain HOA encoders, decoders, binaural-filters, HOA signals transformations, spherical VU-Meter, etc. and can be compiled in various plug-ins format under Windows, Mac OSX, and Linux. The jury praised the quality and the usefulness of Ambitools: a really useful and technically advanced Faust app and an impressive technical achievement ! Check the demo . The committee was also very impressed by the quality of two other projects : Voice of Faust , a voice synthesizer/effects machine by Bart Brouns ( demo ). PMix , a graphical patcher, preset interpolator and JIT compiler for FAUST by Oliver Larkin ( demo ).","title":"Faust Award 2016 to Ambitools"},{"location":"community/news/#faust-student-software-competition-to-touchvoices","text":"In parallel to the main competition, we introduced this year a junior competition: the Faust Student Software Competition , intended to promote small but interesting Faust applications, typically written as student projects. The student prize was awarded to TouchVoices (by Pierre-Adrien Th\u00e9o, RIM Master student at University Jean Monnet) a real-time web application allowing to capture, playback and transform sound loops. Here is a video of Pierre-Adrien Th\u00e9o during a performance with TouchVoices . A very close competitor was SuperBeatRepeater (by Vincent Rateau, of SuperDirt fame), a sample accurate beat repeater. Don't miss the demo !","title":"Faust Student Software Competition to TouchVoices"},{"location":"community/news/#2016-08-30-the-first-faust-book-is-korean","text":"","title":"2016-08-30: The first FAUST book is Korean !"},{"location":"community/news/#the-first-faust-book-is-korean","text":"\u201c Sound Programming using FAUST \u201d, written by Jin-Wook Chae , an experienced audio developer and sound engineer (right) and Hyun-Hoo Jung (left), is the very first book ever published on FAUST. While the book is written in Korean, I was able to really appreciate the choice of the examples and the elegance as well as the high quality of the code. I am sure it will be an invaluable tool to promote FAUST in Korea among sound engineering, computer music students and more generally any person interested in sound programming. This book is for people desiring to produce musical instruments or sound processors. I have always been instructing my students that the ultimate importance is to discover interesting ideas about the sound. In spite of that, I have often relied on an unflattering response such as \"you may need to learn a programming language like C/C++...\" when a student asked for help with how to execute his/her ideas related to sound. Now I am pleased to recommend the use of FAUST to bring such ideas into execution. This is an easy self-study guide that can help to do just that. Now I can confidently tell anybody pursuing sound or electronic music that their exciting and brilliant idea about sound is what truly counts! So, really, how do we execute our ideas? Today I am introducing you to FAUST and to this book which you will find immensely helpful in terms of how to use FAUST to bring your fabulous ideas into reality. Jinwook Chae","title":"The first FAUST book is Korean !"},{"location":"community/news/#2016-06-30-faust-interpreter-backend","text":"A new 'interpreter' backend has been added in the faust2 development branch. It allows to execute Faust programs without using the LLVM dynamic compiler chain.","title":"2016-06-30: Faust interpreter backend"},{"location":"community/news/#interpreter-compilation-chain","text":"The dynamic compilation chain allows developers to embed the Faust compiler technology directly in their application or plugins. Faust2 development branch uses an intermediate FIR representation (Faust Imperative Representation), which can be translated to several output languages. An LLVM backend has been previously developed to allows applications to compile a DSP source into executable code in memory, bypassing the external compiler requirement. In some specific situations, embedding the LLVM chain is not possible : for instance Apple does not allow to deploy dynamic compilers on iOS. Thus having an interpreter backend allows to get around this problem and still make Faust code run on those platforms.","title":"Interpreter compilation chain"},{"location":"community/news/#interpreter-backend","text":"The interpreter backend translates the FIR intermediate language into instructions for a virtual machine. A pure C++ interpreter for this instruction set has been implemented.","title":"Interpreter backend"},{"location":"community/news/#running-and-performances","text":"The interpreter backend translates the FIR intermediate language into bytecode for a virtual machine. It allows to run programs about 4 to 5 slower than native speed . Moreover this interpreter can be compiled in a special 'trace' mode to automatically detect various execution errors : invalid heap access, mathematical errors or warnings (division by zero, integer overloading....) which helps us to check the compiler semantic and code generation quality.","title":"Running and performances"},{"location":"community/news/#deployment-for-developers","text":"Given a Faust source code (as a file or a string), calling the createInterpreterDSPFactoryXXX function runs the compilation chain (Faust + interpreter) and generates the \u201cprototype\u201d of the class, as a interpreter-dsp-factory pointer. class interpreter_dsp_factory : public dsp_factory { public: /* Return Factory name */ std::string getName(); /* Return Factory SHA key */ std::string getSHAKey(); /* Return Factory expanded DSP code */ std::string getDSPCode(); /* Creates a new dsp instance */ dsp* createDSPInstance(); }; Note that the library keeps an internal cache of all allocated factories so that the compilation of the same DSP code, that is same source code and same set of 'normalized' (= sorted in a canonical order) compilations options, will return the same (reference counted) factory pointer. You will have to explicitly use deleteInterpreterDSPFactory to properly decrement the reference counter when the factory is no more needed. You can get a unique SHA1 key of the created factory using its getSHAKey method. Next, the createDSPInstance function, corresponding to the new className of C++, instantiates a interpreter-dsp pointer to be used through its interface, connected to the audio chain and controller interfaces. When finished, simply use delete to destroy the dsp instance. class interpreter_dsp : public dsp { public: void metadata(Meta* m); int getNumInputs(); int getNumOutputs(); void init(int samplingRate); void instanceInit(int samplingRate); dsp* clone(); void buildUserInterface(UI* inter); int getSampleRate(); void compute(int count, FAUSTFLOAT** input, FAUSTFLOAT** output); }; Since interpreter_dsp is a subclass of the dsp base class, an object of this type can be used with all already available audio and UI classes, in essence reusing all architecture files already developed for the static C++ class compilation scheme (like OSCUI, httpdUI interfaces etc.), see Developing a new architecture file .","title":"Deployment for developers"},{"location":"community/news/#savingrestoring-the-factory","text":"After the DSP factory has been compiled, your application or plugin may want to save/restore it in order to save Faust to interpreter bytecode compilation at next use. To get the internal factory compiled code, several functions are available: writeInterpreterDSPFactoryToMachine allows to get the interpreter bytecode as a string, writeInterpreterDSPFactoryToMachineFile allows to save the interpreter bytecode in a file, To re-create a DSP factory from a previously saved code, several functions are available: readInterpreterDSPFactoryFromMachine allows to create a DSP factory from a string containing the interpreter bytecode, readInterpreterDSPFactoryFromMachineFile allows to create a DSP factory from a file containing the interpreter bytecode. The complete API is available and documented in the installed faust/dsp/interpreter-dsp.h header.","title":"Saving/restoring the factory"},{"location":"community/news/#2016-04-07-faust-and-the-web-audio-api","text":"","title":"2016-04-07: Faust and the Web Audio API"},{"location":"community/news/#faust-and-the-web-audio-api-3","text":"The Faust compiler can now directly be used in a Web page. Thanks to the Emscripten compiler, the Faust compiler itself can be compiled to asm.js JavaScript. This has been done by compiling the libfaust C++ library to the libfaust.js JavaScript library, that exports a unique entry point.","title":"Faust and the Web Audio API (3)"},{"location":"community/news/#compiling-dsp-to-javascript-asmjs","text":"The libfaust.js exported function createAsmCDSPFactoryFromString(...) allows to create a DSP factory from a given DSP program as a source string and a set of compilations parameters, uses the Faust compiler asm.js backend, and produces the complete asm.js module and additional pure JavaScript methods as a string. Then calling JavaScript 'eval' function on this string compiles it in the browser. The dynamically created asm.js module and additional pure JavaScript methods can then be used. This internal code in then wrapped with additional JavaScript code. A DSP \u201cfactory\u201d will be created from the DSP source code with the following 'synchronous' code (if using the 'libfaust.js' library): var factory = faust.createDSPFactory(code, arguments); or possibly (if using the 'libfaustworker.js' library in the 'asynchronous' model): faust.createDSPFactory(code, arguments, callback); where 'code' is the DSP source as a string, and 'arguments' is an array of parameters to be given to the Faust compiler (like '-vec', '-vs 512'...), and 'callback' is a function taking the created 'factory' as argument. When no more used, you'll have to explicitly use the following code the deallocate the factory: faust.deleteDSPFactory(factory); Your application may want to save the already compiled factory as asm.js/JavaScript code to speed-up possible restore at later time: var machine_code = faust.writeDSPFactoryToMachine(factory); And restore the factory with the following code: var factory = faust.readDSPFactoryFromMachine(machine_code);","title":"Compiling DSP to JavaScript (asm.js)"},{"location":"community/news/#using-dsp-instances","text":"A fully working DSP \u201cinstance\u201d as a Web Audio node is then created with the code: var dsp = faust.createDSPInstance(factory, audio_context, buffer_size); When no more used, you'll have to explicitly use the following code to deallocate the instance: faust.deleteDSPInstance(dsp); This instance can be used like the statically compiled one, as previously described in this page .","title":"Using DSP instances"},{"location":"community/news/#polyphonic-instruments","text":"Polyphonic instruments can be produced. For a given 'factory' the following code will create a 16 voices polyphonic instance: var dsp = faust.createPolyDSPInstance(factory, audio_context, buffer_size, 16); This instance can be used like the statically compiled one, as previously described in this page .","title":"Polyphonic instruments"},{"location":"community/news/#using-faust-javascript-library","text":"The Emscripten compiled Faust library can be used in two ways. Either using the 'libfaust.js' library: <script src=\"libfaust.js\"></script> <script src=\"webaudio-asm-wrapper.js\"></script> or if using worker mode with the following code which loads the 'libfaustworker.js' library: <script src=\"webaudio/webaudio-asm-worker-wrapper.js\"></script>","title":"Using Faust JavaScript library"},{"location":"community/news/#2016-02-05-faust-award-2016","text":"","title":"2016-02-05: Faust Award 2016"},{"location":"community/news/#faust-award-2016-deadline-june-1-2016","text":"The Faust Open-Source Software Competition is intended to promote innovative high-quality free audio software developed with the Faust programming language, as well as development tools build around the Faust compiler itself. The Faust Open-Source Software award will be attributed to the best submission by an international committee of leading experts in the field. The competition is sponsored by Grame, centre national de cr\u00e9ation musicale. The winning software will receive a 2000\u20ac price to encourage its authors. The results will be announced July 15, 2016. To participate, the software must be provided with source code and licensed with a Free/Open Source license. A substantial part of the software must be written in Faust and the Faust source code must be provided. As part of the review process, the software will be built from the sources. All source code, license, video demonstration, installation instructions, and any other documentation must be available on a public web page. License compatibility with other open source software is encouraged. Dependencies on non-open source third-party software are discouraged, with the exception of operating systems and freely available commercial packages. Authors are required to prepare a video demonstrating the software. This video must be done carefully, and should convincingly present the qualities of the software. The submission must also contain any useful documentation, including examples of how the provided software might be used, existing prototypes that use the software, download statistics or other public usage information. The criteria for judging submissions includes broad applicability and potential impact, novelty, technical depth, reusability, etc.","title":"Faust Award 2016: deadline June 1, 2016"},{"location":"community/news/#junior-competition_1","text":"In parallel to the Faust Open-Source Software Competition we introduce this year a junior competition, the Faust Student Software Competition, with a 200\u20ac prize for the winner. The Faust Student Software Competition is intended to promote interesting audio processing and synthesis applications written in Faust in a single file in less than 1000 words. The word count is done after removing the comments from the code: cat foo.dsp | stripcmt | wc -w. The use of the standard Faust libraries is strongly encouraged. They don't take part in the word count.","title":"Junior Competition"},{"location":"community/news/#important-dates_2","text":"Start of the competition: February 8, 2016 Software Submission Deadline: June 1, 2016 Results of the competition: July 1, 2016","title":"Important dates"},{"location":"community/news/#submission-guidelines_1","text":"Authors interested in participating in the Faust Open Source Software Competition or the Faust Student Software Competition should send a submission email to faustaward@grame.fr with a PDF file attached containing the following information: Title of submission, Category of submission ( Faust Open Source Software Competition or Faust Student Software Competition ), Name, email and affiliation of the main author, Names, emails and affiliations of other authors, A permanent link for the open source software (e.g., Sourceforge, GitHub, Google Code, etc.), A permanent link for the video demonstration (e.g., YouTube, Vimeo, etc.), A link to a compressed archive file that contains the software (source code, documentation, build/install instructions, and licenses). Comprehensive and clear build/install instructions will be a crucial component of any submission. The committee will make a reasonable effort to build the software for the top contributions, but if they are unable to make the software run, it will be excluded from the competition.","title":"Submission Guidelines"},{"location":"community/news/#international-committee_1","text":"Jean-Louis Giavitto (IRCAM, Paris, France), Albert Gr\u00e4f (Johannes Gutenberg U., Mainz, Germany), Pierre Jouvelot (Ecole des Mines, Paris, France), Victor Lazzarini (Maynooth U., Maynooth, Ireland), Romain Michon (CCRMA, Stanford , USA) Yann Orlarey (Grame, Lyon, France), Dave Phillips (Musician/Journalist, Findlay, USA) Laurent Pottier (U. Jean Monnet, Saint Etienne, France), Julius Smith (CCRMA, Stanford , USA)","title":"International Committee"},{"location":"community/news/#previous-winners_1","text":"2015: Guitarix , by Hermann Meyer and Andreas Degert","title":"Previous Winners"},{"location":"community/press/","text":"Faust in the Press 2018 CDM, Vadim is a master of the dark arts of DSP \u2013 listen to him explain filters , October 19, 2018. France Musique, Bernard Cavanna, compositeur agit\u00e9 ! - Albums \"\u00c0 l\u2019agit\u00e9 du bocal\" & \"Le caillou dans la chaussure\" , October 10, 2018. BNEWS, \u0426\u0438\u0444\u0440\u043e\u0432\u0430\u044f \u043e\u0441\u0435\u043d\u044c \u0432 \u0410\u043b\u043c\u0430\u0442\u044b: \u041c\u043e\u043b\u043e\u0434\u044b\u0435 \u043c\u0443\u0437\u044b\u043a\u0430\u043d\u0442\u044b \u0438\u0441\u043f\u043e\u043b\u043d\u0438\u043b\u0438 \u0441\u043e\u0432\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435 \u043f\u0440\u043e\u0438\u0437\u0432\u0435\u0434\u0435\u043d\u0438\u044f \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e \u0433\u0430\u0434\u0436\u0435\u0442\u043e\u0432 , October 18, 2018. iProfesional, Una orquesta sinf\u00f3nica dara un concierto en Buenos Aires junto a un coro de \"smartphones\" , October 06, 2018. SWR Aktuell Rheinland-Pfalz, Programmiersprache macht digitale T\u00f6ne , July 17, 2018. Deutschlandfunk, F\u00fcr einen Mathematiker ist das der Himmel , July 21, 2018. Deutschlandfunk, Radio-Premiere f\u00fcr die Zarenglocke , July 21, 2018. Piekary, Ch\u00f3r\u2026smarfon\u00f3w w Filharmonii \u015al\u0105skiej , May 10, 2018. Tribune de Gen\u00e8ve, Quand smartphones et orchestre s\u2019accordent , March 22, 2018. MDR Th\u00fcringen, Jenaer Philharmonie spielt Smartphone-Konzert , February 26, 2018. iDNES.cz, VIDEO: Filharmonici p\u0159izvali na p\u00f3dium studenty, zahr\u00e1li na sv\u00e9 mobily , February 16, 2018. 2017 Le Dauphin\u00e9 Lib\u00e9r\u00e9, https://www.ledauphine.com/isere-nord/2017/10/28/rejoignez-l-orchestre-de-smartphones , October 28, 2017. Wired.it, Geek Bagatelles, il concerto per orchestra e smartphone , October 18, 2017. Tecnologia, Geek Bagatelles. Al Romaeuropa Festival il concerto per orchestra e coro di smartphone , October 12, 2017. Capital avec Management, Musique et Entreprise : la M\u00e9thode Gagnante de la Soci\u00e9t\u00e9 G\u00e9n\u00e9rale , April 17, 2017. France Info, Fl\u00fbte pr\u00e9historique et ch\u0153ur de smartphones, l\u2019Orchestre de Picardie innove , February 07, 2017. France Info, La smartophonie : quand le portable devient instrument de musique , January 24, 2017. 2016 France Info, SmartFaust, l'application qui transforme les portables en instruments , December, 6, 2016. Le Parisien, \"SmartFaust\", des applis pour jouer de la musique avec son portable , March 26, 2016.","title":"Press"},{"location":"community/press/#faust-in-the-press","text":"","title":"Faust in the Press"},{"location":"community/press/#2018","text":"CDM, Vadim is a master of the dark arts of DSP \u2013 listen to him explain filters , October 19, 2018. France Musique, Bernard Cavanna, compositeur agit\u00e9 ! - Albums \"\u00c0 l\u2019agit\u00e9 du bocal\" & \"Le caillou dans la chaussure\" , October 10, 2018. BNEWS, \u0426\u0438\u0444\u0440\u043e\u0432\u0430\u044f \u043e\u0441\u0435\u043d\u044c \u0432 \u0410\u043b\u043c\u0430\u0442\u044b: \u041c\u043e\u043b\u043e\u0434\u044b\u0435 \u043c\u0443\u0437\u044b\u043a\u0430\u043d\u0442\u044b \u0438\u0441\u043f\u043e\u043b\u043d\u0438\u043b\u0438 \u0441\u043e\u0432\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435 \u043f\u0440\u043e\u0438\u0437\u0432\u0435\u0434\u0435\u043d\u0438\u044f \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e \u0433\u0430\u0434\u0436\u0435\u0442\u043e\u0432 , October 18, 2018. iProfesional, Una orquesta sinf\u00f3nica dara un concierto en Buenos Aires junto a un coro de \"smartphones\" , October 06, 2018. SWR Aktuell Rheinland-Pfalz, Programmiersprache macht digitale T\u00f6ne , July 17, 2018. Deutschlandfunk, F\u00fcr einen Mathematiker ist das der Himmel , July 21, 2018. Deutschlandfunk, Radio-Premiere f\u00fcr die Zarenglocke , July 21, 2018. Piekary, Ch\u00f3r\u2026smarfon\u00f3w w Filharmonii \u015al\u0105skiej , May 10, 2018. Tribune de Gen\u00e8ve, Quand smartphones et orchestre s\u2019accordent , March 22, 2018. MDR Th\u00fcringen, Jenaer Philharmonie spielt Smartphone-Konzert , February 26, 2018. iDNES.cz, VIDEO: Filharmonici p\u0159izvali na p\u00f3dium studenty, zahr\u00e1li na sv\u00e9 mobily , February 16, 2018.","title":"2018"},{"location":"community/press/#2017","text":"Le Dauphin\u00e9 Lib\u00e9r\u00e9, https://www.ledauphine.com/isere-nord/2017/10/28/rejoignez-l-orchestre-de-smartphones , October 28, 2017. Wired.it, Geek Bagatelles, il concerto per orchestra e smartphone , October 18, 2017. Tecnologia, Geek Bagatelles. Al Romaeuropa Festival il concerto per orchestra e coro di smartphone , October 12, 2017. Capital avec Management, Musique et Entreprise : la M\u00e9thode Gagnante de la Soci\u00e9t\u00e9 G\u00e9n\u00e9rale , April 17, 2017. France Info, Fl\u00fbte pr\u00e9historique et ch\u0153ur de smartphones, l\u2019Orchestre de Picardie innove , February 07, 2017. France Info, La smartophonie : quand le portable devient instrument de musique , January 24, 2017.","title":"2017"},{"location":"community/press/#2016","text":"France Info, SmartFaust, l'application qui transforme les portables en instruments , December, 6, 2016. Le Parisien, \"SmartFaust\", des applis pour jouer de la musique avec son portable , March 26, 2016.","title":"2016"},{"location":"community/publications/","text":"Academic Publications Around Faust This page presents a non-exhaustive list of publications around the Faust programming language. If you think one of your papers is missing, let us know and we'll add it! menuholder","title":"Academic Publications"},{"location":"community/publications/#academic-publications-around-faust","text":"This page presents a non-exhaustive list of publications around the Faust programming language. If you think one of your papers is missing, let us know and we'll add it!","title":"Academic Publications Around Faust"},{"location":"community/publications/#menuholder","text":"","title":"menuholder"},{"location":"community/sponsors/","text":"Faust Sponsors","title":"Sponsors"},{"location":"community/sponsors/#faust-sponsors","text":"","title":"Faust Sponsors"}]}