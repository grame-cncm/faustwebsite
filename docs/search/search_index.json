{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is Faust? Faust (Functional Audio Stream) is a functional programming language for sound synthesis and audio processing with a strong focus on the design of synthesizers, musical instruments, audio effects, etc. created at the GRAME-CNCM Research Department . Faust targets high-performance signal processing applications and audio plug-ins for a variety of platforms and standards. The core component of Faust is its compiler. It allows to \"translate\" any Faust digital signal processing (DSP) specification to a wide range of non-domain specific languages such as C++, C, LLVM bit code, WebAssembly, Rust, etc. In this regard, Faust can be seen as an alternative to C++ but is much simpler and intuitive to learn. Thanks to a wrapping system called \"architectures,\" codes generated by Faust can be easily compiled into a wide variety of objects ranging from audio plug-ins to standalone applications or smartphone and web apps, etc. The Faust Web IDE Getting Started If You're in a Hurry If you\u2019re in a hurry and just wanna have a look at how Faust programs look like, you can simply check the Faust Examples . If You Wanna Get Started With Faust If you\u2019re looking for a step by step tutorial of approximately 2 hours that will walk you through writing simple Faust programs and give you an overview of what Faust can do, have a look at our Quick Start Tutorial . If You\u2019re Looking for the \"Manual\" Faust\u2019s syntax and features are thoroughly documented in the Faust Manual . This resource contains hundreds of code examples and many short tutorials. If You\u2019re Looking for the Documentation of a Function in the Faust Libraries The documentation of Faust's standard libraries is automatically generated directly from the libraries' source code. If You prefer Video Tutorials Check out the Faust Kadenze course . If You want to discover Projects Powered by Faust Check out the Powered by Faust page. If You're looking for Papers on Faust Check out Faust papers and reports on HAL . Faust News >> May 01, 2024: Four Google Summer of Code projects attributed Four projects have finally been attributed to GRAME: FaustNet - DDSP aims to continue the work done on adding automatic differentiation in Faust (started in a GSOC 2023 project), to leverage machine learning for audio processing tasks directly within the familiar Faust environment. It will be worked on by Advik Raj Basani . Faust in Cables.gl aims to develop a Cables.gl plugin that compiles Faust DSP code into a WASM AudioWorklet in real-time. It will be worked on by Fay Carsons . Amati++, a VST/CLAP Plugin embedding the dynamic compiler , inspired by the pMix and Amati projects, this plugin will be built using the JUCE framework for the interface and libfaust with LLVM and interpreter backend API to compile Faust code. It will be worked on by Tyler Li . Faust Package Manager aims to add a packaging system to facilitate the integration of Faust libraries in a DSP project. It will be worked on by Shehab Khaled Roshdy . Welcome to the Faust Community ! >> February 21, 2024: GRAME has been selected as a Google Summer of Code 2024 mentor organization Google Summer of Code is a global, online program focused on bringing new contributors into open source software development. GSoC Contributors work with an open source organization on a 12+ week programming project under the guidance of mentors. For the third consecutive year, GRAME has been selected as a mentor organization for the Faust project. >> December 02, 2023: Programmable Audio Workshop (PAW-23) The 6th edition of Programmable Audio Workshop (PAW) will be held on December 2rd at the Marie Curie Library of INSA Lyon (France) on the La Doua campus and is organised by the Emeraude INRIA/INSA/GRAME-CNCM team. This year's theme is \"Artificial intelligence and audio programming languages\", with a strong focus on computer-aided music languages (Faust, ChucK, and PureData). Full program, details of the talks and registration on the PAW website . >> September 09, 2023: faust-web-component released ! Result of Ian Clester Google Summer of Code project, the faust-web-component package provides two web components for embedding interactive Faust snippets in web pages: <faust-editor> displays an editor (using CodeMirror 6 ) with executable, editable Faust code, along with some bells & whistles (controls, block diagram, plots) in a side pane. This component is ideal for demonstrating some code in Faust and allowing the reader to try it out and tweak it themselves without having to leave the page, and can been tested here . <faust-widget> just shows the controls and does not allow editing, so it serves simply as a way to embed interactive DSP, and can been tested here . These components are built on top of faustwasm and faust-ui packages and is released as a npm package . >> September 06, 2023: faust2rnbo released ! The faust2rnbo tool transforms a Faust DSP program into a RNBO patch containing a rnbo~ object and including the codebox code as a subpatch. The tool has been deployed on the Faust remote compilation service, to be used from the Faust Web IDE . All is explained in Using Faust in RNBO with codebox~ tutorial and can be used with the just released Max 8.5.6 version . >> August 28, 2023: Google Summer of Code projects finished Automatic Differentiation in the Faust Compiler aimed at adding automatic differentiation directly in the compiler, so that gradient calculation can be carried out natively in Faust, with applications in Machine Learning algorithms. The project was worked by Thomas Rushton and completed with this Pull Request , and finally integrated in the Faust master-branch . Better Faust on the Web aimed at enhancing Faust\u2019s support for the web platform, and was worked on by Ian Clester . Transitioning the Faust web tools to a rewritten TypeScript version has been completed and deployed in updated versions of the Faust editor and Faust playground and soon in the Faust Web IDE with this Pull Request . A Faust web component embedding the libfaust JS/WebAssembly compiler has been developed and will be used soon in the Faust documentation . The development is fully detailed in this blog post . Thanks Thomas Rushton and Ian Clester for the hard work during the three months period, and Agathe Herrou , David Braun and Jason Freeman for helping mentoring the two projects. >> May 15, 2023: ADCx San Francisco Audio Dev Talks The Audio Developer Conference San Francisco is a one day meet-up for audio developers by the bay. Two conferences are talking about Faust: High-Level Programming of FPGAs for Audio Real-Time Signal Processing Applications by Romain Michon, which can be seen here . Using Faust in JUCE Projects by Julius Smith, which can be seen here . And even the following one with ChatGPT generating running Faust code: Democratization of Audio Dev: How it started, Where it's going by Aurelius Prochazka. >> May 04, 2023: Two Google Summer of Code projects attributed Two projects have finally been attributed to GRAME: Automatic Differentiation in the Faust Compiler aims at adding automatic differentiation directly in the compiler, so that gradient calculation can be carried out natively in Faust, with applications in Machine Learning algorithms. The project will be worked on by Thomas Rushton . Better Faust on the Web aims at enhancing Faust\u2019s support for the web platform: transition the Faust web tools to a rewritten TypeScript version, extend the Faust Web IDE, enhance Faust\u2019s online documentation, and prototype an experimental platform for sharing Faust code on the web. The project will be worked on by Ian Clester . Welcome to both of you in the Faust community ! >> March 24, 2023: Zen Flute 1\u00b0 price at Guthman Musical Instrument 2023 Competition, with Faust inside ! The Guthman Musical Instrument Competition is one of the only competitions of its kind - an event dedicated to identifying the newest and greatest ideas in music. Every year, we invite musical inventors from around the world to share their creations and ideas about the future of music. This year first price is Keith Bexter with the Zen Flute , which sound is produced by a physical model of flute written in Faust , and running on a Teensy audio board . >> February 22, 2023: GRAME has been selected as a Google Summer of Code 2023 mentor organization Google Summer of Code is a global, online program focused on bringing new contributors into open source software development. GSoC Contributors work with an open source organization on a 12+ week programming project under the guidance of mentors. For the second consecutive year, GRAME has been selected as a mentor organization for the Faust project. >> December 03, 2022: Programmable Audio Workshop (PAW-22) The 5th edition of Programmable Audio Workshop (PAW) will be held on December 3rd at the CITI laboratory of INSA Lyon on the La Doua campus. It will be organized this year by the EMERAUDE (Embedded Programmable Audio Systems) team created in 2022 and associating INSA-Lyon, INRIA and GRAME. With 7 conferences in the morning and 4 workshops in the afternoon, PAW addresses this year the theme of networked embedded audio systems, with a particular focus on spatialized sound and FPGAs (Field-Programmable Gate Arrays). Full program, details of the talks and registration on the PAW website . >> October 13, 2022: Google Summer of Code project finished Faust Integration in HISE aimed at integrating support for the Faust audio programming language into HISE, an extensive framework for the creation of sample-based virtual musical instruments. The project has been completed by Roman Sommer with the help of Christoph Hart as mentor, and announced here . >> June 5-12, 2022: Sound Music Computing (SMC-22) at Saint-Etienne (France) SMC-22 (Sound and Music Computing) is a multifaceted event around acoustics, music, and audio technology. It will take place in Saint-\u00c9tienne (France) on June 4-12, 2022 and will have the following theme: Music Technology and Design. As the first \"in person\" edition of SMC after 2 years of COVID-19 pandemic, we aim at widening the public of this event by (i) broadening the scope of SMC concerts through a digital art festival opened to the public, (ii) involving local schools and publics, and (iii) strengthening connections between academia and the industry. SMC-22 will be a combination of a Summer School (June 5-7, 2022), the International Faust Conference (June 7, 2022), the SMC Scientific Conference , Industry-Oriented Events , a Festival (June 8-11, 2022), and a STEAM (Science Technology Engineering Arts and Mathematics) Fair - \"Faites du son!\" (June 9-12). Most Faust related presentations are obviously part of IFC, but several SMC presentations are related to Faust. >> June 7, 2022: Third International Faust Conference (IFC-22) in conjunction with SMC 2022 at Saint-Etienne (France) The International Faust Conference aims at gathering researchers, developers, musicians, computer artists using the Faust programming language. The Third International Faust Conference (IFC-22) will propose sessions of paper presentations, as well as thematic round tables, demonstrations, and tutorials. Participants are encouraged to present current works, projects, etc. and to discuss future directions for Faust and its community. IFC-22 is organized by GRAME-CNCM , INRIA , and Universit\u00e9 Jean Monnet in conjunction with SMC 2022 . It will take place on June 7, 2022 at the Centre des Savoirs pour l\u2019Innovation (CSI) of the Universit\u00e9 Jean Monnet of Saint-Etienne (France). >> May 20, 2022: Two Google Summer of Code projects attributed Two projects have finally been attributed to GRAME: Faust Integration in HISE aims at integrating support for the Faust audio programming language into HISE , an extensive framework for the creation of sample-based virtual musical instruments. The project will be worked on by Roman Sommer . Integrating Faust Into the Bespoke DAW aims at extending the modular Bespoke engine with Faust, allowing for both static compilation of modules, and potentially dynamic programming within Bespoke. The project will be worked on by Drew James . Welcome to both of you in the Faust community ! >> March 7, 2022: GRAME has been selected as a Google Summer of Code 2022 mentor organization Google Summer of Code is a global, online program focused on bringing new contributors into open source software development. GSoC Contributors work with an open source organization on a 12+ week programming project under the guidance of mentors. GRAME has been selected as a mentor organization for the Faust project. >> February 5, 2022: Open Science Award for Open Source Research Software for Faust Great birthday present for the 20th anniversary of the Faust language! Developed by Grame since 2002, supported by a whole community of users and contributors, Faust is one of the four winners of the Open Science Award for Open Source Research Software (documentation category) awarded at the Open Science European Conference (OSEC). >> December 18, 2021: Programmable Audio Workshop (PAW-21) With a combination of talks and workshops, PAW is an intensive day devoted to electronic sounds and programmable audio technologies! The 6 talks and 4 workshops of PAW 2021 , will offer a unique opportunity to discover Procedural Audio in relation with video game engines! >> February 1, 2021: Faust Physical Modeling Workshop -- Online Event Faust has been used for the physical modeling of musical instruments for many years now. Various tools have been developed recently to address the needs of various modeling techniques (e.g., finite difference scheme, waveguides, mass interaction, etc.). The goal of this one day workshop was to provide a series of interactive one-hour tutorials on these tools as well as some background on their related modeling techniques. It took place online on Feb. 1, 2021, 3-9pm GMT+1. Additional information about this event can be found here . >> November 21, 2020: Programmable Audio Workshop (PAW-20) -- Online Event With a combination of talks and workshops, PAW is an intensive day devoted to electronic sounds and programmable audio technologies! PAW-20 will be a fully online event. Information about the free registration process will be posted soon! PAW 2019 >> December 1-2, 2020: International Faust Conference 2020 (IFC-20) -- Online Event The Second International Faust Conference (IFC-20) will take place at the Maison des Sciences de l\u2019Homme Paris Nord (Saint-Denis, France) on December 1-2, 2020. It aims at gathering researchers, developers, musicians, computer artists using the Faust programming language to present current works, creations and projects and discuss future directions for Faust and its community. The 2020 edition is organized by the CICM (Centre de Recherches Informatique et Cr\u00e9ation Musicale) / MUSIDANSE Lab / Universit\u00e9 Paris 8. IFC 2018 >> FAST Project: Fast Audio Signal Processing Technologies on FPGA The FAST project will start in March 2021! It is funded by the Agence Nationale de la Recherche (ANR -- the French National Research Agency). It gathers the strength of GRAME-CNCM , CITI Lab (INSA Lyon) , and LMFA (\u00c9cole Centrale Lyon) towards two goals: facilitate the design of ultra-low latency embedded systems for real-time audio signal processing, use such systems in the context of active control of acoustics. Faust will play a central role in this project.","title":"Home"},{"location":"#what-is-faust","text":"Faust (Functional Audio Stream) is a functional programming language for sound synthesis and audio processing with a strong focus on the design of synthesizers, musical instruments, audio effects, etc. created at the GRAME-CNCM Research Department . Faust targets high-performance signal processing applications and audio plug-ins for a variety of platforms and standards. The core component of Faust is its compiler. It allows to \"translate\" any Faust digital signal processing (DSP) specification to a wide range of non-domain specific languages such as C++, C, LLVM bit code, WebAssembly, Rust, etc. In this regard, Faust can be seen as an alternative to C++ but is much simpler and intuitive to learn. Thanks to a wrapping system called \"architectures,\" codes generated by Faust can be easily compiled into a wide variety of objects ranging from audio plug-ins to standalone applications or smartphone and web apps, etc. The Faust Web IDE","title":"What is Faust?"},{"location":"#getting-started","text":"","title":"Getting Started"},{"location":"#if-youre-in-a-hurry","text":"If you\u2019re in a hurry and just wanna have a look at how Faust programs look like, you can simply check the Faust Examples .","title":"If You're in a Hurry"},{"location":"#if-you-wanna-get-started-with-faust","text":"If you\u2019re looking for a step by step tutorial of approximately 2 hours that will walk you through writing simple Faust programs and give you an overview of what Faust can do, have a look at our Quick Start Tutorial .","title":"If You Wanna Get Started With Faust"},{"location":"#if-youre-looking-for-the-manual","text":"Faust\u2019s syntax and features are thoroughly documented in the Faust Manual . This resource contains hundreds of code examples and many short tutorials.","title":"If You\u2019re Looking for the \"Manual\""},{"location":"#if-youre-looking-for-the-documentation-of-a-function-in-the-faust-libraries","text":"The documentation of Faust's standard libraries is automatically generated directly from the libraries' source code.","title":"If You\u2019re Looking for the Documentation of a Function in the Faust Libraries"},{"location":"#if-you-prefer-video-tutorials","text":"Check out the Faust Kadenze course .","title":"If You prefer Video Tutorials"},{"location":"#if-you-want-to-discover-projects-powered-by-faust","text":"Check out the Powered by Faust page.","title":"If You want to discover Projects Powered by Faust"},{"location":"#if-youre-looking-for-papers-on-faust","text":"Check out Faust papers and reports on HAL .","title":"If You're looking for Papers on Faust"},{"location":"#faust-news","text":"","title":"Faust News"},{"location":"#may-01-2024-four-google-summer-of-code-projects-attributed","text":"Four projects have finally been attributed to GRAME: FaustNet - DDSP aims to continue the work done on adding automatic differentiation in Faust (started in a GSOC 2023 project), to leverage machine learning for audio processing tasks directly within the familiar Faust environment. It will be worked on by Advik Raj Basani . Faust in Cables.gl aims to develop a Cables.gl plugin that compiles Faust DSP code into a WASM AudioWorklet in real-time. It will be worked on by Fay Carsons . Amati++, a VST/CLAP Plugin embedding the dynamic compiler , inspired by the pMix and Amati projects, this plugin will be built using the JUCE framework for the interface and libfaust with LLVM and interpreter backend API to compile Faust code. It will be worked on by Tyler Li . Faust Package Manager aims to add a packaging system to facilitate the integration of Faust libraries in a DSP project. It will be worked on by Shehab Khaled Roshdy . Welcome to the Faust Community !","title":"&gt;&gt; May 01, 2024: Four Google Summer of Code projects attributed"},{"location":"#february-21-2024-grame-has-been-selected-as-a-google-summer-of-code-2024-mentor-organization","text":"Google Summer of Code is a global, online program focused on bringing new contributors into open source software development. GSoC Contributors work with an open source organization on a 12+ week programming project under the guidance of mentors. For the third consecutive year, GRAME has been selected as a mentor organization for the Faust project.","title":"&gt;&gt; February 21, 2024: GRAME has been selected as a Google Summer of Code 2024 mentor organization"},{"location":"#december-02-2023-programmable-audio-workshop-paw-23","text":"The 6th edition of Programmable Audio Workshop (PAW) will be held on December 2rd at the Marie Curie Library of INSA Lyon (France) on the La Doua campus and is organised by the Emeraude INRIA/INSA/GRAME-CNCM team. This year's theme is \"Artificial intelligence and audio programming languages\", with a strong focus on computer-aided music languages (Faust, ChucK, and PureData). Full program, details of the talks and registration on the PAW website .","title":"&gt;&gt; December 02, 2023: Programmable Audio Workshop (PAW-23)"},{"location":"#september-09-2023-faust-web-component-released","text":"Result of Ian Clester Google Summer of Code project, the faust-web-component package provides two web components for embedding interactive Faust snippets in web pages: <faust-editor> displays an editor (using CodeMirror 6 ) with executable, editable Faust code, along with some bells & whistles (controls, block diagram, plots) in a side pane. This component is ideal for demonstrating some code in Faust and allowing the reader to try it out and tweak it themselves without having to leave the page, and can been tested here . <faust-widget> just shows the controls and does not allow editing, so it serves simply as a way to embed interactive DSP, and can been tested here . These components are built on top of faustwasm and faust-ui packages and is released as a npm package .","title":"&gt;&gt; September 09, 2023: faust-web-component released !"},{"location":"#september-06-2023-faust2rnbo-released","text":"The faust2rnbo tool transforms a Faust DSP program into a RNBO patch containing a rnbo~ object and including the codebox code as a subpatch. The tool has been deployed on the Faust remote compilation service, to be used from the Faust Web IDE . All is explained in Using Faust in RNBO with codebox~ tutorial and can be used with the just released Max 8.5.6 version .","title":"&gt;&gt; September 06, 2023: faust2rnbo released !"},{"location":"#august-28-2023-google-summer-of-code-projects-finished","text":"Automatic Differentiation in the Faust Compiler aimed at adding automatic differentiation directly in the compiler, so that gradient calculation can be carried out natively in Faust, with applications in Machine Learning algorithms. The project was worked by Thomas Rushton and completed with this Pull Request , and finally integrated in the Faust master-branch . Better Faust on the Web aimed at enhancing Faust\u2019s support for the web platform, and was worked on by Ian Clester . Transitioning the Faust web tools to a rewritten TypeScript version has been completed and deployed in updated versions of the Faust editor and Faust playground and soon in the Faust Web IDE with this Pull Request . A Faust web component embedding the libfaust JS/WebAssembly compiler has been developed and will be used soon in the Faust documentation . The development is fully detailed in this blog post . Thanks Thomas Rushton and Ian Clester for the hard work during the three months period, and Agathe Herrou , David Braun and Jason Freeman for helping mentoring the two projects.","title":"&gt;&gt; August 28, 2023: Google Summer of Code projects finished"},{"location":"#may-15-2023-adcx-san-francisco-audio-dev-talks","text":"The Audio Developer Conference San Francisco is a one day meet-up for audio developers by the bay. Two conferences are talking about Faust: High-Level Programming of FPGAs for Audio Real-Time Signal Processing Applications by Romain Michon, which can be seen here . Using Faust in JUCE Projects by Julius Smith, which can be seen here . And even the following one with ChatGPT generating running Faust code: Democratization of Audio Dev: How it started, Where it's going by Aurelius Prochazka.","title":"&gt;&gt; May 15, 2023: ADCx San Francisco Audio Dev Talks"},{"location":"#may-04-2023-two-google-summer-of-code-projects-attributed","text":"Two projects have finally been attributed to GRAME: Automatic Differentiation in the Faust Compiler aims at adding automatic differentiation directly in the compiler, so that gradient calculation can be carried out natively in Faust, with applications in Machine Learning algorithms. The project will be worked on by Thomas Rushton . Better Faust on the Web aims at enhancing Faust\u2019s support for the web platform: transition the Faust web tools to a rewritten TypeScript version, extend the Faust Web IDE, enhance Faust\u2019s online documentation, and prototype an experimental platform for sharing Faust code on the web. The project will be worked on by Ian Clester . Welcome to both of you in the Faust community !","title":"&gt;&gt; May 04, 2023: Two Google Summer of Code projects attributed"},{"location":"#march-24-2023-zen-flute-1-price-at-guthman-musical-instrument-2023-competition-with-faust-inside","text":"The Guthman Musical Instrument Competition is one of the only competitions of its kind - an event dedicated to identifying the newest and greatest ideas in music. Every year, we invite musical inventors from around the world to share their creations and ideas about the future of music. This year first price is Keith Bexter with the Zen Flute , which sound is produced by a physical model of flute written in Faust , and running on a Teensy audio board .","title":"&gt;&gt; March 24, 2023: Zen Flute 1\u00b0 price at Guthman Musical Instrument 2023 Competition, with Faust inside !"},{"location":"#february-22-2023-grame-has-been-selected-as-a-google-summer-of-code-2023-mentor-organization","text":"Google Summer of Code is a global, online program focused on bringing new contributors into open source software development. GSoC Contributors work with an open source organization on a 12+ week programming project under the guidance of mentors. For the second consecutive year, GRAME has been selected as a mentor organization for the Faust project.","title":"&gt;&gt; February 22, 2023: GRAME has been selected as a Google Summer of Code 2023 mentor organization"},{"location":"#december-03-2022-programmable-audio-workshop-paw-22","text":"The 5th edition of Programmable Audio Workshop (PAW) will be held on December 3rd at the CITI laboratory of INSA Lyon on the La Doua campus. It will be organized this year by the EMERAUDE (Embedded Programmable Audio Systems) team created in 2022 and associating INSA-Lyon, INRIA and GRAME. With 7 conferences in the morning and 4 workshops in the afternoon, PAW addresses this year the theme of networked embedded audio systems, with a particular focus on spatialized sound and FPGAs (Field-Programmable Gate Arrays). Full program, details of the talks and registration on the PAW website .","title":"&gt;&gt; December 03, 2022: Programmable Audio Workshop (PAW-22)"},{"location":"#october-13-2022-google-summer-of-code-project-finished","text":"Faust Integration in HISE aimed at integrating support for the Faust audio programming language into HISE, an extensive framework for the creation of sample-based virtual musical instruments. The project has been completed by Roman Sommer with the help of Christoph Hart as mentor, and announced here .","title":"&gt;&gt; October 13, 2022: Google Summer of Code project finished"},{"location":"#june-5-12-2022-sound-music-computing-smc-22-at-saint-etienne-france","text":"SMC-22 (Sound and Music Computing) is a multifaceted event around acoustics, music, and audio technology. It will take place in Saint-\u00c9tienne (France) on June 4-12, 2022 and will have the following theme: Music Technology and Design. As the first \"in person\" edition of SMC after 2 years of COVID-19 pandemic, we aim at widening the public of this event by (i) broadening the scope of SMC concerts through a digital art festival opened to the public, (ii) involving local schools and publics, and (iii) strengthening connections between academia and the industry. SMC-22 will be a combination of a Summer School (June 5-7, 2022), the International Faust Conference (June 7, 2022), the SMC Scientific Conference , Industry-Oriented Events , a Festival (June 8-11, 2022), and a STEAM (Science Technology Engineering Arts and Mathematics) Fair - \"Faites du son!\" (June 9-12). Most Faust related presentations are obviously part of IFC, but several SMC presentations are related to Faust.","title":"&gt;&gt; June 5-12, 2022: Sound Music Computing (SMC-22) at Saint-Etienne (France)"},{"location":"#june-7-2022-third-international-faust-conference-ifc-22-in-conjunction-with-smc-2022-at-saint-etienne-france","text":"The International Faust Conference aims at gathering researchers, developers, musicians, computer artists using the Faust programming language. The Third International Faust Conference (IFC-22) will propose sessions of paper presentations, as well as thematic round tables, demonstrations, and tutorials. Participants are encouraged to present current works, projects, etc. and to discuss future directions for Faust and its community. IFC-22 is organized by GRAME-CNCM , INRIA , and Universit\u00e9 Jean Monnet in conjunction with SMC 2022 . It will take place on June 7, 2022 at the Centre des Savoirs pour l\u2019Innovation (CSI) of the Universit\u00e9 Jean Monnet of Saint-Etienne (France).","title":"&gt;&gt; June 7, 2022: Third International Faust Conference (IFC-22) in conjunction with SMC 2022 at Saint-Etienne (France)"},{"location":"#may-20-2022-two-google-summer-of-code-projects-attributed","text":"Two projects have finally been attributed to GRAME: Faust Integration in HISE aims at integrating support for the Faust audio programming language into HISE , an extensive framework for the creation of sample-based virtual musical instruments. The project will be worked on by Roman Sommer . Integrating Faust Into the Bespoke DAW aims at extending the modular Bespoke engine with Faust, allowing for both static compilation of modules, and potentially dynamic programming within Bespoke. The project will be worked on by Drew James . Welcome to both of you in the Faust community !","title":"&gt;&gt; May 20, 2022: Two Google Summer of Code projects attributed"},{"location":"#march-7-2022-grame-has-been-selected-as-a-google-summer-of-code-2022-mentor-organization","text":"Google Summer of Code is a global, online program focused on bringing new contributors into open source software development. GSoC Contributors work with an open source organization on a 12+ week programming project under the guidance of mentors. GRAME has been selected as a mentor organization for the Faust project.","title":"&gt;&gt; March 7, 2022: GRAME has been selected as a Google Summer of Code 2022 mentor organization"},{"location":"#february-5-2022-open-science-award-for-open-source-research-software-for-faust","text":"Great birthday present for the 20th anniversary of the Faust language! Developed by Grame since 2002, supported by a whole community of users and contributors, Faust is one of the four winners of the Open Science Award for Open Source Research Software (documentation category) awarded at the Open Science European Conference (OSEC).","title":"&gt;&gt; February 5, 2022: Open Science Award for Open Source Research Software for Faust"},{"location":"#december-18-2021-programmable-audio-workshop-paw-21","text":"With a combination of talks and workshops, PAW is an intensive day devoted to electronic sounds and programmable audio technologies! The 6 talks and 4 workshops of PAW 2021 , will offer a unique opportunity to discover Procedural Audio in relation with video game engines!","title":"&gt;&gt; December 18, 2021: Programmable Audio Workshop (PAW-21)"},{"location":"#february-1-2021-faust-physical-modeling-workshop-online-event","text":"Faust has been used for the physical modeling of musical instruments for many years now. Various tools have been developed recently to address the needs of various modeling techniques (e.g., finite difference scheme, waveguides, mass interaction, etc.). The goal of this one day workshop was to provide a series of interactive one-hour tutorials on these tools as well as some background on their related modeling techniques. It took place online on Feb. 1, 2021, 3-9pm GMT+1. Additional information about this event can be found here .","title":"&gt;&gt; February 1, 2021: Faust Physical Modeling Workshop -- Online Event"},{"location":"#november-21-2020-programmable-audio-workshop-paw-20-online-event","text":"With a combination of talks and workshops, PAW is an intensive day devoted to electronic sounds and programmable audio technologies! PAW-20 will be a fully online event. Information about the free registration process will be posted soon! PAW 2019","title":"&gt;&gt; November 21, 2020: Programmable Audio Workshop (PAW-20) -- Online Event"},{"location":"#december-1-2-2020-international-faust-conference-2020-ifc-20-online-event","text":"The Second International Faust Conference (IFC-20) will take place at the Maison des Sciences de l\u2019Homme Paris Nord (Saint-Denis, France) on December 1-2, 2020. It aims at gathering researchers, developers, musicians, computer artists using the Faust programming language to present current works, creations and projects and discuss future directions for Faust and its community. The 2020 edition is organized by the CICM (Centre de Recherches Informatique et Cr\u00e9ation Musicale) / MUSIDANSE Lab / Universit\u00e9 Paris 8. IFC 2018","title":"&gt;&gt; December 1-2, 2020: International Faust Conference 2020 (IFC-20) -- Online Event"},{"location":"#fast-project-fast-audio-signal-processing-technologies-on-fpga","text":"The FAST project will start in March 2021! It is funded by the Agence Nationale de la Recherche (ANR -- the French National Research Agency). It gathers the strength of GRAME-CNCM , CITI Lab (INSA Lyon) , and LMFA (\u00c9cole Centrale Lyon) towards two goals: facilitate the design of ultra-low latency embedded systems for real-time audio signal processing, use such systems in the context of active control of acoustics. Faust will play a central role in this project.","title":"&gt;&gt; FAST Project: Fast Audio Signal Processing Technologies on FPGA"},{"location":"Smartphone-Privacy-Policy/","text":"Privacy Policy This smartphone application is a\u200b musical instrument.\u200b It doesn\u2019t collect any personal data of any kind. The microphone input is only used for real-time sound production and no audio recording is ever collected or transmitted. GRAME-CNCM - Centre National de Cr\u00e9ation Musicale, 26 rue Emile Decorps 69100 Villeurbanne FRANCE Phone: +33 4 72 07 37 00","title":"Smartphone Privacy Policy"},{"location":"Smartphone-Privacy-Policy/#privacy-policy","text":"This smartphone application is a\u200b musical instrument.\u200b It doesn\u2019t collect any personal data of any kind. The microphone input is only used for real-time sound production and no audio recording is ever collected or transmitted. GRAME-CNCM - Centre National de Cr\u00e9ation Musicale, 26 rue Emile Decorps 69100 Villeurbanne FRANCE Phone: +33 4 72 07 37 00","title":"Privacy Policy"},{"location":"about/","text":"The Faust Project The Faust Project has started in 2002. It is actively developed by the GRAME-CNCM Research Department . Many persons are contributing to the Faust project, by providing code for the compiler, architecture files, libraries, examples, documentation, scripts, bug reports, ideas, etc. We would like in particular to thank: Fons Adriaensen, Karim Barkati, J\u00e9r\u00f4me Barth\u00e9lemy, Tim Blechmann, Tiziano Bole, Alain Bonardi, Bart Brouns, Thomas Charbonnel, Raffaele Ciavarella, Julien Colafrancesco, Ian Clester, Damien Cramet, Sarah Denoux, \u00c9tienne Gaudrin, R\u00e9mi Georges, Olivier Guillerminet, Pierre Guillot, Albert Gr\u00e4f, Agathe Herrou, Pierre Jouvelot, Stefan Kersten, Victor Lazzarini, Matthieu Leberre, Mathieu Leroi, Fernando Lopez-Lezcano, Kjetil Matheussen, Hermann Meyer, R\u00e9my Muller, Oleg Nesterov, Raphael Panis, Eliott Paris, Reza Payami, Laurent Pottier, Dirk Roosenburg, Thomas Rushton, Dario Sanfilippo, Sampo Savolainen, Nicolas Scaringella, Anne Sedes, Priyanka Shekar, Stephen Sinclair, Travis Skare, Julius Smith, Mike Solomon, Roman Sommer, Michael Wilson. as well as our colleagues at GRAME : Dominique Fober Christophe Lebreton St\u00e9phane Letz Romain Michon Yann Orlarey We would like also to thank for their financial support: the French Ministry of Culture , the Auvergne-Rh\u00f4ne-Alpes Region , the City of Lyon , the French National Research Agency (ANR) .","title":"About"},{"location":"about/#the-faust-project","text":"The Faust Project has started in 2002. It is actively developed by the GRAME-CNCM Research Department . Many persons are contributing to the Faust project, by providing code for the compiler, architecture files, libraries, examples, documentation, scripts, bug reports, ideas, etc. We would like in particular to thank: Fons Adriaensen, Karim Barkati, J\u00e9r\u00f4me Barth\u00e9lemy, Tim Blechmann, Tiziano Bole, Alain Bonardi, Bart Brouns, Thomas Charbonnel, Raffaele Ciavarella, Julien Colafrancesco, Ian Clester, Damien Cramet, Sarah Denoux, \u00c9tienne Gaudrin, R\u00e9mi Georges, Olivier Guillerminet, Pierre Guillot, Albert Gr\u00e4f, Agathe Herrou, Pierre Jouvelot, Stefan Kersten, Victor Lazzarini, Matthieu Leberre, Mathieu Leroi, Fernando Lopez-Lezcano, Kjetil Matheussen, Hermann Meyer, R\u00e9my Muller, Oleg Nesterov, Raphael Panis, Eliott Paris, Reza Payami, Laurent Pottier, Dirk Roosenburg, Thomas Rushton, Dario Sanfilippo, Sampo Savolainen, Nicolas Scaringella, Anne Sedes, Priyanka Shekar, Stephen Sinclair, Travis Skare, Julius Smith, Mike Solomon, Roman Sommer, Michael Wilson. as well as our colleagues at GRAME : Dominique Fober Christophe Lebreton St\u00e9phane Letz Romain Michon Yann Orlarey We would like also to thank for their financial support: the French Ministry of Culture , the Auvergne-Rh\u00f4ne-Alpes Region , the City of Lyon , the French National Research Agency (ANR) .","title":"The Faust Project"},{"location":"downloads/","text":"Faust Downloads Faust comes in many different forms and it can be confusing to know what to install to start using this tool. We recommend you to have a look at the overview of the Faust universe section of the Faust manual . That being said, most of the features of Faust are accessible through the >> Faust Web IDE << so we recommend most people to use this tools which doesn't require any installation. Now, if you really wish to have a local version of Faust on your system, this page should give you an overview of the options that you have. Faust Compiler & libfaust Windows Look for the most recent Faust-XXX-win64.exe on: https://github.com/grame-cncm/faust/releases MacOS Look for the most recent Faust-XXX.dmg on: https://github.com/grame-cncm/faust/releases or use MacPorts or Homebrew package managers Linux Look for the most recent Faust-XXX.tar.gz on: https://github.com/grame-cncm/faust/releases or use your favorite package installer depending of your distribution Building Faust from the Source Alternatively, you might want to build Faust from scratch. For that you can either get the latest release of the Faust source or clone it from our GitRepo . Build instructions are available here . FaustLive FaustLive is an \"on-the-fly\" compiler for Faust (see the overview of the Faust universe for more information) allowing us to instantly run Faust programs. Note that FaustLive is regularly recompiled, but is no more developed, so Faust IDE is the recommended tool to use . Windows Look for the most recent FaustLive-XXX-win64.exe on: https://github.com/grame-cncm/faustlive/releases MacOS Look for the most recent FaustLive-XXX.dmg on: https://github.com/grame-cncm/faustlive/releases Linux Look for the most recent FaustLive-XXX.tar.gz on: https://github.com/grame-cncm/faustlive/releases Building FaustLive from the Source Alternatively, you might want to build FaustLive from scratch. For that you can either get the latest release of the FaustLive source or clone it here . Faustgen Faustgen is a Max/MSP object to compile Faust code dynamically (see the overview of the Faust universe for more information). Windows Look for the most recent faustgen-XXX-win64.zip on: https://github.com/grame-cncm/faust/releases MacOS Look for the most recent faustgen-XXX-macosx.dmg on: https://github.com/grame-cncm/faust/releases FaustWorks FaustWorks is an IDE for the Faust compiler. It is not actively maintained and you should use Faust WEB IDE instead . The source code is available from the FaustWorks github repository .","title":"Downloads"},{"location":"downloads/#faust-downloads","text":"Faust comes in many different forms and it can be confusing to know what to install to start using this tool. We recommend you to have a look at the overview of the Faust universe section of the Faust manual . That being said, most of the features of Faust are accessible through the >> Faust Web IDE << so we recommend most people to use this tools which doesn't require any installation. Now, if you really wish to have a local version of Faust on your system, this page should give you an overview of the options that you have.","title":"Faust Downloads"},{"location":"downloads/#faust-compiler-libfaust","text":"","title":"Faust Compiler &amp; libfaust"},{"location":"downloads/#windows","text":"Look for the most recent Faust-XXX-win64.exe on: https://github.com/grame-cncm/faust/releases","title":"Windows"},{"location":"downloads/#macos","text":"Look for the most recent Faust-XXX.dmg on: https://github.com/grame-cncm/faust/releases or use MacPorts or Homebrew package managers","title":"MacOS"},{"location":"downloads/#linux","text":"Look for the most recent Faust-XXX.tar.gz on: https://github.com/grame-cncm/faust/releases or use your favorite package installer depending of your distribution","title":"Linux"},{"location":"downloads/#building-faust-from-the-source","text":"Alternatively, you might want to build Faust from scratch. For that you can either get the latest release of the Faust source or clone it from our GitRepo . Build instructions are available here .","title":"Building Faust from the Source"},{"location":"downloads/#faustlive","text":"FaustLive is an \"on-the-fly\" compiler for Faust (see the overview of the Faust universe for more information) allowing us to instantly run Faust programs. Note that FaustLive is regularly recompiled, but is no more developed, so Faust IDE is the recommended tool to use .","title":"FaustLive"},{"location":"downloads/#windows_1","text":"Look for the most recent FaustLive-XXX-win64.exe on: https://github.com/grame-cncm/faustlive/releases","title":"Windows"},{"location":"downloads/#macos_1","text":"Look for the most recent FaustLive-XXX.dmg on: https://github.com/grame-cncm/faustlive/releases","title":"MacOS"},{"location":"downloads/#linux_1","text":"Look for the most recent FaustLive-XXX.tar.gz on: https://github.com/grame-cncm/faustlive/releases","title":"Linux"},{"location":"downloads/#building-faustlive-from-the-source","text":"Alternatively, you might want to build FaustLive from scratch. For that you can either get the latest release of the FaustLive source or clone it here .","title":"Building FaustLive from the Source"},{"location":"downloads/#faustgen","text":"Faustgen is a Max/MSP object to compile Faust code dynamically (see the overview of the Faust universe for more information).","title":"Faustgen"},{"location":"downloads/#windows_2","text":"Look for the most recent faustgen-XXX-win64.zip on: https://github.com/grame-cncm/faust/releases","title":"Windows"},{"location":"downloads/#macos_2","text":"Look for the most recent faustgen-XXX-macosx.dmg on: https://github.com/grame-cncm/faust/releases","title":"MacOS"},{"location":"downloads/#faustworks","text":"FaustWorks is an IDE for the Faust compiler. It is not actively maintained and you should use Faust WEB IDE instead . The source code is available from the FaustWorks github repository .","title":"FaustWorks"},{"location":"licence/","text":"The Faust Project The Faust Project has started in 2002. It is actively developed by the GRAME-CNCM Research Department . Many persons are contributing to the Faust project, by providing code for the compiler, architecture files, libraries, examples, documentation, scripts, bug reports, ideas, etc. We would like in particular to thank: Fons Adriaensen, Karim Barkati, J\u00e9r\u00f4me Barth\u00e9lemy, Tim Blechmann, Tiziano Bole, Alain Bonardi, Thomas Charbonnel, Raffaele Ciavarella, Julien Colafrancesco, Damien Cramet, Sarah Denoux, \u00c9tienne Gaudrin, Olivier Guillerminet, Pierre Guillot, Albert Gr\u00e4f, Pierre Jouvelot, Stefan Kersten, Victor Lazzarini, Matthieu Leberre, Mathieu Leroi, Fernando Lopez-Lezcano, Kjetil Matheussen, Hermann Meyer, R\u00e9my Muller, Raphael Panis, Eliott Paris, Reza Payami, Laurent Pottier, Sampo Savolainen, Nicolas Scaringella, Anne Sedes, Priyanka Shekar, Stephen Sinclair, Travis Skare, Julius Smith, Mike Solomon, Michael Wilson, Bart Brouns, Dirk Roosenburg. as well as our colleagues at GRAME : Dominique Fober Christophe Lebreton St\u00e9phane Letz Romain Michon Yann Orlarey We would like also to thank for their financial support: the French Ministry of Culture , the Auvergne-Rh\u00f4ne-Alpes Region , the City of Lyon , the French National Research Agency (ANR) .","title":"The Faust Project"},{"location":"licence/#the-faust-project","text":"The Faust Project has started in 2002. It is actively developed by the GRAME-CNCM Research Department . Many persons are contributing to the Faust project, by providing code for the compiler, architecture files, libraries, examples, documentation, scripts, bug reports, ideas, etc. We would like in particular to thank: Fons Adriaensen, Karim Barkati, J\u00e9r\u00f4me Barth\u00e9lemy, Tim Blechmann, Tiziano Bole, Alain Bonardi, Thomas Charbonnel, Raffaele Ciavarella, Julien Colafrancesco, Damien Cramet, Sarah Denoux, \u00c9tienne Gaudrin, Olivier Guillerminet, Pierre Guillot, Albert Gr\u00e4f, Pierre Jouvelot, Stefan Kersten, Victor Lazzarini, Matthieu Leberre, Mathieu Leroi, Fernando Lopez-Lezcano, Kjetil Matheussen, Hermann Meyer, R\u00e9my Muller, Raphael Panis, Eliott Paris, Reza Payami, Laurent Pottier, Sampo Savolainen, Nicolas Scaringella, Anne Sedes, Priyanka Shekar, Stephen Sinclair, Travis Skare, Julius Smith, Mike Solomon, Michael Wilson, Bart Brouns, Dirk Roosenburg. as well as our colleagues at GRAME : Dominique Fober Christophe Lebreton St\u00e9phane Letz Romain Michon Yann Orlarey We would like also to thank for their financial support: the French Ministry of Culture , the Auvergne-Rh\u00f4ne-Alpes Region , the City of Lyon , the French National Research Agency (ANR) .","title":"The Faust Project"},{"location":"community/bugs/","text":"Reporting Bugs The best way to report a bug in Faust or in any of its associated tool is to submit an issue on the corresponding Git repository: Report a bug in the Faust Compiler , libfaust , faustgen or any other tool part of the Faust distribution Report a bug in the Faust Web Editor Report a bug in the Faust Web IDE Report a bug in the Faust Playground Report a bug in FaustLive Report a bug in FaustWorks Report a bug in the Faust Libraries Report a bug in the Faust Web Services Report a bug in the Faust Online Compiler Report a bug/typo on this website .","title":"Reporting Bugs"},{"location":"community/bugs/#reporting-bugs","text":"The best way to report a bug in Faust or in any of its associated tool is to submit an issue on the corresponding Git repository: Report a bug in the Faust Compiler , libfaust , faustgen or any other tool part of the Faust distribution Report a bug in the Faust Web Editor Report a bug in the Faust Web IDE Report a bug in the Faust Playground Report a bug in FaustLive Report a bug in FaustWorks Report a bug in the Faust Libraries Report a bug in the Faust Web Services Report a bug in the Faust Online Compiler Report a bug/typo on this website .","title":"Reporting Bugs"},{"location":"community/events/","text":"Events Faust Day 2023 Faust Day took place at the Center for Computer Research in Music and Acoustics (CCRMA) at Stanford University on May 20th, 2023. It aimed at: giving an overview of the most recent developments in the Faust programming language, giving an introductory tutorial for those who never used Faust. Where is Faust Going as a Programming Language? -- Yann Orlarey Overview of Recent Developments in the Faust General Ecosystem -- St\u00e9phane Letz Faust and AI -- David Braun Faust in Real-Time Expressive Virtual Musical Instruments -- Julius O. Smith Real-Time Audio DSP With Faust and FPGAs -- Romain Michon Faust Physical Modeling Workshop Faust has been used for the physical modeling of musical instruments for many years now. Different tools have been developed recently to address the needs of various modeling techniques (e.g., finite difference scheme, waveguides, mass interaction, etc.). The goal of this one day online workshop which took place on Feb. 1, 2021 was to provide a series of interactive one-hour tutorials on these tools as well as some background on their related modeling techniques. Creating Circuit-Bendable Wave-Digital Models of Analog Audio Circuits in Faust -- Dirk Roosenburg Download this workshop's code here Wave-digital models are a well researched and popular approach for creating virtual-analog models of audio circuits for use in audio processing. wdmodels.lib is a new addition to the Faust Libraries that supports easy creation of these models in Faust. In this workshop, we will introduce the technique of wave-digital modeling of circuits by analyzing several audio circuits and exploring their implementation in wdmodels.lib . We also will discuss library support of more complex implementation tasks associated with wave-digital models, such as R-type adaptors and Multiple/Multiport non-linearities. Finally, we will conclude by exploring the capacity of Faust to \"circuit-bend\" our wave-digital models. Note : the workshop's code has been adapted to work with the latest version of the wdmodels.lib library embedded in the Faust Web IDE. You'll see some tiny syntax differences between the video and the new syntax. An Introduction to Mass-Interaction Modelling in Faust -- James Leonard and J\u00e9r\u00f4me Villeneuve Download this workshop's code here This workshop proposes an introduction to mass-interaction (sometimes referred to as mass-spring) modelling for sound synthesis in the Faust environment. After a brief historic introduction to this field, we will give a hands on tutorial on the mi_faust library, which allows simulating modular physical constructions in Faust, as well as online model scripting tools that allow for efficient model design and code generation. We will conclude with ongoing developments and perspectives, in particular regarding performance issues, possible extensions to 3-DoF physics, and the importance of modelling frameworks that allow for a creative approach to physical model design. Finite Difference Schemes Synthesis in Faust -- Riccardo Russo Download this workshop's code here Over the years, Faust proved to be a powerful tool for developing physical modeling synthesis. However, coding finite difference schemes models has always been complicated, in fact, their implementation in imperative programming languages is typically achieved using data structures, which are not available in Faust. This workshop will introduce the fds library, a new tool which allows to code linear, explicit finite difference schemes physical models in Faust, based on a cellular automata formalism. We will start with a brief introduction on how finite difference schemes work and what is their place within the scope physical modeling techniques. Then, we will focus on how to implement the algorithms we obtained on paper in Faust and, lastly, we will see how the fds library can be used to code such algorithms in a much easier way. By the end of the tutorial you should have quite an understanding on the basic principles of finite difference schemes, on the roles of the different functions inside the fds library and on how they can be used to easily obtain a working fds physical model. break Introduction to the Faust Physical Modeling Toolkit -- Romain Michon Download this workshop's code here A series of tools to facilitate the implementation of waveguide and modal physical models of musical instruments have been developed over the years by the Faust team to become the \"Faust Physical Modeling Toolkit.\" This comprises the Faust Physical Modeling library ( pm.lib ) as well as mesh2faust , a tool to convert 3D meshes into modal physical models compatible with pm.lib . During this workshop, we will provide a step-by-step tutorial on how to use these different tools to implement various kinds of physical models from scratch. Overview of Physical Modeling Formulations and Faust Implementations -- Julius O. Smith Download this workshop's code is available at https://ccrma.stanford.edu/~jos/aspf/Appendix_A_State_Space_Models.html#code:statespace and https://ccrma.stanford.edu/~jos/aspf/State_Space_BiQuad_FAUST.html#code:statespaceBiquad A summary of methods for physical modeling is followed by some examples in Faust. Physical models normally start out as differential equations which are then digitized to yield finite-difference schemes as were discussed earlier in this workshop. Wave digital and digital waveguide formulations were also discussed. Two additional topics are state-space models and modal representations which can be obtained by diagonalizing state-space models. As a result, this talk focuses primarily on state-space models and how to diagonalize them.","title":"Events"},{"location":"community/events/#events","text":"","title":"Events"},{"location":"community/events/#faust-day-2023","text":"Faust Day took place at the Center for Computer Research in Music and Acoustics (CCRMA) at Stanford University on May 20th, 2023. It aimed at: giving an overview of the most recent developments in the Faust programming language, giving an introductory tutorial for those who never used Faust.","title":"Faust Day 2023"},{"location":"community/events/#where-is-faust-going-as-a-programming-language-yann-orlarey","text":"","title":"Where is Faust Going as a Programming Language? -- Yann Orlarey"},{"location":"community/events/#overview-of-recent-developments-in-the-faust-general-ecosystem-stephane-letz","text":"","title":"Overview of Recent Developments in the Faust General Ecosystem -- St\u00e9phane Letz"},{"location":"community/events/#faust-and-ai-david-braun","text":"","title":"Faust and AI -- David Braun"},{"location":"community/events/#faust-in-real-time-expressive-virtual-musical-instruments-julius-o-smith","text":"","title":"Faust in Real-Time Expressive Virtual Musical Instruments -- Julius O. Smith"},{"location":"community/events/#real-time-audio-dsp-with-faust-and-fpgas-romain-michon","text":"","title":"Real-Time Audio DSP With Faust and FPGAs -- Romain Michon"},{"location":"community/events/#faust-physical-modeling-workshop","text":"Faust has been used for the physical modeling of musical instruments for many years now. Different tools have been developed recently to address the needs of various modeling techniques (e.g., finite difference scheme, waveguides, mass interaction, etc.). The goal of this one day online workshop which took place on Feb. 1, 2021 was to provide a series of interactive one-hour tutorials on these tools as well as some background on their related modeling techniques.","title":"Faust Physical Modeling Workshop"},{"location":"community/events/#creating-circuit-bendable-wave-digital-models-of-analog-audio-circuits-in-faust-dirk-roosenburg","text":"Download this workshop's code here Wave-digital models are a well researched and popular approach for creating virtual-analog models of audio circuits for use in audio processing. wdmodels.lib is a new addition to the Faust Libraries that supports easy creation of these models in Faust. In this workshop, we will introduce the technique of wave-digital modeling of circuits by analyzing several audio circuits and exploring their implementation in wdmodels.lib . We also will discuss library support of more complex implementation tasks associated with wave-digital models, such as R-type adaptors and Multiple/Multiport non-linearities. Finally, we will conclude by exploring the capacity of Faust to \"circuit-bend\" our wave-digital models. Note : the workshop's code has been adapted to work with the latest version of the wdmodels.lib library embedded in the Faust Web IDE. You'll see some tiny syntax differences between the video and the new syntax.","title":"Creating Circuit-Bendable Wave-Digital Models of Analog Audio Circuits in Faust -- Dirk Roosenburg"},{"location":"community/events/#an-introduction-to-mass-interaction-modelling-in-faust-james-leonard-and-jerome-villeneuve","text":"Download this workshop's code here This workshop proposes an introduction to mass-interaction (sometimes referred to as mass-spring) modelling for sound synthesis in the Faust environment. After a brief historic introduction to this field, we will give a hands on tutorial on the mi_faust library, which allows simulating modular physical constructions in Faust, as well as online model scripting tools that allow for efficient model design and code generation. We will conclude with ongoing developments and perspectives, in particular regarding performance issues, possible extensions to 3-DoF physics, and the importance of modelling frameworks that allow for a creative approach to physical model design.","title":"An Introduction to Mass-Interaction Modelling in Faust -- James Leonard and J\u00e9r\u00f4me Villeneuve"},{"location":"community/events/#finite-difference-schemes-synthesis-in-faust-riccardo-russo","text":"Download this workshop's code here Over the years, Faust proved to be a powerful tool for developing physical modeling synthesis. However, coding finite difference schemes models has always been complicated, in fact, their implementation in imperative programming languages is typically achieved using data structures, which are not available in Faust. This workshop will introduce the fds library, a new tool which allows to code linear, explicit finite difference schemes physical models in Faust, based on a cellular automata formalism. We will start with a brief introduction on how finite difference schemes work and what is their place within the scope physical modeling techniques. Then, we will focus on how to implement the algorithms we obtained on paper in Faust and, lastly, we will see how the fds library can be used to code such algorithms in a much easier way. By the end of the tutorial you should have quite an understanding on the basic principles of finite difference schemes, on the roles of the different functions inside the fds library and on how they can be used to easily obtain a working fds physical model.","title":"Finite Difference Schemes Synthesis in Faust -- Riccardo Russo"},{"location":"community/events/#break","text":"","title":"break"},{"location":"community/events/#introduction-to-the-faust-physical-modeling-toolkit-romain-michon","text":"Download this workshop's code here A series of tools to facilitate the implementation of waveguide and modal physical models of musical instruments have been developed over the years by the Faust team to become the \"Faust Physical Modeling Toolkit.\" This comprises the Faust Physical Modeling library ( pm.lib ) as well as mesh2faust , a tool to convert 3D meshes into modal physical models compatible with pm.lib . During this workshop, we will provide a step-by-step tutorial on how to use these different tools to implement various kinds of physical models from scratch.","title":"Introduction to the Faust Physical Modeling Toolkit -- Romain Michon"},{"location":"community/events/#overview-of-physical-modeling-formulations-and-faust-implementations-julius-o-smith","text":"Download this workshop's code is available at https://ccrma.stanford.edu/~jos/aspf/Appendix_A_State_Space_Models.html#code:statespace and https://ccrma.stanford.edu/~jos/aspf/State_Space_BiQuad_FAUST.html#code:statespaceBiquad A summary of methods for physical modeling is followed by some examples in Faust. Physical models normally start out as differential equations which are then digitized to yield finite-difference schemes as were discussed earlier in this workshop. Wave digital and digital waveguide formulations were also discussed. Two additional topics are state-space models and modal representations which can be obtained by diagonalizing state-space models. As a result, this talk focuses primarily on state-space models and how to diagonalize them.","title":"Overview of Physical Modeling Formulations and Faust Implementations -- Julius O. Smith"},{"location":"community/help/","text":"Getting Help Faust Mailing Lists Mailing lists are the oldest way to reach out to the Faust community. If you have a question about the Faust language, the use of one of its associated tools (e.g., FaustLive, the web editor, etc.), or if you just want to follow the latest Faust news, please subscribe and ask your question to: the Faust Users Mailing List If you'd like to follow the development of Faust and of its associated tools and/or if you wish to contribute to it, please subscribe and ask your question to: the Faust Developers Mailing List Faust on discord Connect to the Faust discord server. The Audio Programmer community discord community has a #faust channel. Faust slack channel Slack can also be used to get help with Faust: https://faustaudio.slack.com or this link , but Faust on discord is the preferably way to go. Faust GitHub discussion The discussions can also take place on the Faust GitHub discussion forum .","title":"Getting Help"},{"location":"community/help/#getting-help","text":"","title":"Getting Help"},{"location":"community/help/#faust-mailing-lists","text":"Mailing lists are the oldest way to reach out to the Faust community. If you have a question about the Faust language, the use of one of its associated tools (e.g., FaustLive, the web editor, etc.), or if you just want to follow the latest Faust news, please subscribe and ask your question to: the Faust Users Mailing List If you'd like to follow the development of Faust and of its associated tools and/or if you wish to contribute to it, please subscribe and ask your question to: the Faust Developers Mailing List","title":"Faust Mailing Lists"},{"location":"community/help/#faust-on-discord","text":"Connect to the Faust discord server. The Audio Programmer community discord community has a #faust channel.","title":"Faust on discord"},{"location":"community/help/#faust-slack-channel","text":"Slack can also be used to get help with Faust: https://faustaudio.slack.com or this link , but Faust on discord is the preferably way to go.","title":"Faust slack channel"},{"location":"community/help/#faust-github-discussion","text":"The discussions can also take place on the Faust GitHub discussion forum .","title":"Faust GitHub discussion"},{"location":"community/ifc/","text":"International Faust Conference (IFC) The International Faust Conference (IFC) takes place every two years. It aims at gathering developers and users of the Faust programming language to present current projects and discuss future directions for Faust and its community. Participants share their work through paper presentations. A series of round tables on various topics serve as a platform to brainstorm on Faust's features, semantics, tools, applications, etc. to determine future directions for this language. Open spaces for demos and workshops are usually available for participants to openly share their ongoing projects with the rest of the community. Next Edition: IFC-24 - November 21-22, 2024 in Torino (Italy) The fourth edition of the International Faust Conference ( IFC-24 ) will be held on November 21-22, 2024 in Torino (Italy). Past Editions IFC-22 - June 7-8, 2022 - During SMC-22 at St-Etienne (France) The third edition of the International Faust Conference (IFC-22) took place during SMC-22 at St-Etienne (France) on June 7-8, 2022, with morning recording and afternoon recording . IFC-20 - MSH Paris Nord Saint-Denis (France) The second edition of the International Faust Conference (IFC-20) took place at the Maison des Sciences de l\u2019Homme Paris Nord on December 1-2, 2020. IFC-18 - JGU, Mainz (Germany) The first edition of the International Faust Conference (IFC-18) took place at the Johannes Gutenberg University of Mainz (Germany) on July 17-18, 2018.","title":"International Faust Conference"},{"location":"community/ifc/#international-faust-conference-ifc","text":"The International Faust Conference (IFC) takes place every two years. It aims at gathering developers and users of the Faust programming language to present current projects and discuss future directions for Faust and its community. Participants share their work through paper presentations. A series of round tables on various topics serve as a platform to brainstorm on Faust's features, semantics, tools, applications, etc. to determine future directions for this language. Open spaces for demos and workshops are usually available for participants to openly share their ongoing projects with the rest of the community.","title":"International Faust Conference (IFC)"},{"location":"community/ifc/#next-edition-ifc-24-november-21-22-2024-in-torino-italy","text":"The fourth edition of the International Faust Conference ( IFC-24 ) will be held on November 21-22, 2024 in Torino (Italy).","title":"Next Edition: IFC-24 - November 21-22, 2024 in Torino (Italy)"},{"location":"community/ifc/#past-editions","text":"","title":"Past Editions"},{"location":"community/ifc/#ifc-22-june-7-8-2022-during-smc-22-at-st-etienne-france","text":"The third edition of the International Faust Conference (IFC-22) took place during SMC-22 at St-Etienne (France) on June 7-8, 2022, with morning recording and afternoon recording .","title":"IFC-22 - June 7-8, 2022 - During SMC-22 at St-Etienne (France)"},{"location":"community/ifc/#ifc-20-msh-paris-nord-saint-denis-france","text":"The second edition of the International Faust Conference (IFC-20) took place at the Maison des Sciences de l\u2019Homme Paris Nord on December 1-2, 2020.","title":"IFC-20 - MSH Paris Nord Saint-Denis (France)"},{"location":"community/ifc/#ifc-18-jgu-mainz-germany","text":"The first edition of the International Faust Conference (IFC-18) took place at the Johannes Gutenberg University of Mainz (Germany) on July 17-18, 2018.","title":"IFC-18 - JGU, Mainz (Germany)"},{"location":"community/learning/","text":"Learning Faust Faust Kadenze Course In 2018, Yann Orlarey and Romain Michon shot an online course on the Kadenze platform on Real Time Audio Signal Processing in Faust . The videos of this course are free to watch online . Center for Computer Research in Music and Acoustics (CCRMA) Several courses on Faust are given at CCRMA: Julius Smith's Faust tutorial , Writing a Slew Limiter in the Faust Language and Make an Eight Channel Mixer in the Faust IDE Romain Michon's Faust tutorials Music 250a (Physical Interaction Design for Music) course which hosts various tutorials on Faust and hardware Music 250a 2021 and related videos Music 320c (Audio Plugin Development in Faust and C++) Embedded DSP With Faust Workshop TU Berlin The regular sound synthesis class at the Audio Communication Group, TU Berlin, makes use of Faust for exploring the basics of different synthesis algorithms. Student projects based on Faust include Eurorack modules, standalone drum machines and synthesizers, as well as data sonification approaches. The class is taught by Henrik von Coler , who is director of the Electronic Studio at the TU, with a Building Instruments in Faust course. HPI Potsdam The class Data Sonification & Opportunities of Sound at Hasso Plattner Institute, University of Potsdam Potsdam, is an interdisciplinary format, exploring the use of sonification and sound synthesis in the context of design thinking, neurosience and medical applications. The signal processing part is taught by Henrik von Coler . Universit\u00e9 Paris 8 A 24 hours introduction to Faust is given by Alain Bonardi during the first semester to undergraduated students (L3, 3rd year after the french 'baccalaur\u00e9at') in the framework of the course \"Programming Languages in Computer Music 1\" offered in the \"Music creation with computerqs\" minor. Universidad Nacional de Quilmes Cursos de Faust / DSP en espan\u0303ol, realizados por Juan Ramos . Incluyen las clases del \"Seminario de Actualizacio\u0301n en Sonido, Ciencia y Tecnologi\u0301a II\", dictado en la Universidad Nacional de Quilmes (Argentina) en 2021. Faust / DSP courses in Spanish, prepared by Juan Ramos . They include the classes of the \"Update Seminar on Sound, Science and Technology II\", held at the National University of Quilmes (Argentina) in 2021: An intro video is available here All available classes are located here Professional Masters of RIM & RAN The Professional RIM & RAN Masters are aimed at developing students applied knowledge and understanding of electronic and digital technologies for the creation, prepare them to the professions of Producer in Computer Music (RIM - R\u00e9alisateur en Informatique Musicale) and in Digital Arts (RAN - R\u00e9alisateur en Arts Num\u00e9riques) . These producers are direct actors in musical and artistic productions, and work at the interface between software developers, applied computer scientists, composers, artists, etc. and all people likely to integrate video, image and sound in their activities. Most of the courses concerning signal processing are given around the Faust language (M1 Romain Michon 12h / M2 Yann Orlarey 20h). Johannes Gutenberg University of Mainz To complete...","title":"Learning Faust"},{"location":"community/learning/#learning-faust","text":"","title":"Learning Faust"},{"location":"community/learning/#faust-kadenze-course","text":"In 2018, Yann Orlarey and Romain Michon shot an online course on the Kadenze platform on Real Time Audio Signal Processing in Faust . The videos of this course are free to watch online .","title":"Faust Kadenze Course"},{"location":"community/learning/#center-for-computer-research-in-music-and-acoustics-ccrma","text":"Several courses on Faust are given at CCRMA: Julius Smith's Faust tutorial , Writing a Slew Limiter in the Faust Language and Make an Eight Channel Mixer in the Faust IDE Romain Michon's Faust tutorials Music 250a (Physical Interaction Design for Music) course which hosts various tutorials on Faust and hardware Music 250a 2021 and related videos Music 320c (Audio Plugin Development in Faust and C++) Embedded DSP With Faust Workshop","title":"Center for Computer Research in Music and Acoustics (CCRMA)"},{"location":"community/learning/#tu-berlin","text":"The regular sound synthesis class at the Audio Communication Group, TU Berlin, makes use of Faust for exploring the basics of different synthesis algorithms. Student projects based on Faust include Eurorack modules, standalone drum machines and synthesizers, as well as data sonification approaches. The class is taught by Henrik von Coler , who is director of the Electronic Studio at the TU, with a Building Instruments in Faust course.","title":"TU Berlin"},{"location":"community/learning/#hpi-potsdam","text":"The class Data Sonification & Opportunities of Sound at Hasso Plattner Institute, University of Potsdam Potsdam, is an interdisciplinary format, exploring the use of sonification and sound synthesis in the context of design thinking, neurosience and medical applications. The signal processing part is taught by Henrik von Coler .","title":"HPI Potsdam"},{"location":"community/learning/#universite-paris-8","text":"A 24 hours introduction to Faust is given by Alain Bonardi during the first semester to undergraduated students (L3, 3rd year after the french 'baccalaur\u00e9at') in the framework of the course \"Programming Languages in Computer Music 1\" offered in the \"Music creation with computerqs\" minor.","title":"Universit\u00e9 Paris 8"},{"location":"community/learning/#universidad-nacional-de-quilmes","text":"Cursos de Faust / DSP en espan\u0303ol, realizados por Juan Ramos . Incluyen las clases del \"Seminario de Actualizacio\u0301n en Sonido, Ciencia y Tecnologi\u0301a II\", dictado en la Universidad Nacional de Quilmes (Argentina) en 2021. Faust / DSP courses in Spanish, prepared by Juan Ramos . They include the classes of the \"Update Seminar on Sound, Science and Technology II\", held at the National University of Quilmes (Argentina) in 2021: An intro video is available here All available classes are located here","title":"Universidad Nacional de Quilmes"},{"location":"community/learning/#professional-masters-of-rim-ran","text":"The Professional RIM & RAN Masters are aimed at developing students applied knowledge and understanding of electronic and digital technologies for the creation, prepare them to the professions of Producer in Computer Music (RIM - R\u00e9alisateur en Informatique Musicale) and in Digital Arts (RAN - R\u00e9alisateur en Arts Num\u00e9riques) . These producers are direct actors in musical and artistic productions, and work at the interface between software developers, applied computer scientists, composers, artists, etc. and all people likely to integrate video, image and sound in their activities. Most of the courses concerning signal processing are given around the Faust language (M1 Romain Michon 12h / M2 Yann Orlarey 20h).","title":"Professional Masters of RIM &amp; RAN"},{"location":"community/learning/#johannes-gutenberg-university-of-mainz","text":"To complete...","title":"Johannes Gutenberg University of Mainz"},{"location":"community/logos/","text":"Faust Logos The Faust logo is available in several variants (Full Logo, Simple Logo, Faust Award, and Made with Faust). The Adobe Illustrator file is available here Full Logo Very nice and trendy on your T-shirt... Blue White Grey Orange Simple Logo If you don't have too much space... Blue White Grey Orange Faust Awards And the winner is... Blue White Grey Orange Made with Faust For your next killer app... Blue White Grey Orange","title":"Logos"},{"location":"community/logos/#faust-logos","text":"The Faust logo is available in several variants (Full Logo, Simple Logo, Faust Award, and Made with Faust). The Adobe Illustrator file is available here","title":"Faust Logos"},{"location":"community/logos/#full-logo","text":"Very nice and trendy on your T-shirt...","title":"Full Logo"},{"location":"community/logos/#blue","text":"","title":"Blue"},{"location":"community/logos/#white","text":"","title":"White"},{"location":"community/logos/#grey","text":"","title":"Grey"},{"location":"community/logos/#orange","text":"","title":"Orange"},{"location":"community/logos/#simple-logo","text":"If you don't have too much space...","title":"Simple Logo"},{"location":"community/logos/#blue_1","text":"","title":"Blue"},{"location":"community/logos/#white_1","text":"","title":"White"},{"location":"community/logos/#grey_1","text":"","title":"Grey"},{"location":"community/logos/#orange_1","text":"","title":"Orange"},{"location":"community/logos/#faust-awards","text":"And the winner is...","title":"Faust Awards"},{"location":"community/logos/#blue_2","text":"","title":"Blue"},{"location":"community/logos/#white_2","text":"","title":"White"},{"location":"community/logos/#grey_2","text":"","title":"Grey"},{"location":"community/logos/#orange_2","text":"","title":"Orange"},{"location":"community/logos/#made-with-faust","text":"For your next killer app...","title":"Made with Faust"},{"location":"community/logos/#blue_3","text":"","title":"Blue"},{"location":"community/logos/#white_3","text":"","title":"White"},{"location":"community/logos/#grey_3","text":"","title":"Grey"},{"location":"community/logos/#orange_3","text":"","title":"Orange"},{"location":"community/news/","text":"Faust News 2018-07-23: Faust's Evolution View the evolution of the Faust project from 2004 to 2018. The visualization was done using Gource . Here is the command used (as suggested by fullybacked ): gource --hide dirnames,filenames --seconds-per-day 0.1 --auto-skip-seconds 1 -1920x1024 -o - | ffmpeg -y -r 60 -f image2pipe -vcodec ppm -i - -vcodec libx264 -preset ultrafast -pix_fmt yuv420p -crf 1 -threads 0 -bf 0 faust-hd.mp4 2018-07-23: Faust Award 2018 The Faust Open Source Software Competition aims at promoting innovative high-quality free audio software developed with Faust, a functional programming language for realtime signal processing and sound synthesis. The competition is sponsored by GRAME , Centre National de Cr\u00e9ation Musicale. Faust Award 2018 to iPlug 2 The Faust Award 2018 was attributed by an international committee composed of : Jean-Louis Giavitto (IRCAM, Paris, France), Albert Graef (Johannes Gutenberg U., Mainz, Germany), Pierre Jouvelot (Ecole des Mines, Paris, France), Victor Lazzarini (Maynooth U., Maynooth, Ireland), Romain Michon (Stanford U., Palo Alto, USA) Yann Orlarey (GRAME, Lyon, France), Laurent Pottier (U. Jean Monnet, Saint-Etienne, France), Julius Smith (Stanford U., Palo Alto, USA) to iPlug 2 a free open source C++ audio plug-in framework, allowing developers to create audio plug-ins and apps across a wide range of formats from the same code, including graphical user interface and DSP components. Amongst many other new features and a reworked code base, version 2 includes support for FAUST, allowing sections of audio DSP to be implemented using the FAUST language, and easily integrated with other C++ elements. iPlug 2 is developed by Oliver Larkin and Alex Harker from the original iPlug, by Cockos inc. that was open sourced in 2008. The project is under active development and will be publicly released at the end of 2018. The jury praised the quality, the ambition, and the usefulness of iPlug 2 as a Faust development framework! Check the demo here . We hope that the Faust Award will help the authors to fully finalize the project. Faust Student Software Competition to Cloud Generator In parallel to the main competition, the Faust Student Software Competition , is intended to promote small, but innovative Faust applications, typically developed in the framework of student projects. The student prize 2018 was awarded to Cloud Generator a nine-voice polyphonic synthesizer developed by Rittik Wystup. The jury praised the audio quality and the care taken by Rittik Wystup in his project! Check the Cloud Generator demo here . 2018-07-10: IFC 2018 International Faust Conference IFC18 : July 17-18, 2018 The International Faust Conference IFC18 will take place at the Johannes Gutenberg University of Mainz (Germany) on July 17-18, 2018. It aims at gathering developers and users of the Faust programming language to present current projects and discuss future directions for Faust and its community. Participants will be able to share their work through paper presentations. A series of round tables on various topics will serve as a platform to brainstorm on Faust's features, semantics, tools, applications, etc. to determine future directions for this language. Open spaces for demos and workshops will be available for participants to openly share their ongoing projects with the rest of the community. As a special event, the winner of GRAME's Faust Open-Source Software Competition will be announced during IFC18 . IFC-18 is free and everyone is welcome to attend! Please register here -- 2018-02-18: Faust Award 2018 Faust Award 2018: deadline June 1, 2018 The Faust Open-Source Software Competition is intended to promote innovative high-quality free audio software developed with the Faust programming language, as well as development tools built around the Faust compiler itself. The Faust Open-Source Software award will be attributed to the best submission by an international committee of leading experts in the field. The competition is sponsored by Grame, centre national de cr\u00e9ation musicale. The winning software will receive a 2000\u20ac price to encourage its authors. The results will be announced July 17, 2018 during the International Faust Conference in Mainz IFC18 . To participate, the software must be provided with source code and licensed with a Free/Open Source license. A substantial part of the software must be written in Faust and the Faust source code must be provided. As part of the review process, the software will be built from the sources. All source code, license, video demonstration, installation instructions, and any other documentation must be available on a public web page. License compatibility with other open source software is encouraged. Dependencies on non-open source third-party software are discouraged, with the exception of operating systems and freely available commercial packages. Authors are required to prepare a video demonstrating the software. This video must be done carefully, and should convincingly present the qualities of the software. The submission must also contain any useful documentation, including examples of how the provided software might be used, existing prototypes that use the software, download statistics or other public usage information. The criteria for judging submissions includes broad applicability and potential impact, novelty, technical depth, reusability, etc. Junior Competition In parallel to the Faust Open-Source Software Competition we have a junior competition, the Faust Student Software Competition, with a 200\u20ac prize for the winner. The Faust Student Software Competition is intended to promote interesting audio processing and synthesis applications written in Faust in a single file in less than 1000 words. The word count is done after removing the comments from the code: cat foo.dsp | stripcmt | wc -w. The use of the standard Faust libraries is strongly encouraged. They don't take part in the word count. Important dates Start of the competition: February 18, 2018 Software Submission Deadline: June 1, 2018 Results of the competition: July 17, 2018 Submission Guidelines Authors interested in participating in the Faust Open Source Software Competition or the Faust Student Software Competition should send a submission email to faustaward@grame.fr with a PDF file attached containing the following information: Title of submission, Category of submission ( Faust Open Source Software Competition or Faust Student Software Competition ), Name, email and affiliation of the main author, Names, emails and affiliations of other authors, A permanent link for the open source software (e.g., Sourceforge, GitHub, Google Code, etc.), A permanent link for the video demonstration (e.g., YouTube, Vimeo, etc.), A link to a compressed archive file that contains the software (source code, documentation, build/install instructions, and licenses). Comprehensive and clear build/install instructions will be a crucial component of any submission. The committee will make a reasonable effort to build the software for the top contributions, but if they are unable to make the software run, it will be excluded from the competition. International Committee Jean-Louis Giavitto (IRCAM, Paris, France), Albert Gr\u00e4f (Johannes Gutenberg U., Mainz, Germany), Pierre Jouvelot (Ecole des Mines, Paris, France), Victor Lazzarini (Maynooth U., Maynooth, Ireland), Romain Michon (CCRMA, Stanford , USA) Yann Orlarey (Grame, Lyon, France), Laurent Pottier (U. Jean Monnet, Saint Etienne, France), Julius Smith (CCRMA, Stanford , USA) Previous Winners 2015: Guitarix , by Hermann Meyer and Andreas Degert 2016: Ambitools , by Pierre Lecomte; Student prize: TouchVoices , by Pierre-Adrien Th\u00e9o. 2017-12-12: WebAudio wasm... WebAudio wasm benchmark pages and tools WebAudio wasm benchmark pages and tools allow to test statically generated HTML pages from Faust DSP. Audio generating pages in ScriptProcessor or AudioWorklet mode can be tested first. DSP CPU benchmark pages can be used to test the perfomance of wasm code across different browsers. Tools to generate new DSP CPU benchmark pages are also available, and finally a page allowing to test the dynamic compilation chain can be acccesed. Simple pages Simple pages can be used to test simple monophonic and polyphonic DSP, generated as ScriptProcessor or AudioWorklet WebAudio nodes. statically generated OSC as a ScriptProcessor node statically generated MIDI controllable Organ as a ScriptProcessor node Note that as 12/12/17, AudioWorklet pages can ony be tested with Chrome Canary. Be sure to activate AudioWorklet mode first. On a MacBook Pro OSX El Capitan 2,2 GHz Intel Core i7, we still hear audio glitches when testing them , for example when opening the JavaScript console, or interacting with other applications (like scrolling in the XCode editor, scrolling in the terminal...) statically generated OSC as an AudioWorlet node statically generated MIDI controllable Organ as an AudioWorlet node Polyphonic MIDI aware pages More complex statically generated polyphonic MIDI aware pages can be tested. ScriptProcessor based pages: modules/clarinetMIDI.html modules/elecGuitarMIDI.html modules/violinMIDI.html AudioWorklet based pages: modules-worklet/clarinetMIDI.html modules-worklet/elecGuitarMIDI.html modules-worklet/violinMIDI.html Benchmark pages A set of statically generated pages allow to measure the DSP CPU use of Faust generated WebAssemby code. The compute method is repeatedly called in a loop (taking 100% of a core) which duration is measured. Results as MBytes/sec as well a DSP CPU load in % of a 1024 frames, 44.1 kHz audio buffer are displayed. On the following pages, just hit the Start benchmark button, and wait for the result to be displayed. Note that since the computation is done in the main JavaScript thread, don't disturb your machine too much to get a reliable result. The pages can typically be used to compare the performances of different browsers: bench/clarinetMIDI.html bench/djembe.html bench/filterBank.html bench/freeverb.html bench/frenchBell.html bench/guitarEffectChain.html bench/karplus.html bench/karplus32.html bench/kisana.html bench/spectralLevel.html bench/stunedBar6.html bench/violinMIDI.html bench/zitaRev.html Testing the denormal issue A specific problem occurs when audio computation produces denormal float values, which is quite common with recursive filters, and can be extremely costly to compute on some processors like the Intel family for instance. Even with the software FTZ mode, we still see huge DSP CPU issue in some cases like this djembe physical model based on simple biquad filters: modules/djembe.html On OSX for instance, open the Activity Monitor tool and look as your browser CPU use. Then hit the checkbox to start playing, and hit it again to stop it. Silence should be produced, but actually very small sample values (= subnormals) are generated. If your machine uses an Intel CPU, you will see CPU raise quite rapidly ! (tested on a MacBook Pro OSX El Capitan 2,2 GHz Intel Core i7). Benchmark tools For developers, benchmark tools allow to generate HTML pages to test your DSP. Look in particular at the faust2benchwasm script. Dynamic compilation chain testing page A more complete testing page for monophonic and polyphonic MIDI aware DSP, ScriptProcessor or AudioWorklet mode, FTZ selection mode is available here . 2017-11-07: 1st IFC 1st International Faust Conference - Johannes Gutenberg University, Mainz (Germany), July 17-18, 2018 The International Faust Conference IFC-18 will take place at the Johannes Gutenberg University of Mainz (Germany) on July 17-18, 2018. It aims at gathering developers and users of the Faust programming language to present current projects and discuss future directions for Faust and its community. Participants will be able to share their work through paper presentations. A series of round tables on various topics will serve as a platform to brainstorm on Faust's features, semantics, tools, applications, etc. to determine future directions for this language. Open spaces for demos and workshops will be available for participants to openly share their ongoing projects with the rest of the community. As a special event, the winner of GRAME's Faust Open-Source Software Competition will be announced during IFC-18. IFC-18 is free and everyone is welcome to attend! Call for Papers We welcome submissions from academic, professional, independent programmers, artists, etc. We solicit original papers centered around the Faust programming language in the following categories: Original research Technology tutorial Artistic project report (e.g., installation, composition, etc.) Paper should be up to 14 pages in length, non anonymous, and formatted according to this template . Submissions should be carried out via our EasyChair portal . All submissions are subject to peer review. Acceptance may be conditional upon changes being made to the paper as directed by reviewers. Accepted papers will be published on-line as well as in the IFC-18 proceedings paper version. They will be presented by their author(s) at IFC-18 as 15 minutes presentations (+ 5 minutes for questions). Feel free to contact us if you have any question. Important Dates Papers submission deadline: March 2, 2018 Notification of Acceptance: May 1, 2018 Camera-Ready Version: June 1, 2018 Call for Round Table Topics A series of round tables on the following themes will take place both afternoons of IFC-18: Faust Tools (e.g., Architectures, IDE, Faust Code Generator, On-Line Services, etc.) DSP in Faust and Faust Libraries (e.g., New Algorithms, New Libraries, Missing Functions, etc.) Faust Compiler and Semantics Other Topics/Open Session We solicit topic suggestions from the Faust community for each of these themes. Topics can be submitted by means of this Google form . They will be introduced during the round tables by the session chair. Contact Please, address your questions to: ifc18@muwiinfa.geschichte.uni-mainz.de Conference website: http://www.ifc18.uni-mainz.de 2017-10-20: New Editor New Faust Editor We are very happy to announce the online Faust Editor . It can be used to edit , compile and run Faust code from any recent Web Browser with WebAssembly support. This editor works completely on the client side and it is therefore very convenient for situations with many simultaneous users (workshops, classrooms, etc.). It embeds the latest version of the Faust compiler with an efficient WebAssembly backend and offers polyphonic MIDI support. Features The editor engine is based on codemirror . It offers syntax highlighting , auto completion and direct access to the online documentation . The documentation command (ctrl-d) uses the function name at the cursor position to locate to the relevant information. Recommended Browsers The recommended browsers are the latest versions of Firefox and Chrome. Chrome is recommended for MIDI, but it requires an https connexion to use the audio inputs. On the other hand MIDI is not supported by Firefox. Useful links Editor : the official link, https://grame-cncm.github.io/fausteditorweb/ : an alternative link on GitHub. Because this is an https address, audio inputs will work (but not the export function), https://github.com/grame-cncm/fausteditorweb : the GitHub repository. 2017-09-15: Performances... Performances of audio DSP code compiled in WebAssembly Porting and running large C/C++ code base on the Web have been the subject of several competing projects in the recent years, from Google NaCl/PNaCl to Mozilla asm.js . Recently standardized WebAssembly language inherits from ideas experimented in both approaches, with the Mozilla vision finnally winning as Robert O'Callahan explains here . Coupled with the WebAudio API , running real-time audio code in the Web now appears to be an achievable goal. WebAssembly is a hot topic in the JavaScript ecosystem. The WebAudio community is eagerly waiting for the AudioWorklet specification, with its promised reduced latency and glitch-free audio rendering, to land in browser development versions, and be tested. Porting well established C/C++ codebase with Emscripten , like the Csound framework as an example, or using DSL languages like Faust, will then naturally beneficiate from improved and more stable performances. The Faust ecosystem already allows to generate static or dynamically compiled WebAssembly based WebAudio nodes . These nodes are still using the deprecated ScriptProcessor WebAudio interface. Premillinary work has been started to be ready as soon at the AudioWorklet model will be testable. In the meantime, work have been started using the WAVM , a standalone VM for WebAssembly, that can load both the standard binary and text wasm format, compiling it in native code using the LLVM chain (generating LLVM IR and compiling it on the fly to native code using LLVM JIT compiler), and running it at (near) native speed. Glue code to load and run Faust generated wasm modules has been written. Validation and benchmarking tools have been developed. Performances comparison with the C++ and LLVM IR Faust backends is the subject of this post. Comparing the Faust C++, LLVM IR and wast/wasm backends The WebAssembly approach promises near native performances for C/C++ written code compiled to WebAssembly using the Emscripten tool chain. Other languages like Rust (using the mir2wasm tool) experiment direct WebAssembly generation. It seems clear that as WebAssembly specification and implementation stabilize, more and more languages will directly generate wasm to be deployed in browsers. The question of the quality of code generation at each step of the compilation chain will rapidly emerge. While WebAssembly is initially designed to run on the Web, it may be deployed in non Web environnement like nodejs , or even in standalone VM like WAVM . Thus WebAssembly becomes a portable binary format that can be used in a large variety of situations. This is especially of interest for a DSL language like Faust. Faust wast/wasm backend Faust wast/wasm backend directly produce WebAssembly code from the Faust internal FIR (Faust Imperative Representation) code. Generated modules are rather light since they define a very simple ABI to be used by the loader code. Two generation models have been defined: in monophonic mode the wast/mast module internally allocates a memory block to be used for the DSP state (controllers, delays lines, waveforms...) as well as audio buffers. in polyphonic mode, the memory block will be allocated by the loader environnement. This block will typically be sized to contain all the needed voices for the polyphonic DSP. In both cases, a full description of the DSP state as a JSON string is generated in the module data segment (including memory indexes of all controllers). Loader code will get and decode this JSON description, and use whatever parts of the description it needs to run the DSP code. In particular, control memory zones (corresponding to the UI items like buttons, sliders, bargraph...) can be directly read/written by the wrapper code. Benchmark of C++, LLVM IR and wast/wasm generated code Since Faust already generates C++ or LLVM IR code, the performances of those two backends can be compared with the new wasm one. Using the WAVM C++ written machine allows to deploy the same measuring code . The first benchmark compares the speed of C++, LLVM IR and wasm backends running a set of DSP, running on a MacBook Pro 2,2 GHz Core I7 with OSX El capitan. The same 4.0 version of LLVM toolchain has been used with the three backend. C++ and LLVM IR code has been compiled with the -Ofast optimization flag, the WAVM runtime is the standard version one (without any specific audio optimization, see later): The diagrams clearly shows that the wasm code is still slower than C++ or LLVM IR code, but speed difference is not so high in most cases. Some DSP behaviours need to be understood in more details. Optimizing the WAVM runtime for audio code The WAVM runtime strictly conforms to the WebAssembly specification, thus behaving as a interesting base reference. In the audio domain, the deployed code is usually compiled with specific optimization flags. Since C++ WAVM runtime can be hacked quite easily, we did several changes into the reference implementation to gain some speed: removing the atomic flag in all load/store that are added to pass all spec WebAssembly tests. adding the equivalent of -fast-math compilation flag that have to be done at LLVM IR and JIT (= native) generation steps. and finally simplifying some mathematical operators, using their standard definition instead of the specific WAVM coded ones that strictly implement WebAssembly official semantic (see for instance the definition of f32.min/f32.max operations). Here is the diagram of DSP examples run with reference WAVM runtime, and the three specific optimizations: After generating the LLVM IR code, the WAVM runtime runs a set of LLVM IR to IR optimizations passes. It remains to be tested if adding more optimization passes (especially the auto-vectorizations ones) could help producing even better code. WebAssembly module optimization with Binaryen Binaryen is a compiler and toolchain infrastructure library for WebAssembly , written in C++. We tested the wasm-opt tool at -O3 level on Faust generated wasm modules to estimate which speedup we can expect. The following diagram shows limited gains, with no more than 5% in some of the tested cases: Float denormal handling A specific problem occurs when audio computation produces denormal float values, which is quite common with recursive filters, and can be extremely costly to compute on some processors like the Intel family for instance. A Flush To Zero (FTZ) mode for denormals can usually be set at hardware level, but it not yet available in the WebAssembly MVP version, which strictly conform to the IEEE 754 norm 8. Thus an automatic software strategy which consists in adding FTZ code in all recursive loops has been implemented in the Faust compiler. To activate it, the -ftz compilation parameter must be used at compilation time. The -ftz 1 mode adds a test in each recursive loop which uses the fabs function and a threshold to detect subnormal samples (slower). The -ftz 2 mode adds a test in each recursive loop which uses a mask to detect subnormal samples (faster). Even if using software ftz is not strictly needed in our benchmark chain (since the C++ WAVM uses the ftz hardware protection mode), we can still compare the speed of the different ftz options. Here is the result of code generated with -ftz from 0 to 2: Comparing three browsers on OSX El Capitan HTML test pages were prepared to compare the performances of the three main browsers on OSX El Capitan. The DSP code is compiled with float denormal protection on (-ftz 2). The generated wasm module compute method is called repeatedly in a timed loop, using successive slices of a big allocated circular audio buffer to avoid cache effects. Here are the results: The fasted one (Chrome for now) can be compared with C++, LLVM IR, WAVM native engines, all compiled with float denormal protection on (-ftz 2): Comments and Conclusion Testing wasm JIT machines inside browsers is not an easy task. The C++ WAVM runtime revealed to be an excellent tool to compare the Faust C++, LLVM IR and wasm backend. Since its code can be easily adapted, one can estimate also what can be expected deploying wasm DSP modules in pure native environments , outside of the browser, where some audio specific optimizations may be considered. Measures done on a set of Faust DSP show that WebAssembly code still run slower than C++ or LLVM IR generated code in most cases, up to almost 66% slower in the less favorable examples. This value will typically be a bit worse when deploying in browsers, since float denormal protection code has to be used . Benchmarks in browser wasm runtime still need to be done to confirm or refine these findings. Comparing the Chrome , Firefox and WebKit browsers on OSX El Capitan shows that Chrome is currently the fastest engine in most cases, with Firefox and WebKit quite similar (with a slight plus for WebKit). Comparing the Chrome browser with native engines shows results from 4,8 times slower (filterBank.dsp), 2,8 times slower (sTunedBar6.dsp) up to much more favorable cases (karplus32.dsp). Note that filterBank.dsp example is a bit of a pathological case, since Chrome is significantly slower than Firefox and WebKit in this case, and filterBank.dsp uses a lot of pow(10, x) code that is rewritten an optimized as exp10(x) with the C++ backend path. 2017-08-18: Faust on the Web Deploying Faust DSP on the Web EDIT : we are at the Web Audio conference 2017, and it appears that the way we currently extend the ScripProcessorNode with Faust code is not the Right Way... Part of the post concerning the exposed API will probably change a bit in the near future... Using latest developments done for the Web (the new WebAssembly backends and libfaust library compiled in WebAssembly with Emscripten), statically and dynamically Faust generated WebAudio nodes can be easily produced and deployed on the Web. Deploying statically compiled Faust WebAudio nodes From a foo.dsp source file, JavaScript and the associated WebAssembly files can be produced with the following script: faust2wasm foo.dsp This will generate a foo.wasm file with the WebAssembly module as binary code, as well as a foo.js wrapper file containing the code needed to turn the Faust DSP in a fully working WebAudio node (using an extended ScriptProcessor node). The name of the Faust DSP code file is used to define the final ScriptProcessorNode constructor name. So for instance if osc.dsp file is compiled, the following faust.createosc function will be generated: /** * Create a 'monophonic' ScriptProcessorNode Web Audio object * by loading and compiling the Faust wasm file * * @param context - the Web Audio context * @param buffer_size - the buffer_size in frames * @param callback - a callback taking the created ScriptProcessorNode as parameter, * or null in case of error */ faust.createosc = function(context, buffer_size, callback) The resulting object is an extended ScriptProcessorNode, to be used as a regular node (like connected to other WebAudio nodes), but which also adds the Faust specific API as defined in the equivalent C++ generated dsp class (see the architecture/faust/dsp/dsp.h header for more technical details), as well as JavaScript more specific functions. For instance the following ones will have to be used to control the node: var paths = node.getParams(); // get the set of paths to read/write input control parameters Then knowing the path for a given parameter, the following function is used to change the parameter value: node.setParamValue(\"/Oscillator/freq\", 0.6); A full JSON description of the node with the complete UI, can be retrieved with: var json = node.getJSON(); The complete usable API is fully documented in the generated JavaScript file in the Public API to be used to control the WebAudio node section. A simple example Web page A simple Web page using the files generated by faust2wasm on the noise.dsp file can be defined with the following parts: <!-- Load 'faust2wasm' script generated .js file --> <script src=\"noise.js\"></script> A slider to control the noise volume parameter is defined with: <P> Noise volume: <input type=\"range\" oninput=\"changeVolume(event) \"min=\"0\" max=\"1\" value=\"0.5\" step=\"0.01\"/> The WebAudio context is created and the noise slide hander is defined with: var isWebKitAudio = (typeof (webkitAudioContext) !== \"undefined\"); var audio_context = (isWebKitAudio) ? new webkitAudioContext() : new AudioContext(); var noise = null; // Slider handler to change the 'noise' volume function changeVolume(event) { noise.setParamValue(\"/Noise/Volume\", parseFloat(event.target.value)); } A startnoise function which creates the Faust WebAudio node is defined with: function startnoise() { // Create the Faust generated node faust.createnoise(audio_context, 1024, function (node) { noise = node; console.log(noise.getJSON()); // Print paths to be used with 'setParamValue' console.log(noise.getParams()); // Connect it to output as a regular WebAudio node noise.connect(audio_context.destination); }); } An finally the load handler is defined to activate the code: window.addEventListener(\"load\", startnoise); Look at the Noise and OSC online pages for the complete code. Note that pages loading an additional .wasm file cannot directly be loaded in Chrome. You'll have to start a local server (using the python -m SimpleHTTPServer command for instance) and access them with their http:// based URL. Generating Polyphonic WebAudio nodes Assuming that the compiled Faust DSP file is polyphonic ready , a polyphonic ready WebAudio node can be created with the -poly parameter, and will generate the following constructor for the node (where the mydsp part will be replaced by the actual DSP name): /** * Create a 'polyphonic' ScriptProcessorNode Web Audio object * by loading and compiling the Faust wasm file * to be use for the voice, and allocating the number of needed voices * * @param context - the Web Audio context * @param buffer_size - the buffer_size in frames * @param polyphony - the number of polyphonic voices * @param callback - a callback taking the created ScriptProcessorNode * as parameter, or null in case of error */ faust.createmydsp_poly = function(context, buffer_size, polyphony, callback) Polyphonic nodes have an extended API to be controled with MIDI messages: /** * Instantiates a new polyphonic voice. * * @param channel - the MIDI channel (0..15, not used for now) * @param pitch - the MIDI pitch (0..127) * @param velocity - the MIDI velocity (0..127) */ keyOn = function (channel, pitch, velocity) /** * De-instantiates a polyphonic voice. * * @param channel - the MIDI channel (0..15, not used for now) * @param pitch - the MIDI pitch (0..127) * @param velocity - the MIDI velocity (0..127) */ keyOff = function (channel, pitch, velocity) /** * Gently terminates all the active voices. */ allNotesOff = function () Look at the JavaScript public documentation section for the complete description. Extended control with -comb parameter The faust2wasm tool can be used with the -comb parameter to compile several DSP files and contatenate all JavaScript code in a unique resulting comb.js file (possibly to be used in -poly mode also). Generating fully working self-contained HTML pages The faust2webaudiowasm script can be used to generate a fully working self-contained HTML page, with a SVG/CSS a Graphical User Interface. From the osc.dsp Faust DSP source file, it will generate an osc.html file: faust2webaudiowasm osc.dsp Assuming that the compiled Faust DSP file is polyphonic ready, the -poly parameter can be used to generate a polyphonic MIDI controlable instrument, to be used with a MIDI application or device. The -links generates the DSP processor SVG representation, and links to the original DSP file as well as generated SVG files, so that the HTML page can possibly be deployed as a reusable Faust DSP resource. WebAssembly module optimization Assuming that you have Binaryen tools installed on your machine, the faust2wasm and faust2webaudiowasm scripts can take an additional -opt parameter to allow WebAssembly module optimization. Deploying dynamically compiled Faust WebAudio nodes Since the libfaust library is available for the Web, it becomes possible to embed the complete dynamic compilation chain in a Web page , from the Faust DSP source to the executable WebAudio node. First the following resources (located on the Faust GitHub in architecture/webaudio folder) have to be loaded in the page: <!-- Load 'libfaust' library and wrapper code --> <script src=\"libfaust-wasm.js\"></script> <script src=\"webaudio-wasm-wrapper.js\"></script> Then the two following functions are used to generate factories, creating later on monophonic or polyphonic instances (this is necessary because of the way internal WebAssembly memory is managed): /** * Create a DSP factory from source code as a string to be used to create monophonic DSP * * @param code - the source code as a string * @param argv - an array of parameters to be given to the Faust compiler * @param callback - a callback taking the created DSP factory as parameter, * or null in case of error */ faust.createDSPFactory = function (code, argv, callback) /** * Create a DSP factory from source code as a string to be used to create polyphonic DSP * * @param code - the source code as a string * @param argv - an array of parameters to be given to the Faust compiler * @param callback - a callback taking the created DSP factory as parameter, * or null in case of error */ faust.createPolyDSPFactory = function (code, argv, callback) The two following functions are used to generate monophonic or polyphonic Faust WebAudio nodes: /** * Create a ScriptProcessorNode Web Audio object from a factory * * @param factory - the DSP factory * @param context - the Web Audio context * @param buffer_size - the buffer_size in frames * @param callback - a callback taking the created ScriptProcessorNode as parameter, * or null in case of error */ faust.createDSPInstance = function (factory, context, buffer_size, callback) /** * Create a 'polyphonic' 'ScriptProcessorNode Web Audio object from a factory * * @param factory - the DSP factory * @param context - the Web Audio context * @param buffer_size - the buffer_size in frames * @param polyphony - the number of polyphonic voices * @param callback - a callback taking the created ScriptProcessorNode as parameter, * or null in case of error */ faust.createPolyDSPInstance = function (factory, context, buffer_size, polyphony, callback) The resulting nodes have the same API as statically compiled nodes described in the first section, so can be controlled the same way, including the polyphonic ones. Here is a code example using faust.createDSPFactory and faust.createDSPInstance : var isWebKitAudio = (typeof (webkitAudioContext) !== \"undefined\"); var audio_context = (isWebKitAudio) ? new webkitAudioContext() : new AudioContext(); var dsp_code = \"import(\\\"stdfaust.lib\\\"); vol = hslider(\\\"volume [unit:dB]\\\", 0, -96, 0, 0.1) : ba.db2linear : si.smoo; freq = hslider(\\\"freq [unit:Hz]\\\", 1000, 20, 24000, 1); process = vgroup(\\\"Oscillator\\\", os.osc(freq) * vol);\"; var osc = null; var libraries_url = \"/modules/libraries/\"; function startosc() { // Prepare argv list var argv = []; argv.push(\"-ftz\"); argv.push(\"2\"); argv.push(\"-I\"); argv.push(libraries_url); // Dynamically create the Faust generated node from explicit DSP source in 'dsp_code' faust.createDSPFactory(dsp_code, argv, function (factory) { faust.createDSPInstance(factory, audio_context, 1024 function (node) { osc = node; console.log(osc.getJSON()); // Print paths to be used with 'setParamValue' console.log(osc.getParams()); // Connect it to output as a regular WebAudio node osc.connect(audio_context.destination); })}); } The Dynamic OSC page demonstrates the dynamic OSC complete code (based on the example seen before). The Dynamic Organ page demonstrates a polyphonic organ instrument, which loads a DSP from an url, and ready to be controlled with a MIDI device or application. Look at the Dynamic Faust compiler page for a more complete use-case of the dynamic compiler. Float denormal handling A specific problem occurs when audio computation produces denormal float values, which is quite common with recursive filters, and can be extremely costly to compute on some processors like the Intel family for instance. A Flush To Zero (FTZ) mode for denormals can usually be set at hardware level, but it not yet available in the WebAssembly MVP version, which strictly conform to the IEEE 754 norm 8. Thus an automatic software strategy which consists in adding FTZ code in all recursive loops has been implemented in the Faust compiler. To activate it, the -ftz compilation parameter must be used at compilation time. The -ftz 1 mode adds a test in each recursive loop which uses the fabs function and a threshold to detect subnormal samples (slower). The -ftz 2 mode adds a test in each recursive loop which uses a mask to detect subnormal samples (faster). Use for example the following line to active software denormal handing when using faust2wasm tool: faust2wasm -ftz 2 foo.dsp The same for the faust2webaudiowasm tool: faust2webaudiowasm -ftz 2 foo.dsp For dynamic compilation, the -ftz v flag will have to be added in the argv parameter in faust.createDSPFactory or faust.createPolyDSPFactory , like for instance: faust.createPolyFactory(dsp_code, ['-ftz', '2'], callback); 2017-06-16: Memory allocator Using a custom memory allocator From a DSP source file, the Faust compiler typically generates a C++ class. When a rdtable item is used on the source code, the C++ class will contain a table shared by all instances of the class. By default, this table is generated as a static class array, and so allocated in the application global static memory. In some specific case (usually in more constrained deployment cases), managing where this data is allocated is crucial. By extension this post explains how a custom memory allocator can be used to precisely control the DSP memory allocation. Faust -mem option to control memory related code generation A new -mem compiler parameter has been added in the Faust compiler, starting from the 0.9.103 version (or 2.1.4 in Faust2 branch). This parameter will change the way static shared tables are generated. The table is allocated as a class static pointer allocated using a custom memory allocator , which has the following propotype: struct dsp_memory_manager { virtual ~dsp_memory_manager() {} virtual void* allocate(size_t size) = 0; virtual void destroy(void* ptr) = 0; }; Taking the following Faust DSP example: process = (waveform {10,20,30,40,50,60,70}, %(7)~+(3) : rdtable), (waveform {1.1,2.2,3.3,4.4,5.5,6.6,7.7}, %(7)~+(3) : rdtable); Here is the generated code in default mode: ... int mydsp::itbl0[7]; float mydsp::ftbl0[7]; static void classInit(int samplingFreq) { SIG0 sig0; sig0.init(samplingFreq); sig0.fill(7,itbl0); SIG1 sig1; sig1.init(samplingFreq); sig1.fill(7,ftbl0); } virtual void init(int samplingFreq) { classInit(samplingFreq); instanceInit(samplingFreq); } virtual void instanceInit(int samplingFreq) { instanceConstants(samplingFreq); instanceResetUserInterface(); instanceClear(); } ... The two itbl0 and ftbl0 tables are static class arrays. They are filled in the classInit method. The architecture code will typically call the init method (which calls classInit ) on a given DSP, to allocate class related arrays and the DSP itself. If several DSP are going to be allocated, calling classInit only once then the instanceInit method on each allocated DSP is the way to go. In the new -mem mode, the generated C++ code is now: ... int* mydsp::itbl0 = 0; float* mydsp::ftbl0 = 0; dsp_memory_manager* mydsp::fManager = 0; static void classInit(int samplingFreq) { SIG0 sig0; itbl0 = static_cast<int*>(fManager->allocate(sizeof(int) * 7)); sig0.init(samplingFreq); sig0.fill(7,itbl0); SIG1 sig1; ftbl0 = static_cast<float*>(fManager->allocate(sizeof(float) * 7)); sig1.init(samplingFreq); sig1.fill(7,ftbl0); } static void classDestroy() { fManager->destroy(itbl0); fManager->destroy(ftbl0); } virtual void init(int samplingFreq) {} virtual void instanceInit(int samplingFreq) { instanceConstants(samplingFreq); instanceResetUserInterface(); instanceClear(); } ... The two itbl0 and ftbl0 tables are generated a class static pointers. The classInit method takes the additional dsp_memory_manager object used to allocate tables. A new classDestroy method is available to deallocate the tables. Finally the init method is now empty, since the architecure file is supposed to use the classInit/classDestroy method once to allocate and deallocate static tables, and the instanceInit method on each allocated DSP. Control of the DSP memory allocation An architecture file can now define its custom memory manager by subclassing the dsp_memory_manager abstract base class, and implement the two required allocate and destroy methods. Here is an example of a simple heap allocating manager: struct malloc_memory_manager : public dsp_memory_manager { virtual void* allocate(size_t size) { void* res = malloc(size); cout << \"malloc_manager: \" << size << endl; return res; } virtual void destroy(void* ptr) { cout << \"free_manager\" << endl; free(ptr); } }; Controlling the table memory allocation To control table memory allocation, the architecture file will have to do: // Allocate a custom memory allocator malloc_memory_manager manager; // Setup manager for the class mydsp::fManager = &manager; // Allocate the dsp instance using regular C++ new mydsp* dsp = new mydsp(); // Allocate static tables (using the custom memory allocator) mydsp::classInit(48000); // Initialise the given instance dsp->instanceInit(48000); ... ... // Deallocate the dsp instance using regular C++ delete delete dsp; // Deallocate static tables (using the custom memory allocator) mydsp::classDestroy(); Controlling the complete DSP memory allocation Full control the DSP memory allocation can be done using C++ placement new : #include <new> // Allocate a custom memory allocator malloc_memory_manager manager; // Setup manager for the class mydsp::fManager = &manager; // Placement new using the custom allocator mydsp* dsp = new(manager.allocate(sizeof(mydsp))) mydsp(); // Allocate static tables (using the custom memory allocator) mydsp::classInit(48000); // Initialise the given instance dsp->instanceInit(48000); ... ... // Calling the destructor dsp->~mydsp(); // Deallocate the pointer itself using the custom memory allocator manager.destroy(dsp); // Deallocate static tables (using the custom memory allocator) mydsp::classDestroy(); More complex custom memory allocators can be developed by refining this malloc_memory_manager example, possibly defining real-time memory allocators...etc... The OWL architecture file already uses this new custom memory allocator model. This is a work in progress: in the Faust2 branch, this model is still not supported yet beside the C++ backend custom memory allocator is not yet supported is additional DSP classes (like the mydsp_poly defined in the achitecture/faust/dsp/poly-dsp.h header). 2017-04-26: Optimizing... Optimizing the DSP CPU usage The Faust compiler has as lot of different compilation parameters to play with. Discovering them for a given DSP program is something that can be automated. Two measure_dsp and dsp_optimizer classes are available for developers to measure DSP CPU use directly in their code. Two more friendly faustbench and faustbench-llvm tools have been developed using them. They allow to discover the best Faust compiler parameters, to be used later on with faust2xx scripts, faustgen~ Max/MSP external or FaustLive . The measure_dsp and dsp_optimizer DSP decorator classes The measure_dsp class defined in the faust/dsp/dsp-bench.h file allows to decorate a given DSP object and measure its compute method CPU consumption. Results are given in Megabytes/seconds (higher is better). Here is a C++ code example of its use: static void bench(dsp* dsp, const string& name) { // Init the DSP dsp->init(48000); // Wraps it with a 'measure_dsp' decorator measure_dsp mes(dsp, 1024, 5); // Measure the CPU use mes.measure(); // Print the stats cout << name << \" CPU use : \" << mes.getStats() << endl; } Only part of the Faust2 branch and defined in the faust/dsp/dsp-optimizer.h file, the dsp_optimizer class uses the libfaust library and its LLVM backend to dynamically compile DSP objects produced with different Faust compiler options, and then measure their DSP CPU. Here is a C++ code example of its use: static void dynamic_bench(const string& dsp_source) { // Init the DSP optimizer with the dsp_source to compile // (either the filename or source code string) dsp_optimizer optimizer(dsp_source, \"/usr/local/share/faust\", \"\", 1024); double value; // Discover the best set of parameters vector<string> options = optimizer.findOptimizedParameters(value); // Print the result cout << \"Best value is for '\" << argv[1] << \"' is : \" << value << \" with \"; for (int i = 0; i < options.size(); i++) { cout << options[i] << \" \"; } cout << endl; } Using the faustbench tool The faustbench tool uses the C++ backend to generate a set of C++ files produced with different Faust compiler options. All files are then compiled in a unique binary that will measure DSP CPU of all versions of the compiled DSP. The tool is supposed to be launched in a terminal, but it can be used to generate an iOS project, ready to be launched and tested in Xcode. Here are the available options: faustbench [-ios] [Additional Faust options (-vec -vs 8...)] <file.dsp> Use '-ios' to generate an iOS project Use 'export CXX=/path/to/compiler' before running faustbench to change the C++ compiler Use 'export CXXFLAGS=options' before running faustbench to change the C++ compiler options Here is a trace of its use: faustbench karplus32.dsp Selected compiler is g++ with CXXFLAGS = -Ofast -scal : 77.5123 -vec -lv 0 -vs 4 : 64.2194 -vec -lv 0 -vs 8 : 80.8951 -vec -lv 0 -vs 16 : 106.244 ..... -vec -lv 1 -vs 128 -g : 130.635 -vec -lv 1 -vs 256 -g : 134.335 -vec -lv 1 -vs 512 -g : 135.352 Best value is : 136.235 with -vec -lv 0 -vs 512 Using the faustbench-llvm tool Available in the faust2 branch only, the faustbench-llvm tool uses the libfaust library and its LLVM backend to dynamically compile DSP objects produced with different Faust compiler options, and then measure their DSP CPU. In the main Faust folder, use make bench && sudo make install to build and install the tool. Here is a trace of its use: faustbench-llvm karplus32.dsp Estimate timing parameters -scal : 21.1269 duration = 0.102801 count = 24318 Discover best parameters option -scal : 21.1034 -vec -lv 0 -vs 4 : 42.0734 -vec -lv 0 -vs 8 : 55.3725 -vec -lv 0 -vs 16 : 85.3855 ..... -vec -lv 1 -vs 128 -dfs : 133.974 -vec -lv 1 -vs 256 -dfs : 139.12 -vec -lv 1 -vs 512 -dfs : 91.8424 Refined with -mcd -vec -lv 0 -vs 256 -g -mcd 2 : 83.5555 -vec -lv 0 -vs 256 -g -mcd 4 : 138.519 -vec -lv 0 -vs 256 -g -mcd 8 : 140.122 -vec -lv 0 -vs 256 -g -mcd 16 : 141.558 -vec -lv 0 -vs 256 -g -mcd 32 : 139.454 -vec -lv 0 -vs 256 -g -mcd 64 : 143.405 -vec -lv 0 -vs 256 -g -mcd 128 : 142.975 -vec -lv 0 -vs 256 -g -mcd 256 : 139.345 Best value is for 'karplus32.dsp' is : 142.473 with -vec -lv 0 -vs 256 -dfs -mcd 64 w 2017-02-21: Faust meets JUCE JUCE is an open-source cross-platform C++ application framework, used for the development of desktop and mobile applications. JUCE is used in particular for its GUI and plugins libraries. A set of architecture files have been developed to deploy standalone or plugins built from Faust code. They allow to automatically generate the GUI from the Faust program, possibly supporting polyphonic instruments, and be controlled by MIDI or OSC messages. The architecture files are then combined to produce ready to compile JUCE applications or plugins, using tools that are part of the Faust distribution. They can also be accessed using the Faust online compiler. faust2juce script faust2juce transforms a Faust DSP program into a fully working JUCE standalone application or plugin, which can possibly be controlled with MIDI or OSC messages. Read its complete description here . You'll have to get a recent github version of Faust tree to use it. Using the online compiler The Faust online compiler has been updated to provide new 'juce' targets. Note that only some of the possible compilation options are availble for now: the application target produces a standalone MIDI controlable application (using Faust polyphonic code if the Faust source code is polyphonic aware) the plug-in target produces a MIDI controlable mono or polyphonic plugin (using Faust polyphonic code if the Faust source code is polyphonic aware) the jsynth target produces a MIDI controlable mono or polyphonic plugin (using JUCE polyphonic Synthesizer if the Faust source code is polyphonic aware) Directly using faust2juce provides the full control of the generated target with access to all possible compilation parameters. Graph of Faust generated plugins Here is an example of three Faust generated plugins running in JUCE plugin host: Using libfaust and LLVM An alternative to faust2juce static-compilation model, is to use Oliver Larkin's juce_faustllvm module, also used in his pMix2 tool . 2017-01-13: WebAssembly... Faust WebAssembly backend WebAssembly was born with the premise of creating a safe, portable and fast to load and execute format suitable for the web. WebAssembly its not a programing language but a compilation target with a text and binary specs. That means that other low level languages like C/C++, Rust, Swift, etc. can compile to WebAssembly. Specified and developed by principal browser compagnies (Google, Mozilla, Microsoft and Apple), this new format aims to finally replace the more hackish \"asm.js\" format initialy developed by Mozilla. Development versions of Chrome and Firefox can already execute it. To get an early preview of this experimental technology, at your own risk: on Chrome Canary , open chrome://flags/#enable-webassembly and enable the switch on Firefox Nightly , open about:config and set javascript.options.wasm to true See a preview of Microsoft Edge support and follow Safari support on WebKit\u2019s feature status . WebAssembly backends New WebAssembly backends have been added in the faust2 development branch. They allow to generate textual or binary WebAssembly code. 'wast' textual backend The 'wast' backend allows to generate textual WebAssembly code (in s-expression like format). Note that as of january 2017, the official textual format is not yet fully specified, thus we follow the format used in the binaryen tool . Use the following command to generate the textual output in the terminal for a given foo.dsp file. faust -lang wast foo.dsp The following command: faust -lang wast foo.dsp -o foo.wast will generate the foo.wast textual WebAssembly output file as well as an additional foo.js JavaScript file containing glue code. 'wasm' binary backend The 'wasm' backend allows to generate binary WebAssembly code. Use the following command to generate the binary output in the terminal for a given foo.dsp file. faust -lang wasm foo.dsp The following command: faust -lang wasm foo.dsp -o foo.wasm will generate the foo.wast binary WebAssembly output file as well as an additional foo.js JavaScript file containing glue code. Generating static HTML pages WebAssembly code can be feeded into WebAudio JavaScript nodes, which can then be used like any other native WebAudio node. Two scripts are available to generate static WebAudio html pages from a given foo.dsp source file with the generated html/css/svg user interface: faust2webaudiowast foo.dsp will generate the textual WebAssembly output, use binaryen wasm-as tool to convert the wast to wasm format (you'll have to compile and install the binaryen tools on your machine), and produce a self-contained html page. faust2webaudiowasm foo.dsp will generate the binary WebAssembly output that can directly be loaded by the produced self-contained html page. Page containing polyphonic instruments can be generated with the following commands: faust2webaudiowast -poly foo.dsp to use the 'wast' backend and a polyphonic ready foo.dsp, and create a self-contained html page ready to be used with a MIDI instrument. faust2webaudiowasm -poly foo.dsp to use the 'wasm' backend and a polyphonic ready foo.dsp, and create a self-contained html page ready to be used with a MIDI instrument. 2016-10-17: Faust Award 2016 The Faust Open Source Software Competition aims at promoting innovative high-quality free audio software developed with Faust, a functional programming language for realtime signal processing and sound synthesis. The competition is sponsored by GRAME , Centre National de Cr\u00e9ation Musicale Faust Award 2016 to Ambitools The Faust Award 2016 was attributed by an international committee composed of : Jean-Louis Giavitto (IRCAM, Paris, France), Albert Graef (Johannes Gutenberg U., Mainz, Germany), Pierre Jouvelot (Ecole des Mines, Paris, France), Victor Lazzarini (Maynooth U., Maynooth, Ireland), Romain Michon (Stanford U., Palo Alto, USA) Yann Orlarey (GRAME, Lyon, France), Dave Phillips (musician, journalist, and educator, USA) Laurent Pottier (U. Jean Monnet, Saint-Etienne, France), Julius Smith (Stanford U., Palo Alto, USA) to Ambitools , a set of tools for real-time 3D sound field synthesis using higher order ambisonics (HOA). Ambitools is developed by Pierre Lecomte, a PhD candidate at Conservatoire National des Arts et M\u00e9tiers and Sherbrooke University. The core of the sound processing is written in Faust. The tools contain HOA encoders, decoders, binaural-filters, HOA signals transformations, spherical VU-Meter, etc. and can be compiled in various plug-ins format under Windows, Mac OSX, and Linux. The jury praised the quality and the usefulness of Ambitools: a really useful and technically advanced Faust app and an impressive technical achievement ! Check the demo . The committee was also very impressed by the quality of two other projects : Voice of Faust , a voice synthesizer/effects machine by Bart Brouns ( demo ). PMix , a graphical patcher, preset interpolator and JIT compiler for FAUST by Oliver Larkin ( demo ). Faust Student Software Competition to TouchVoices In parallel to the main competition, we introduced this year a junior competition: the Faust Student Software Competition , intended to promote small but interesting Faust applications, typically written as student projects. The student prize was awarded to TouchVoices (by Pierre-Adrien Th\u00e9o, RIM Master student at University Jean Monnet) a real-time web application allowing to capture, playback and transform sound loops. Here is a video of Pierre-Adrien Th\u00e9o during a performance with TouchVoices . A very close competitor was SuperBeatRepeater (by Vincent Rateau, of SuperDirt fame), a sample accurate beat repeater. Don't miss the demo ! 2016-08-30: FAUST book... The first FAUST book is Korean ! \u201c Sound Programming using FAUST \u201d, written by Jin-Wook Chae , an experienced audio developer and sound engineer (right) and Hyun-Hoo Jung (left), is the very first book ever published on FAUST. While the book is written in Korean, I was able to really appreciate the choice of the examples and the elegance as well as the high quality of the code. I am sure it will be an invaluable tool to promote FAUST in Korea among sound engineering, computer music students and more generally any person interested in sound programming. This book is for people desiring to produce musical instruments or sound processors. I have always been instructing my students that the ultimate importance is to discover interesting ideas about the sound. In spite of that, I have often relied on an unflattering response such as \"you may need to learn a programming language like C/C++...\" when a student asked for help with how to execute his/her ideas related to sound. Now I am pleased to recommend the use of FAUST to bring such ideas into execution. This is an easy self-study guide that can help to do just that. Now I can confidently tell anybody pursuing sound or electronic music that their exciting and brilliant idea about sound is what truly counts! So, really, how do we execute our ideas? Today I am introducing you to FAUST and to this book which you will find immensely helpful in terms of how to use FAUST to bring your fabulous ideas into reality. Jinwook Chae 2016-06-30: Faust interpreter A new 'interpreter' backend has been added in the faust2 development branch. It allows to execute Faust programs without using the LLVM dynamic compiler chain. Interpreter compilation chain The dynamic compilation chain allows developers to embed the Faust compiler technology directly in their application or plugins. Faust2 development branch uses an intermediate FIR representation (Faust Imperative Representation), which can be translated to several output languages. An LLVM backend has been previously developed to allows applications to compile a DSP source into executable code in memory, bypassing the external compiler requirement. In some specific situations, embedding the LLVM chain is not possible : for instance Apple does not allow to deploy dynamic compilers on iOS. Thus having an interpreter backend allows to get around this problem and still make Faust code run on those platforms. Interpreter backend The interpreter backend translates the FIR intermediate language into instructions for a virtual machine. A pure C++ interpreter for this instruction set has been implemented. Running and performances The interpreter backend translates the FIR intermediate language into bytecode for a virtual machine. It allows to run programs about 4 to 5 slower than native speed . Moreover this interpreter can be compiled in a special 'trace' mode to automatically detect various execution errors : invalid heap access, mathematical errors or warnings (division by zero, integer overloading....) which helps us to check the compiler semantic and code generation quality. Deployment for developers Given a Faust source code (as a file or a string), calling the createInterpreterDSPFactoryXXX function runs the compilation chain (Faust + interpreter) and generates the \u201cprototype\u201d of the class, as a interpreter-dsp-factory pointer. class interpreter_dsp_factory : public dsp_factory { public: /* Return Factory name */ std::string getName(); /* Return Factory SHA key */ std::string getSHAKey(); /* Return Factory expanded DSP code */ std::string getDSPCode(); /* Creates a new dsp instance */ dsp* createDSPInstance(); }; Note that the library keeps an internal cache of all allocated factories so that the compilation of the same DSP code, that is same source code and same set of 'normalized' (= sorted in a canonical order) compilations options, will return the same (reference counted) factory pointer. You will have to explicitly use deleteInterpreterDSPFactory to properly decrement the reference counter when the factory is no more needed. You can get a unique SHA1 key of the created factory using its getSHAKey method. Next, the createDSPInstance function, corresponding to the new className of C++, instantiates a interpreter-dsp pointer to be used through its interface, connected to the audio chain and controller interfaces. When finished, simply use delete to destroy the dsp instance. class interpreter_dsp : public dsp { public: void metadata(Meta* m); int getNumInputs(); int getNumOutputs(); void init(int samplingRate); void instanceInit(int samplingRate); dsp* clone(); void buildUserInterface(UI* inter); int getSampleRate(); void compute(int count, FAUSTFLOAT** input, FAUSTFLOAT** output); }; Since interpreter_dsp is a subclass of the dsp base class, an object of this type can be used with all already available audio and UI classes, in essence reusing all architecture files already developed for the static C++ class compilation scheme (like OSCUI, httpdUI interfaces etc.), see Developing a new architecture file . Saving/restoring the factory After the DSP factory has been compiled, your application or plugin may want to save/restore it in order to save Faust to interpreter bytecode compilation at next use. To get the internal factory compiled code, several functions are available: writeInterpreterDSPFactoryToMachine allows to get the interpreter bytecode as a string, writeInterpreterDSPFactoryToMachineFile allows to save the interpreter bytecode in a file, To re-create a DSP factory from a previously saved code, several functions are available: readInterpreterDSPFactoryFromMachine allows to create a DSP factory from a string containing the interpreter bytecode, readInterpreterDSPFactoryFromMachineFile allows to create a DSP factory from a file containing the interpreter bytecode. The complete API is available and documented in the installed faust/dsp/interpreter-dsp.h header. 2016-04-07: Web Audio API Faust and the Web Audio API (3) The Faust compiler can now directly be used in a Web page. Thanks to the Emscripten compiler, the Faust compiler itself can be compiled to asm.js JavaScript. This has been done by compiling the libfaust C++ library to the libfaust.js JavaScript library, that exports a unique entry point. Compiling DSP to JavaScript (asm.js) The libfaust.js exported function createAsmCDSPFactoryFromString(...) allows to create a DSP factory from a given DSP program as a source string and a set of compilations parameters, uses the Faust compiler asm.js backend, and produces the complete asm.js module and additional pure JavaScript methods as a string. Then calling JavaScript 'eval' function on this string compiles it in the browser. The dynamically created asm.js module and additional pure JavaScript methods can then be used. This internal code in then wrapped with additional JavaScript code. A DSP \u201cfactory\u201d will be created from the DSP source code with the following 'synchronous' code (if using the 'libfaust.js' library): var factory = faust.createDSPFactory(code, arguments); or possibly (if using the 'libfaustworker.js' library in the 'asynchronous' model): faust.createDSPFactory(code, arguments, callback); where 'code' is the DSP source as a string, and 'arguments' is an array of parameters to be given to the Faust compiler (like '-vec', '-vs 512'...), and 'callback' is a function taking the created 'factory' as argument. When no more used, you'll have to explicitly use the following code the deallocate the factory: faust.deleteDSPFactory(factory); Your application may want to save the already compiled factory as asm.js/JavaScript code to speed-up possible restore at later time: var machine_code = faust.writeDSPFactoryToMachine(factory); And restore the factory with the following code: var factory = faust.readDSPFactoryFromMachine(machine_code); Using DSP instances A fully working DSP \u201cinstance\u201d as a Web Audio node is then created with the code: var dsp = faust.createDSPInstance(factory, audio_context, buffer_size); When no more used, you'll have to explicitly use the following code to deallocate the instance: faust.deleteDSPInstance(dsp); This instance can be used like the statically compiled one, as previously described in this page . Polyphonic instruments Polyphonic instruments can be produced. For a given 'factory' the following code will create a 16 voices polyphonic instance: var dsp = faust.createPolyDSPInstance(factory, audio_context, buffer_size, 16); This instance can be used like the statically compiled one, as previously described in this page . Using Faust JavaScript library The Emscripten compiled Faust library can be used in two ways. Either using the 'libfaust.js' library: <script src=\"libfaust.js\"></script> <script src=\"webaudio-asm-wrapper.js\"></script> or if using worker mode with the following code which loads the 'libfaustworker.js' library: <script src=\"webaudio/webaudio-asm-worker-wrapper.js\"></script> 2016-02-05: Faust Award 2016 Faust Award 2016: deadline June 1, 2016 The Faust Open-Source Software Competition is intended to promote innovative high-quality free audio software developed with the Faust programming language, as well as development tools build around the Faust compiler itself. The Faust Open-Source Software award will be attributed to the best submission by an international committee of leading experts in the field. The competition is sponsored by Grame, centre national de cr\u00e9ation musicale. The winning software will receive a 2000\u20ac price to encourage its authors. The results will be announced July 15, 2016. To participate, the software must be provided with source code and licensed with a Free/Open Source license. A substantial part of the software must be written in Faust and the Faust source code must be provided. As part of the review process, the software will be built from the sources. All source code, license, video demonstration, installation instructions, and any other documentation must be available on a public web page. License compatibility with other open source software is encouraged. Dependencies on non-open source third-party software are discouraged, with the exception of operating systems and freely available commercial packages. Authors are required to prepare a video demonstrating the software. This video must be done carefully, and should convincingly present the qualities of the software. The submission must also contain any useful documentation, including examples of how the provided software might be used, existing prototypes that use the software, download statistics or other public usage information. The criteria for judging submissions includes broad applicability and potential impact, novelty, technical depth, reusability, etc. Junior Competition In parallel to the Faust Open-Source Software Competition we introduce this year a junior competition, the Faust Student Software Competition, with a 200\u20ac prize for the winner. The Faust Student Software Competition is intended to promote interesting audio processing and synthesis applications written in Faust in a single file in less than 1000 words. The word count is done after removing the comments from the code: cat foo.dsp | stripcmt | wc -w. The use of the standard Faust libraries is strongly encouraged. They don't take part in the word count. Important dates Start of the competition: February 8, 2016 Software Submission Deadline: June 1, 2016 Results of the competition: July 1, 2016 Submission Guidelines Authors interested in participating in the Faust Open Source Software Competition or the Faust Student Software Competition should send a submission email to faustaward@grame.fr with a PDF file attached containing the following information: Title of submission, Category of submission ( Faust Open Source Software Competition or Faust Student Software Competition ), Name, email and affiliation of the main author, Names, emails and affiliations of other authors, A permanent link for the open source software (e.g., Sourceforge, GitHub, Google Code, etc.), A permanent link for the video demonstration (e.g., YouTube, Vimeo, etc.), A link to a compressed archive file that contains the software (source code, documentation, build/install instructions, and licenses). Comprehensive and clear build/install instructions will be a crucial component of any submission. The committee will make a reasonable effort to build the software for the top contributions, but if they are unable to make the software run, it will be excluded from the competition. International Committee Jean-Louis Giavitto (IRCAM, Paris, France), Albert Gr\u00e4f (Johannes Gutenberg U., Mainz, Germany), Pierre Jouvelot (Ecole des Mines, Paris, France), Victor Lazzarini (Maynooth U., Maynooth, Ireland), Romain Michon (CCRMA, Stanford , USA) Yann Orlarey (Grame, Lyon, France), Dave Phillips (Musician/Journalist, Findlay, USA) Laurent Pottier (U. Jean Monnet, Saint Etienne, France), Julius Smith (CCRMA, Stanford , USA) Previous Winners 2015: Guitarix , by Hermann Meyer and Andreas Degert","title":"News up to 2018"},{"location":"community/news/#faust-news","text":"","title":"Faust News"},{"location":"community/news/#2018-07-23-fausts-evolution","text":"View the evolution of the Faust project from 2004 to 2018. The visualization was done using Gource . Here is the command used (as suggested by fullybacked ): gource --hide dirnames,filenames --seconds-per-day 0.1 --auto-skip-seconds 1 -1920x1024 -o - | ffmpeg -y -r 60 -f image2pipe -vcodec ppm -i - -vcodec libx264 -preset ultrafast -pix_fmt yuv420p -crf 1 -threads 0 -bf 0 faust-hd.mp4","title":"2018-07-23: Faust's Evolution"},{"location":"community/news/#2018-07-23-faust-award-2018","text":"The Faust Open Source Software Competition aims at promoting innovative high-quality free audio software developed with Faust, a functional programming language for realtime signal processing and sound synthesis. The competition is sponsored by GRAME , Centre National de Cr\u00e9ation Musicale.","title":"2018-07-23: Faust Award 2018"},{"location":"community/news/#faust-award-2018-to-iplug-2","text":"The Faust Award 2018 was attributed by an international committee composed of : Jean-Louis Giavitto (IRCAM, Paris, France), Albert Graef (Johannes Gutenberg U., Mainz, Germany), Pierre Jouvelot (Ecole des Mines, Paris, France), Victor Lazzarini (Maynooth U., Maynooth, Ireland), Romain Michon (Stanford U., Palo Alto, USA) Yann Orlarey (GRAME, Lyon, France), Laurent Pottier (U. Jean Monnet, Saint-Etienne, France), Julius Smith (Stanford U., Palo Alto, USA) to iPlug 2 a free open source C++ audio plug-in framework, allowing developers to create audio plug-ins and apps across a wide range of formats from the same code, including graphical user interface and DSP components. Amongst many other new features and a reworked code base, version 2 includes support for FAUST, allowing sections of audio DSP to be implemented using the FAUST language, and easily integrated with other C++ elements. iPlug 2 is developed by Oliver Larkin and Alex Harker from the original iPlug, by Cockos inc. that was open sourced in 2008. The project is under active development and will be publicly released at the end of 2018. The jury praised the quality, the ambition, and the usefulness of iPlug 2 as a Faust development framework! Check the demo here . We hope that the Faust Award will help the authors to fully finalize the project.","title":"Faust Award 2018 to iPlug 2"},{"location":"community/news/#faust-student-software-competition-to-cloud-generator","text":"In parallel to the main competition, the Faust Student Software Competition , is intended to promote small, but innovative Faust applications, typically developed in the framework of student projects. The student prize 2018 was awarded to Cloud Generator a nine-voice polyphonic synthesizer developed by Rittik Wystup. The jury praised the audio quality and the care taken by Rittik Wystup in his project! Check the Cloud Generator demo here .","title":"Faust Student Software Competition to Cloud Generator"},{"location":"community/news/#2018-07-10-ifc-2018","text":"","title":"2018-07-10: IFC 2018"},{"location":"community/news/#international-faust-conference-ifc18-july-17-18-2018","text":"The International Faust Conference IFC18 will take place at the Johannes Gutenberg University of Mainz (Germany) on July 17-18, 2018. It aims at gathering developers and users of the Faust programming language to present current projects and discuss future directions for Faust and its community. Participants will be able to share their work through paper presentations. A series of round tables on various topics will serve as a platform to brainstorm on Faust's features, semantics, tools, applications, etc. to determine future directions for this language. Open spaces for demos and workshops will be available for participants to openly share their ongoing projects with the rest of the community. As a special event, the winner of GRAME's Faust Open-Source Software Competition will be announced during IFC18 . IFC-18 is free and everyone is welcome to attend! Please register here --","title":"International Faust Conference IFC18: July 17-18, 2018"},{"location":"community/news/#2018-02-18-faust-award-2018","text":"","title":"2018-02-18: Faust Award 2018"},{"location":"community/news/#faust-award-2018-deadline-june-1-2018","text":"The Faust Open-Source Software Competition is intended to promote innovative high-quality free audio software developed with the Faust programming language, as well as development tools built around the Faust compiler itself. The Faust Open-Source Software award will be attributed to the best submission by an international committee of leading experts in the field. The competition is sponsored by Grame, centre national de cr\u00e9ation musicale. The winning software will receive a 2000\u20ac price to encourage its authors. The results will be announced July 17, 2018 during the International Faust Conference in Mainz IFC18 . To participate, the software must be provided with source code and licensed with a Free/Open Source license. A substantial part of the software must be written in Faust and the Faust source code must be provided. As part of the review process, the software will be built from the sources. All source code, license, video demonstration, installation instructions, and any other documentation must be available on a public web page. License compatibility with other open source software is encouraged. Dependencies on non-open source third-party software are discouraged, with the exception of operating systems and freely available commercial packages. Authors are required to prepare a video demonstrating the software. This video must be done carefully, and should convincingly present the qualities of the software. The submission must also contain any useful documentation, including examples of how the provided software might be used, existing prototypes that use the software, download statistics or other public usage information. The criteria for judging submissions includes broad applicability and potential impact, novelty, technical depth, reusability, etc.","title":"Faust Award 2018: deadline June 1, 2018"},{"location":"community/news/#junior-competition","text":"In parallel to the Faust Open-Source Software Competition we have a junior competition, the Faust Student Software Competition, with a 200\u20ac prize for the winner. The Faust Student Software Competition is intended to promote interesting audio processing and synthesis applications written in Faust in a single file in less than 1000 words. The word count is done after removing the comments from the code: cat foo.dsp | stripcmt | wc -w. The use of the standard Faust libraries is strongly encouraged. They don't take part in the word count.","title":"Junior Competition"},{"location":"community/news/#important-dates","text":"Start of the competition: February 18, 2018 Software Submission Deadline: June 1, 2018 Results of the competition: July 17, 2018","title":"Important dates"},{"location":"community/news/#submission-guidelines","text":"Authors interested in participating in the Faust Open Source Software Competition or the Faust Student Software Competition should send a submission email to faustaward@grame.fr with a PDF file attached containing the following information: Title of submission, Category of submission ( Faust Open Source Software Competition or Faust Student Software Competition ), Name, email and affiliation of the main author, Names, emails and affiliations of other authors, A permanent link for the open source software (e.g., Sourceforge, GitHub, Google Code, etc.), A permanent link for the video demonstration (e.g., YouTube, Vimeo, etc.), A link to a compressed archive file that contains the software (source code, documentation, build/install instructions, and licenses). Comprehensive and clear build/install instructions will be a crucial component of any submission. The committee will make a reasonable effort to build the software for the top contributions, but if they are unable to make the software run, it will be excluded from the competition.","title":"Submission Guidelines"},{"location":"community/news/#international-committee","text":"Jean-Louis Giavitto (IRCAM, Paris, France), Albert Gr\u00e4f (Johannes Gutenberg U., Mainz, Germany), Pierre Jouvelot (Ecole des Mines, Paris, France), Victor Lazzarini (Maynooth U., Maynooth, Ireland), Romain Michon (CCRMA, Stanford , USA) Yann Orlarey (Grame, Lyon, France), Laurent Pottier (U. Jean Monnet, Saint Etienne, France), Julius Smith (CCRMA, Stanford , USA)","title":"International Committee"},{"location":"community/news/#previous-winners","text":"2015: Guitarix , by Hermann Meyer and Andreas Degert 2016: Ambitools , by Pierre Lecomte; Student prize: TouchVoices , by Pierre-Adrien Th\u00e9o.","title":"Previous Winners"},{"location":"community/news/#2017-12-12-webaudio-wasm","text":"","title":"2017-12-12: WebAudio wasm..."},{"location":"community/news/#webaudio-wasm-benchmark-pages-and-tools","text":"WebAudio wasm benchmark pages and tools allow to test statically generated HTML pages from Faust DSP. Audio generating pages in ScriptProcessor or AudioWorklet mode can be tested first. DSP CPU benchmark pages can be used to test the perfomance of wasm code across different browsers. Tools to generate new DSP CPU benchmark pages are also available, and finally a page allowing to test the dynamic compilation chain can be acccesed.","title":"WebAudio wasm benchmark pages and tools"},{"location":"community/news/#simple-pages","text":"Simple pages can be used to test simple monophonic and polyphonic DSP, generated as ScriptProcessor or AudioWorklet WebAudio nodes. statically generated OSC as a ScriptProcessor node statically generated MIDI controllable Organ as a ScriptProcessor node Note that as 12/12/17, AudioWorklet pages can ony be tested with Chrome Canary. Be sure to activate AudioWorklet mode first. On a MacBook Pro OSX El Capitan 2,2 GHz Intel Core i7, we still hear audio glitches when testing them , for example when opening the JavaScript console, or interacting with other applications (like scrolling in the XCode editor, scrolling in the terminal...) statically generated OSC as an AudioWorlet node statically generated MIDI controllable Organ as an AudioWorlet node","title":"Simple pages"},{"location":"community/news/#polyphonic-midi-aware-pages","text":"More complex statically generated polyphonic MIDI aware pages can be tested. ScriptProcessor based pages: modules/clarinetMIDI.html modules/elecGuitarMIDI.html modules/violinMIDI.html AudioWorklet based pages: modules-worklet/clarinetMIDI.html modules-worklet/elecGuitarMIDI.html modules-worklet/violinMIDI.html","title":"Polyphonic MIDI aware pages"},{"location":"community/news/#benchmark-pages","text":"A set of statically generated pages allow to measure the DSP CPU use of Faust generated WebAssemby code. The compute method is repeatedly called in a loop (taking 100% of a core) which duration is measured. Results as MBytes/sec as well a DSP CPU load in % of a 1024 frames, 44.1 kHz audio buffer are displayed. On the following pages, just hit the Start benchmark button, and wait for the result to be displayed. Note that since the computation is done in the main JavaScript thread, don't disturb your machine too much to get a reliable result. The pages can typically be used to compare the performances of different browsers: bench/clarinetMIDI.html bench/djembe.html bench/filterBank.html bench/freeverb.html bench/frenchBell.html bench/guitarEffectChain.html bench/karplus.html bench/karplus32.html bench/kisana.html bench/spectralLevel.html bench/stunedBar6.html bench/violinMIDI.html bench/zitaRev.html","title":"Benchmark pages"},{"location":"community/news/#testing-the-denormal-issue","text":"A specific problem occurs when audio computation produces denormal float values, which is quite common with recursive filters, and can be extremely costly to compute on some processors like the Intel family for instance. Even with the software FTZ mode, we still see huge DSP CPU issue in some cases like this djembe physical model based on simple biquad filters: modules/djembe.html On OSX for instance, open the Activity Monitor tool and look as your browser CPU use. Then hit the checkbox to start playing, and hit it again to stop it. Silence should be produced, but actually very small sample values (= subnormals) are generated. If your machine uses an Intel CPU, you will see CPU raise quite rapidly ! (tested on a MacBook Pro OSX El Capitan 2,2 GHz Intel Core i7).","title":"Testing the denormal issue"},{"location":"community/news/#benchmark-tools","text":"For developers, benchmark tools allow to generate HTML pages to test your DSP. Look in particular at the faust2benchwasm script.","title":"Benchmark tools"},{"location":"community/news/#dynamic-compilation-chain-testing-page","text":"A more complete testing page for monophonic and polyphonic MIDI aware DSP, ScriptProcessor or AudioWorklet mode, FTZ selection mode is available here .","title":"Dynamic compilation chain testing page"},{"location":"community/news/#2017-11-07-1st-ifc","text":"","title":"2017-11-07: 1st IFC"},{"location":"community/news/#1st-international-faust-conference-johannes-gutenberg-university-mainz-germany-july-17-18-2018","text":"The International Faust Conference IFC-18 will take place at the Johannes Gutenberg University of Mainz (Germany) on July 17-18, 2018. It aims at gathering developers and users of the Faust programming language to present current projects and discuss future directions for Faust and its community. Participants will be able to share their work through paper presentations. A series of round tables on various topics will serve as a platform to brainstorm on Faust's features, semantics, tools, applications, etc. to determine future directions for this language. Open spaces for demos and workshops will be available for participants to openly share their ongoing projects with the rest of the community. As a special event, the winner of GRAME's Faust Open-Source Software Competition will be announced during IFC-18. IFC-18 is free and everyone is welcome to attend!","title":"1st International Faust Conference - Johannes Gutenberg University, Mainz (Germany), July 17-18, 2018"},{"location":"community/news/#call-for-papers","text":"We welcome submissions from academic, professional, independent programmers, artists, etc. We solicit original papers centered around the Faust programming language in the following categories: Original research Technology tutorial Artistic project report (e.g., installation, composition, etc.) Paper should be up to 14 pages in length, non anonymous, and formatted according to this template . Submissions should be carried out via our EasyChair portal . All submissions are subject to peer review. Acceptance may be conditional upon changes being made to the paper as directed by reviewers. Accepted papers will be published on-line as well as in the IFC-18 proceedings paper version. They will be presented by their author(s) at IFC-18 as 15 minutes presentations (+ 5 minutes for questions). Feel free to contact us if you have any question.","title":"Call for Papers"},{"location":"community/news/#important-dates_1","text":"Papers submission deadline: March 2, 2018 Notification of Acceptance: May 1, 2018 Camera-Ready Version: June 1, 2018","title":"Important Dates"},{"location":"community/news/#call-for-round-table-topics","text":"A series of round tables on the following themes will take place both afternoons of IFC-18: Faust Tools (e.g., Architectures, IDE, Faust Code Generator, On-Line Services, etc.) DSP in Faust and Faust Libraries (e.g., New Algorithms, New Libraries, Missing Functions, etc.) Faust Compiler and Semantics Other Topics/Open Session We solicit topic suggestions from the Faust community for each of these themes. Topics can be submitted by means of this Google form . They will be introduced during the round tables by the session chair.","title":"Call for Round Table Topics"},{"location":"community/news/#contact","text":"Please, address your questions to: ifc18@muwiinfa.geschichte.uni-mainz.de Conference website: http://www.ifc18.uni-mainz.de","title":"Contact"},{"location":"community/news/#2017-10-20-new-editor","text":"","title":"2017-10-20: New Editor"},{"location":"community/news/#new-faust-editor","text":"We are very happy to announce the online Faust Editor . It can be used to edit , compile and run Faust code from any recent Web Browser with WebAssembly support. This editor works completely on the client side and it is therefore very convenient for situations with many simultaneous users (workshops, classrooms, etc.). It embeds the latest version of the Faust compiler with an efficient WebAssembly backend and offers polyphonic MIDI support.","title":"New Faust Editor"},{"location":"community/news/#features","text":"The editor engine is based on codemirror . It offers syntax highlighting , auto completion and direct access to the online documentation . The documentation command (ctrl-d) uses the function name at the cursor position to locate to the relevant information.","title":"Features"},{"location":"community/news/#recommended-browsers","text":"The recommended browsers are the latest versions of Firefox and Chrome. Chrome is recommended for MIDI, but it requires an https connexion to use the audio inputs. On the other hand MIDI is not supported by Firefox.","title":"Recommended Browsers"},{"location":"community/news/#useful-links","text":"Editor : the official link, https://grame-cncm.github.io/fausteditorweb/ : an alternative link on GitHub. Because this is an https address, audio inputs will work (but not the export function), https://github.com/grame-cncm/fausteditorweb : the GitHub repository.","title":"Useful links"},{"location":"community/news/#2017-09-15-performances","text":"","title":"2017-09-15: Performances..."},{"location":"community/news/#performances-of-audio-dsp-code-compiled-in-webassembly","text":"Porting and running large C/C++ code base on the Web have been the subject of several competing projects in the recent years, from Google NaCl/PNaCl to Mozilla asm.js . Recently standardized WebAssembly language inherits from ideas experimented in both approaches, with the Mozilla vision finnally winning as Robert O'Callahan explains here . Coupled with the WebAudio API , running real-time audio code in the Web now appears to be an achievable goal. WebAssembly is a hot topic in the JavaScript ecosystem. The WebAudio community is eagerly waiting for the AudioWorklet specification, with its promised reduced latency and glitch-free audio rendering, to land in browser development versions, and be tested. Porting well established C/C++ codebase with Emscripten , like the Csound framework as an example, or using DSL languages like Faust, will then naturally beneficiate from improved and more stable performances. The Faust ecosystem already allows to generate static or dynamically compiled WebAssembly based WebAudio nodes . These nodes are still using the deprecated ScriptProcessor WebAudio interface. Premillinary work has been started to be ready as soon at the AudioWorklet model will be testable. In the meantime, work have been started using the WAVM , a standalone VM for WebAssembly, that can load both the standard binary and text wasm format, compiling it in native code using the LLVM chain (generating LLVM IR and compiling it on the fly to native code using LLVM JIT compiler), and running it at (near) native speed. Glue code to load and run Faust generated wasm modules has been written. Validation and benchmarking tools have been developed. Performances comparison with the C++ and LLVM IR Faust backends is the subject of this post.","title":"Performances of audio DSP code compiled in WebAssembly"},{"location":"community/news/#comparing-the-faust-c-llvm-ir-and-wastwasm-backends","text":"The WebAssembly approach promises near native performances for C/C++ written code compiled to WebAssembly using the Emscripten tool chain. Other languages like Rust (using the mir2wasm tool) experiment direct WebAssembly generation. It seems clear that as WebAssembly specification and implementation stabilize, more and more languages will directly generate wasm to be deployed in browsers. The question of the quality of code generation at each step of the compilation chain will rapidly emerge. While WebAssembly is initially designed to run on the Web, it may be deployed in non Web environnement like nodejs , or even in standalone VM like WAVM . Thus WebAssembly becomes a portable binary format that can be used in a large variety of situations. This is especially of interest for a DSL language like Faust.","title":"Comparing the Faust C++, LLVM IR and wast/wasm backends"},{"location":"community/news/#faust-wastwasm-backend","text":"Faust wast/wasm backend directly produce WebAssembly code from the Faust internal FIR (Faust Imperative Representation) code. Generated modules are rather light since they define a very simple ABI to be used by the loader code. Two generation models have been defined: in monophonic mode the wast/mast module internally allocates a memory block to be used for the DSP state (controllers, delays lines, waveforms...) as well as audio buffers. in polyphonic mode, the memory block will be allocated by the loader environnement. This block will typically be sized to contain all the needed voices for the polyphonic DSP. In both cases, a full description of the DSP state as a JSON string is generated in the module data segment (including memory indexes of all controllers). Loader code will get and decode this JSON description, and use whatever parts of the description it needs to run the DSP code. In particular, control memory zones (corresponding to the UI items like buttons, sliders, bargraph...) can be directly read/written by the wrapper code.","title":"Faust wast/wasm backend"},{"location":"community/news/#benchmark-of-c-llvm-ir-and-wastwasm-generated-code","text":"Since Faust already generates C++ or LLVM IR code, the performances of those two backends can be compared with the new wasm one. Using the WAVM C++ written machine allows to deploy the same measuring code . The first benchmark compares the speed of C++, LLVM IR and wasm backends running a set of DSP, running on a MacBook Pro 2,2 GHz Core I7 with OSX El capitan. The same 4.0 version of LLVM toolchain has been used with the three backend. C++ and LLVM IR code has been compiled with the -Ofast optimization flag, the WAVM runtime is the standard version one (without any specific audio optimization, see later): The diagrams clearly shows that the wasm code is still slower than C++ or LLVM IR code, but speed difference is not so high in most cases. Some DSP behaviours need to be understood in more details.","title":"Benchmark of C++, LLVM IR and wast/wasm generated code"},{"location":"community/news/#optimizing-the-wavm-runtime-for-audio-code","text":"The WAVM runtime strictly conforms to the WebAssembly specification, thus behaving as a interesting base reference. In the audio domain, the deployed code is usually compiled with specific optimization flags. Since C++ WAVM runtime can be hacked quite easily, we did several changes into the reference implementation to gain some speed: removing the atomic flag in all load/store that are added to pass all spec WebAssembly tests. adding the equivalent of -fast-math compilation flag that have to be done at LLVM IR and JIT (= native) generation steps. and finally simplifying some mathematical operators, using their standard definition instead of the specific WAVM coded ones that strictly implement WebAssembly official semantic (see for instance the definition of f32.min/f32.max operations). Here is the diagram of DSP examples run with reference WAVM runtime, and the three specific optimizations: After generating the LLVM IR code, the WAVM runtime runs a set of LLVM IR to IR optimizations passes. It remains to be tested if adding more optimization passes (especially the auto-vectorizations ones) could help producing even better code.","title":"Optimizing the WAVM runtime for audio code"},{"location":"community/news/#webassembly-module-optimization-with-binaryen","text":"Binaryen is a compiler and toolchain infrastructure library for WebAssembly , written in C++. We tested the wasm-opt tool at -O3 level on Faust generated wasm modules to estimate which speedup we can expect. The following diagram shows limited gains, with no more than 5% in some of the tested cases:","title":"WebAssembly module optimization with Binaryen"},{"location":"community/news/#float-denormal-handling","text":"A specific problem occurs when audio computation produces denormal float values, which is quite common with recursive filters, and can be extremely costly to compute on some processors like the Intel family for instance. A Flush To Zero (FTZ) mode for denormals can usually be set at hardware level, but it not yet available in the WebAssembly MVP version, which strictly conform to the IEEE 754 norm 8. Thus an automatic software strategy which consists in adding FTZ code in all recursive loops has been implemented in the Faust compiler. To activate it, the -ftz compilation parameter must be used at compilation time. The -ftz 1 mode adds a test in each recursive loop which uses the fabs function and a threshold to detect subnormal samples (slower). The -ftz 2 mode adds a test in each recursive loop which uses a mask to detect subnormal samples (faster). Even if using software ftz is not strictly needed in our benchmark chain (since the C++ WAVM uses the ftz hardware protection mode), we can still compare the speed of the different ftz options. Here is the result of code generated with -ftz from 0 to 2:","title":"Float denormal handling"},{"location":"community/news/#comparing-three-browsers-on-osx-el-capitan","text":"HTML test pages were prepared to compare the performances of the three main browsers on OSX El Capitan. The DSP code is compiled with float denormal protection on (-ftz 2). The generated wasm module compute method is called repeatedly in a timed loop, using successive slices of a big allocated circular audio buffer to avoid cache effects. Here are the results: The fasted one (Chrome for now) can be compared with C++, LLVM IR, WAVM native engines, all compiled with float denormal protection on (-ftz 2):","title":"Comparing three browsers on OSX El Capitan"},{"location":"community/news/#comments-and-conclusion","text":"Testing wasm JIT machines inside browsers is not an easy task. The C++ WAVM runtime revealed to be an excellent tool to compare the Faust C++, LLVM IR and wasm backend. Since its code can be easily adapted, one can estimate also what can be expected deploying wasm DSP modules in pure native environments , outside of the browser, where some audio specific optimizations may be considered. Measures done on a set of Faust DSP show that WebAssembly code still run slower than C++ or LLVM IR generated code in most cases, up to almost 66% slower in the less favorable examples. This value will typically be a bit worse when deploying in browsers, since float denormal protection code has to be used . Benchmarks in browser wasm runtime still need to be done to confirm or refine these findings. Comparing the Chrome , Firefox and WebKit browsers on OSX El Capitan shows that Chrome is currently the fastest engine in most cases, with Firefox and WebKit quite similar (with a slight plus for WebKit). Comparing the Chrome browser with native engines shows results from 4,8 times slower (filterBank.dsp), 2,8 times slower (sTunedBar6.dsp) up to much more favorable cases (karplus32.dsp). Note that filterBank.dsp example is a bit of a pathological case, since Chrome is significantly slower than Firefox and WebKit in this case, and filterBank.dsp uses a lot of pow(10, x) code that is rewritten an optimized as exp10(x) with the C++ backend path.","title":"Comments and Conclusion"},{"location":"community/news/#2017-08-18-faust-on-the-web","text":"","title":"2017-08-18: Faust on the Web"},{"location":"community/news/#deploying-faust-dsp-on-the-web","text":"EDIT : we are at the Web Audio conference 2017, and it appears that the way we currently extend the ScripProcessorNode with Faust code is not the Right Way... Part of the post concerning the exposed API will probably change a bit in the near future... Using latest developments done for the Web (the new WebAssembly backends and libfaust library compiled in WebAssembly with Emscripten), statically and dynamically Faust generated WebAudio nodes can be easily produced and deployed on the Web.","title":"Deploying Faust DSP on the Web"},{"location":"community/news/#deploying-statically-compiled-faust-webaudio-nodes","text":"From a foo.dsp source file, JavaScript and the associated WebAssembly files can be produced with the following script: faust2wasm foo.dsp This will generate a foo.wasm file with the WebAssembly module as binary code, as well as a foo.js wrapper file containing the code needed to turn the Faust DSP in a fully working WebAudio node (using an extended ScriptProcessor node). The name of the Faust DSP code file is used to define the final ScriptProcessorNode constructor name. So for instance if osc.dsp file is compiled, the following faust.createosc function will be generated: /** * Create a 'monophonic' ScriptProcessorNode Web Audio object * by loading and compiling the Faust wasm file * * @param context - the Web Audio context * @param buffer_size - the buffer_size in frames * @param callback - a callback taking the created ScriptProcessorNode as parameter, * or null in case of error */ faust.createosc = function(context, buffer_size, callback) The resulting object is an extended ScriptProcessorNode, to be used as a regular node (like connected to other WebAudio nodes), but which also adds the Faust specific API as defined in the equivalent C++ generated dsp class (see the architecture/faust/dsp/dsp.h header for more technical details), as well as JavaScript more specific functions. For instance the following ones will have to be used to control the node: var paths = node.getParams(); // get the set of paths to read/write input control parameters Then knowing the path for a given parameter, the following function is used to change the parameter value: node.setParamValue(\"/Oscillator/freq\", 0.6); A full JSON description of the node with the complete UI, can be retrieved with: var json = node.getJSON(); The complete usable API is fully documented in the generated JavaScript file in the Public API to be used to control the WebAudio node section.","title":"Deploying statically compiled Faust WebAudio nodes"},{"location":"community/news/#a-simple-example-web-page","text":"A simple Web page using the files generated by faust2wasm on the noise.dsp file can be defined with the following parts: <!-- Load 'faust2wasm' script generated .js file --> <script src=\"noise.js\"></script> A slider to control the noise volume parameter is defined with: <P> Noise volume: <input type=\"range\" oninput=\"changeVolume(event) \"min=\"0\" max=\"1\" value=\"0.5\" step=\"0.01\"/> The WebAudio context is created and the noise slide hander is defined with: var isWebKitAudio = (typeof (webkitAudioContext) !== \"undefined\"); var audio_context = (isWebKitAudio) ? new webkitAudioContext() : new AudioContext(); var noise = null; // Slider handler to change the 'noise' volume function changeVolume(event) { noise.setParamValue(\"/Noise/Volume\", parseFloat(event.target.value)); } A startnoise function which creates the Faust WebAudio node is defined with: function startnoise() { // Create the Faust generated node faust.createnoise(audio_context, 1024, function (node) { noise = node; console.log(noise.getJSON()); // Print paths to be used with 'setParamValue' console.log(noise.getParams()); // Connect it to output as a regular WebAudio node noise.connect(audio_context.destination); }); } An finally the load handler is defined to activate the code: window.addEventListener(\"load\", startnoise); Look at the Noise and OSC online pages for the complete code. Note that pages loading an additional .wasm file cannot directly be loaded in Chrome. You'll have to start a local server (using the python -m SimpleHTTPServer command for instance) and access them with their http:// based URL.","title":"A simple example Web page"},{"location":"community/news/#generating-polyphonic-webaudio-nodes","text":"Assuming that the compiled Faust DSP file is polyphonic ready , a polyphonic ready WebAudio node can be created with the -poly parameter, and will generate the following constructor for the node (where the mydsp part will be replaced by the actual DSP name): /** * Create a 'polyphonic' ScriptProcessorNode Web Audio object * by loading and compiling the Faust wasm file * to be use for the voice, and allocating the number of needed voices * * @param context - the Web Audio context * @param buffer_size - the buffer_size in frames * @param polyphony - the number of polyphonic voices * @param callback - a callback taking the created ScriptProcessorNode * as parameter, or null in case of error */ faust.createmydsp_poly = function(context, buffer_size, polyphony, callback) Polyphonic nodes have an extended API to be controled with MIDI messages: /** * Instantiates a new polyphonic voice. * * @param channel - the MIDI channel (0..15, not used for now) * @param pitch - the MIDI pitch (0..127) * @param velocity - the MIDI velocity (0..127) */ keyOn = function (channel, pitch, velocity) /** * De-instantiates a polyphonic voice. * * @param channel - the MIDI channel (0..15, not used for now) * @param pitch - the MIDI pitch (0..127) * @param velocity - the MIDI velocity (0..127) */ keyOff = function (channel, pitch, velocity) /** * Gently terminates all the active voices. */ allNotesOff = function () Look at the JavaScript public documentation section for the complete description.","title":"Generating Polyphonic WebAudio nodes"},{"location":"community/news/#extended-control-with-comb-parameter","text":"The faust2wasm tool can be used with the -comb parameter to compile several DSP files and contatenate all JavaScript code in a unique resulting comb.js file (possibly to be used in -poly mode also).","title":"Extended control with -comb parameter"},{"location":"community/news/#generating-fully-working-self-contained-html-pages","text":"The faust2webaudiowasm script can be used to generate a fully working self-contained HTML page, with a SVG/CSS a Graphical User Interface. From the osc.dsp Faust DSP source file, it will generate an osc.html file: faust2webaudiowasm osc.dsp Assuming that the compiled Faust DSP file is polyphonic ready, the -poly parameter can be used to generate a polyphonic MIDI controlable instrument, to be used with a MIDI application or device. The -links generates the DSP processor SVG representation, and links to the original DSP file as well as generated SVG files, so that the HTML page can possibly be deployed as a reusable Faust DSP resource.","title":"Generating fully working self-contained HTML pages"},{"location":"community/news/#webassembly-module-optimization","text":"Assuming that you have Binaryen tools installed on your machine, the faust2wasm and faust2webaudiowasm scripts can take an additional -opt parameter to allow WebAssembly module optimization.","title":"WebAssembly module optimization"},{"location":"community/news/#deploying-dynamically-compiled-faust-webaudio-nodes","text":"Since the libfaust library is available for the Web, it becomes possible to embed the complete dynamic compilation chain in a Web page , from the Faust DSP source to the executable WebAudio node. First the following resources (located on the Faust GitHub in architecture/webaudio folder) have to be loaded in the page: <!-- Load 'libfaust' library and wrapper code --> <script src=\"libfaust-wasm.js\"></script> <script src=\"webaudio-wasm-wrapper.js\"></script> Then the two following functions are used to generate factories, creating later on monophonic or polyphonic instances (this is necessary because of the way internal WebAssembly memory is managed): /** * Create a DSP factory from source code as a string to be used to create monophonic DSP * * @param code - the source code as a string * @param argv - an array of parameters to be given to the Faust compiler * @param callback - a callback taking the created DSP factory as parameter, * or null in case of error */ faust.createDSPFactory = function (code, argv, callback) /** * Create a DSP factory from source code as a string to be used to create polyphonic DSP * * @param code - the source code as a string * @param argv - an array of parameters to be given to the Faust compiler * @param callback - a callback taking the created DSP factory as parameter, * or null in case of error */ faust.createPolyDSPFactory = function (code, argv, callback) The two following functions are used to generate monophonic or polyphonic Faust WebAudio nodes: /** * Create a ScriptProcessorNode Web Audio object from a factory * * @param factory - the DSP factory * @param context - the Web Audio context * @param buffer_size - the buffer_size in frames * @param callback - a callback taking the created ScriptProcessorNode as parameter, * or null in case of error */ faust.createDSPInstance = function (factory, context, buffer_size, callback) /** * Create a 'polyphonic' 'ScriptProcessorNode Web Audio object from a factory * * @param factory - the DSP factory * @param context - the Web Audio context * @param buffer_size - the buffer_size in frames * @param polyphony - the number of polyphonic voices * @param callback - a callback taking the created ScriptProcessorNode as parameter, * or null in case of error */ faust.createPolyDSPInstance = function (factory, context, buffer_size, polyphony, callback) The resulting nodes have the same API as statically compiled nodes described in the first section, so can be controlled the same way, including the polyphonic ones. Here is a code example using faust.createDSPFactory and faust.createDSPInstance : var isWebKitAudio = (typeof (webkitAudioContext) !== \"undefined\"); var audio_context = (isWebKitAudio) ? new webkitAudioContext() : new AudioContext(); var dsp_code = \"import(\\\"stdfaust.lib\\\"); vol = hslider(\\\"volume [unit:dB]\\\", 0, -96, 0, 0.1) : ba.db2linear : si.smoo; freq = hslider(\\\"freq [unit:Hz]\\\", 1000, 20, 24000, 1); process = vgroup(\\\"Oscillator\\\", os.osc(freq) * vol);\"; var osc = null; var libraries_url = \"/modules/libraries/\"; function startosc() { // Prepare argv list var argv = []; argv.push(\"-ftz\"); argv.push(\"2\"); argv.push(\"-I\"); argv.push(libraries_url); // Dynamically create the Faust generated node from explicit DSP source in 'dsp_code' faust.createDSPFactory(dsp_code, argv, function (factory) { faust.createDSPInstance(factory, audio_context, 1024 function (node) { osc = node; console.log(osc.getJSON()); // Print paths to be used with 'setParamValue' console.log(osc.getParams()); // Connect it to output as a regular WebAudio node osc.connect(audio_context.destination); })}); } The Dynamic OSC page demonstrates the dynamic OSC complete code (based on the example seen before). The Dynamic Organ page demonstrates a polyphonic organ instrument, which loads a DSP from an url, and ready to be controlled with a MIDI device or application. Look at the Dynamic Faust compiler page for a more complete use-case of the dynamic compiler.","title":"Deploying dynamically compiled Faust WebAudio nodes"},{"location":"community/news/#float-denormal-handling_1","text":"A specific problem occurs when audio computation produces denormal float values, which is quite common with recursive filters, and can be extremely costly to compute on some processors like the Intel family for instance. A Flush To Zero (FTZ) mode for denormals can usually be set at hardware level, but it not yet available in the WebAssembly MVP version, which strictly conform to the IEEE 754 norm 8. Thus an automatic software strategy which consists in adding FTZ code in all recursive loops has been implemented in the Faust compiler. To activate it, the -ftz compilation parameter must be used at compilation time. The -ftz 1 mode adds a test in each recursive loop which uses the fabs function and a threshold to detect subnormal samples (slower). The -ftz 2 mode adds a test in each recursive loop which uses a mask to detect subnormal samples (faster). Use for example the following line to active software denormal handing when using faust2wasm tool: faust2wasm -ftz 2 foo.dsp The same for the faust2webaudiowasm tool: faust2webaudiowasm -ftz 2 foo.dsp For dynamic compilation, the -ftz v flag will have to be added in the argv parameter in faust.createDSPFactory or faust.createPolyDSPFactory , like for instance: faust.createPolyFactory(dsp_code, ['-ftz', '2'], callback);","title":"Float denormal handling"},{"location":"community/news/#2017-06-16-memory-allocator","text":"","title":"2017-06-16: Memory allocator"},{"location":"community/news/#using-a-custom-memory-allocator","text":"From a DSP source file, the Faust compiler typically generates a C++ class. When a rdtable item is used on the source code, the C++ class will contain a table shared by all instances of the class. By default, this table is generated as a static class array, and so allocated in the application global static memory. In some specific case (usually in more constrained deployment cases), managing where this data is allocated is crucial. By extension this post explains how a custom memory allocator can be used to precisely control the DSP memory allocation.","title":"Using a custom memory allocator"},{"location":"community/news/#faust-mem-option-to-control-memory-related-code-generation","text":"A new -mem compiler parameter has been added in the Faust compiler, starting from the 0.9.103 version (or 2.1.4 in Faust2 branch). This parameter will change the way static shared tables are generated. The table is allocated as a class static pointer allocated using a custom memory allocator , which has the following propotype: struct dsp_memory_manager { virtual ~dsp_memory_manager() {} virtual void* allocate(size_t size) = 0; virtual void destroy(void* ptr) = 0; }; Taking the following Faust DSP example: process = (waveform {10,20,30,40,50,60,70}, %(7)~+(3) : rdtable), (waveform {1.1,2.2,3.3,4.4,5.5,6.6,7.7}, %(7)~+(3) : rdtable); Here is the generated code in default mode: ... int mydsp::itbl0[7]; float mydsp::ftbl0[7]; static void classInit(int samplingFreq) { SIG0 sig0; sig0.init(samplingFreq); sig0.fill(7,itbl0); SIG1 sig1; sig1.init(samplingFreq); sig1.fill(7,ftbl0); } virtual void init(int samplingFreq) { classInit(samplingFreq); instanceInit(samplingFreq); } virtual void instanceInit(int samplingFreq) { instanceConstants(samplingFreq); instanceResetUserInterface(); instanceClear(); } ... The two itbl0 and ftbl0 tables are static class arrays. They are filled in the classInit method. The architecture code will typically call the init method (which calls classInit ) on a given DSP, to allocate class related arrays and the DSP itself. If several DSP are going to be allocated, calling classInit only once then the instanceInit method on each allocated DSP is the way to go. In the new -mem mode, the generated C++ code is now: ... int* mydsp::itbl0 = 0; float* mydsp::ftbl0 = 0; dsp_memory_manager* mydsp::fManager = 0; static void classInit(int samplingFreq) { SIG0 sig0; itbl0 = static_cast<int*>(fManager->allocate(sizeof(int) * 7)); sig0.init(samplingFreq); sig0.fill(7,itbl0); SIG1 sig1; ftbl0 = static_cast<float*>(fManager->allocate(sizeof(float) * 7)); sig1.init(samplingFreq); sig1.fill(7,ftbl0); } static void classDestroy() { fManager->destroy(itbl0); fManager->destroy(ftbl0); } virtual void init(int samplingFreq) {} virtual void instanceInit(int samplingFreq) { instanceConstants(samplingFreq); instanceResetUserInterface(); instanceClear(); } ... The two itbl0 and ftbl0 tables are generated a class static pointers. The classInit method takes the additional dsp_memory_manager object used to allocate tables. A new classDestroy method is available to deallocate the tables. Finally the init method is now empty, since the architecure file is supposed to use the classInit/classDestroy method once to allocate and deallocate static tables, and the instanceInit method on each allocated DSP.","title":"Faust -mem option to control memory related code generation"},{"location":"community/news/#control-of-the-dsp-memory-allocation","text":"An architecture file can now define its custom memory manager by subclassing the dsp_memory_manager abstract base class, and implement the two required allocate and destroy methods. Here is an example of a simple heap allocating manager: struct malloc_memory_manager : public dsp_memory_manager { virtual void* allocate(size_t size) { void* res = malloc(size); cout << \"malloc_manager: \" << size << endl; return res; } virtual void destroy(void* ptr) { cout << \"free_manager\" << endl; free(ptr); } };","title":"Control of the DSP memory allocation"},{"location":"community/news/#controlling-the-table-memory-allocation","text":"To control table memory allocation, the architecture file will have to do: // Allocate a custom memory allocator malloc_memory_manager manager; // Setup manager for the class mydsp::fManager = &manager; // Allocate the dsp instance using regular C++ new mydsp* dsp = new mydsp(); // Allocate static tables (using the custom memory allocator) mydsp::classInit(48000); // Initialise the given instance dsp->instanceInit(48000); ... ... // Deallocate the dsp instance using regular C++ delete delete dsp; // Deallocate static tables (using the custom memory allocator) mydsp::classDestroy();","title":"Controlling the table memory allocation"},{"location":"community/news/#controlling-the-complete-dsp-memory-allocation","text":"Full control the DSP memory allocation can be done using C++ placement new : #include <new> // Allocate a custom memory allocator malloc_memory_manager manager; // Setup manager for the class mydsp::fManager = &manager; // Placement new using the custom allocator mydsp* dsp = new(manager.allocate(sizeof(mydsp))) mydsp(); // Allocate static tables (using the custom memory allocator) mydsp::classInit(48000); // Initialise the given instance dsp->instanceInit(48000); ... ... // Calling the destructor dsp->~mydsp(); // Deallocate the pointer itself using the custom memory allocator manager.destroy(dsp); // Deallocate static tables (using the custom memory allocator) mydsp::classDestroy(); More complex custom memory allocators can be developed by refining this malloc_memory_manager example, possibly defining real-time memory allocators...etc... The OWL architecture file already uses this new custom memory allocator model. This is a work in progress: in the Faust2 branch, this model is still not supported yet beside the C++ backend custom memory allocator is not yet supported is additional DSP classes (like the mydsp_poly defined in the achitecture/faust/dsp/poly-dsp.h header).","title":"Controlling the complete DSP memory allocation"},{"location":"community/news/#2017-04-26-optimizing","text":"","title":"2017-04-26: Optimizing..."},{"location":"community/news/#optimizing-the-dsp-cpu-usage","text":"The Faust compiler has as lot of different compilation parameters to play with. Discovering them for a given DSP program is something that can be automated. Two measure_dsp and dsp_optimizer classes are available for developers to measure DSP CPU use directly in their code. Two more friendly faustbench and faustbench-llvm tools have been developed using them. They allow to discover the best Faust compiler parameters, to be used later on with faust2xx scripts, faustgen~ Max/MSP external or FaustLive .","title":"Optimizing the DSP CPU usage"},{"location":"community/news/#the-measure_dsp-and-dsp_optimizer-dsp-decorator-classes","text":"The measure_dsp class defined in the faust/dsp/dsp-bench.h file allows to decorate a given DSP object and measure its compute method CPU consumption. Results are given in Megabytes/seconds (higher is better). Here is a C++ code example of its use: static void bench(dsp* dsp, const string& name) { // Init the DSP dsp->init(48000); // Wraps it with a 'measure_dsp' decorator measure_dsp mes(dsp, 1024, 5); // Measure the CPU use mes.measure(); // Print the stats cout << name << \" CPU use : \" << mes.getStats() << endl; } Only part of the Faust2 branch and defined in the faust/dsp/dsp-optimizer.h file, the dsp_optimizer class uses the libfaust library and its LLVM backend to dynamically compile DSP objects produced with different Faust compiler options, and then measure their DSP CPU. Here is a C++ code example of its use: static void dynamic_bench(const string& dsp_source) { // Init the DSP optimizer with the dsp_source to compile // (either the filename or source code string) dsp_optimizer optimizer(dsp_source, \"/usr/local/share/faust\", \"\", 1024); double value; // Discover the best set of parameters vector<string> options = optimizer.findOptimizedParameters(value); // Print the result cout << \"Best value is for '\" << argv[1] << \"' is : \" << value << \" with \"; for (int i = 0; i < options.size(); i++) { cout << options[i] << \" \"; } cout << endl; }","title":"The measure_dsp and dsp_optimizer DSP decorator classes"},{"location":"community/news/#using-the-faustbench-tool","text":"The faustbench tool uses the C++ backend to generate a set of C++ files produced with different Faust compiler options. All files are then compiled in a unique binary that will measure DSP CPU of all versions of the compiled DSP. The tool is supposed to be launched in a terminal, but it can be used to generate an iOS project, ready to be launched and tested in Xcode. Here are the available options: faustbench [-ios] [Additional Faust options (-vec -vs 8...)] <file.dsp> Use '-ios' to generate an iOS project Use 'export CXX=/path/to/compiler' before running faustbench to change the C++ compiler Use 'export CXXFLAGS=options' before running faustbench to change the C++ compiler options Here is a trace of its use: faustbench karplus32.dsp Selected compiler is g++ with CXXFLAGS = -Ofast -scal : 77.5123 -vec -lv 0 -vs 4 : 64.2194 -vec -lv 0 -vs 8 : 80.8951 -vec -lv 0 -vs 16 : 106.244 ..... -vec -lv 1 -vs 128 -g : 130.635 -vec -lv 1 -vs 256 -g : 134.335 -vec -lv 1 -vs 512 -g : 135.352 Best value is : 136.235 with -vec -lv 0 -vs 512","title":"Using the faustbench tool"},{"location":"community/news/#using-the-faustbench-llvm-tool","text":"Available in the faust2 branch only, the faustbench-llvm tool uses the libfaust library and its LLVM backend to dynamically compile DSP objects produced with different Faust compiler options, and then measure their DSP CPU. In the main Faust folder, use make bench && sudo make install to build and install the tool. Here is a trace of its use: faustbench-llvm karplus32.dsp Estimate timing parameters -scal : 21.1269 duration = 0.102801 count = 24318 Discover best parameters option -scal : 21.1034 -vec -lv 0 -vs 4 : 42.0734 -vec -lv 0 -vs 8 : 55.3725 -vec -lv 0 -vs 16 : 85.3855 ..... -vec -lv 1 -vs 128 -dfs : 133.974 -vec -lv 1 -vs 256 -dfs : 139.12 -vec -lv 1 -vs 512 -dfs : 91.8424 Refined with -mcd -vec -lv 0 -vs 256 -g -mcd 2 : 83.5555 -vec -lv 0 -vs 256 -g -mcd 4 : 138.519 -vec -lv 0 -vs 256 -g -mcd 8 : 140.122 -vec -lv 0 -vs 256 -g -mcd 16 : 141.558 -vec -lv 0 -vs 256 -g -mcd 32 : 139.454 -vec -lv 0 -vs 256 -g -mcd 64 : 143.405 -vec -lv 0 -vs 256 -g -mcd 128 : 142.975 -vec -lv 0 -vs 256 -g -mcd 256 : 139.345 Best value is for 'karplus32.dsp' is : 142.473 with -vec -lv 0 -vs 256 -dfs -mcd 64 w","title":"Using the faustbench-llvm tool"},{"location":"community/news/#2017-02-21-faust-meets-juce","text":"JUCE is an open-source cross-platform C++ application framework, used for the development of desktop and mobile applications. JUCE is used in particular for its GUI and plugins libraries. A set of architecture files have been developed to deploy standalone or plugins built from Faust code. They allow to automatically generate the GUI from the Faust program, possibly supporting polyphonic instruments, and be controlled by MIDI or OSC messages. The architecture files are then combined to produce ready to compile JUCE applications or plugins, using tools that are part of the Faust distribution. They can also be accessed using the Faust online compiler.","title":"2017-02-21: Faust meets JUCE"},{"location":"community/news/#faust2juce-script","text":"faust2juce transforms a Faust DSP program into a fully working JUCE standalone application or plugin, which can possibly be controlled with MIDI or OSC messages. Read its complete description here . You'll have to get a recent github version of Faust tree to use it.","title":"faust2juce script"},{"location":"community/news/#using-the-online-compiler","text":"The Faust online compiler has been updated to provide new 'juce' targets. Note that only some of the possible compilation options are availble for now: the application target produces a standalone MIDI controlable application (using Faust polyphonic code if the Faust source code is polyphonic aware) the plug-in target produces a MIDI controlable mono or polyphonic plugin (using Faust polyphonic code if the Faust source code is polyphonic aware) the jsynth target produces a MIDI controlable mono or polyphonic plugin (using JUCE polyphonic Synthesizer if the Faust source code is polyphonic aware) Directly using faust2juce provides the full control of the generated target with access to all possible compilation parameters.","title":"Using the online compiler"},{"location":"community/news/#graph-of-faust-generated-plugins","text":"Here is an example of three Faust generated plugins running in JUCE plugin host:","title":"Graph of Faust generated plugins"},{"location":"community/news/#using-libfaust-and-llvm","text":"An alternative to faust2juce static-compilation model, is to use Oliver Larkin's juce_faustllvm module, also used in his pMix2 tool .","title":"Using libfaust and LLVM"},{"location":"community/news/#2017-01-13-webassembly","text":"","title":"2017-01-13: WebAssembly..."},{"location":"community/news/#faust-webassembly-backend","text":"WebAssembly was born with the premise of creating a safe, portable and fast to load and execute format suitable for the web. WebAssembly its not a programing language but a compilation target with a text and binary specs. That means that other low level languages like C/C++, Rust, Swift, etc. can compile to WebAssembly. Specified and developed by principal browser compagnies (Google, Mozilla, Microsoft and Apple), this new format aims to finally replace the more hackish \"asm.js\" format initialy developed by Mozilla. Development versions of Chrome and Firefox can already execute it. To get an early preview of this experimental technology, at your own risk: on Chrome Canary , open chrome://flags/#enable-webassembly and enable the switch on Firefox Nightly , open about:config and set javascript.options.wasm to true See a preview of Microsoft Edge support and follow Safari support on WebKit\u2019s feature status .","title":"Faust WebAssembly backend"},{"location":"community/news/#webassembly-backends","text":"New WebAssembly backends have been added in the faust2 development branch. They allow to generate textual or binary WebAssembly code.","title":"WebAssembly backends"},{"location":"community/news/#wast-textual-backend","text":"The 'wast' backend allows to generate textual WebAssembly code (in s-expression like format). Note that as of january 2017, the official textual format is not yet fully specified, thus we follow the format used in the binaryen tool . Use the following command to generate the textual output in the terminal for a given foo.dsp file. faust -lang wast foo.dsp The following command: faust -lang wast foo.dsp -o foo.wast will generate the foo.wast textual WebAssembly output file as well as an additional foo.js JavaScript file containing glue code.","title":"'wast' textual backend"},{"location":"community/news/#wasm-binary-backend","text":"The 'wasm' backend allows to generate binary WebAssembly code. Use the following command to generate the binary output in the terminal for a given foo.dsp file. faust -lang wasm foo.dsp The following command: faust -lang wasm foo.dsp -o foo.wasm will generate the foo.wast binary WebAssembly output file as well as an additional foo.js JavaScript file containing glue code.","title":"'wasm' binary backend"},{"location":"community/news/#generating-static-html-pages","text":"WebAssembly code can be feeded into WebAudio JavaScript nodes, which can then be used like any other native WebAudio node. Two scripts are available to generate static WebAudio html pages from a given foo.dsp source file with the generated html/css/svg user interface: faust2webaudiowast foo.dsp will generate the textual WebAssembly output, use binaryen wasm-as tool to convert the wast to wasm format (you'll have to compile and install the binaryen tools on your machine), and produce a self-contained html page. faust2webaudiowasm foo.dsp will generate the binary WebAssembly output that can directly be loaded by the produced self-contained html page. Page containing polyphonic instruments can be generated with the following commands: faust2webaudiowast -poly foo.dsp to use the 'wast' backend and a polyphonic ready foo.dsp, and create a self-contained html page ready to be used with a MIDI instrument. faust2webaudiowasm -poly foo.dsp to use the 'wasm' backend and a polyphonic ready foo.dsp, and create a self-contained html page ready to be used with a MIDI instrument.","title":"Generating static HTML pages"},{"location":"community/news/#2016-10-17-faust-award-2016","text":"The Faust Open Source Software Competition aims at promoting innovative high-quality free audio software developed with Faust, a functional programming language for realtime signal processing and sound synthesis. The competition is sponsored by GRAME , Centre National de Cr\u00e9ation Musicale","title":"2016-10-17: Faust Award 2016"},{"location":"community/news/#faust-award-2016-to-ambitools","text":"The Faust Award 2016 was attributed by an international committee composed of : Jean-Louis Giavitto (IRCAM, Paris, France), Albert Graef (Johannes Gutenberg U., Mainz, Germany), Pierre Jouvelot (Ecole des Mines, Paris, France), Victor Lazzarini (Maynooth U., Maynooth, Ireland), Romain Michon (Stanford U., Palo Alto, USA) Yann Orlarey (GRAME, Lyon, France), Dave Phillips (musician, journalist, and educator, USA) Laurent Pottier (U. Jean Monnet, Saint-Etienne, France), Julius Smith (Stanford U., Palo Alto, USA) to Ambitools , a set of tools for real-time 3D sound field synthesis using higher order ambisonics (HOA). Ambitools is developed by Pierre Lecomte, a PhD candidate at Conservatoire National des Arts et M\u00e9tiers and Sherbrooke University. The core of the sound processing is written in Faust. The tools contain HOA encoders, decoders, binaural-filters, HOA signals transformations, spherical VU-Meter, etc. and can be compiled in various plug-ins format under Windows, Mac OSX, and Linux. The jury praised the quality and the usefulness of Ambitools: a really useful and technically advanced Faust app and an impressive technical achievement ! Check the demo . The committee was also very impressed by the quality of two other projects : Voice of Faust , a voice synthesizer/effects machine by Bart Brouns ( demo ). PMix , a graphical patcher, preset interpolator and JIT compiler for FAUST by Oliver Larkin ( demo ).","title":"Faust Award 2016 to Ambitools"},{"location":"community/news/#faust-student-software-competition-to-touchvoices","text":"In parallel to the main competition, we introduced this year a junior competition: the Faust Student Software Competition , intended to promote small but interesting Faust applications, typically written as student projects. The student prize was awarded to TouchVoices (by Pierre-Adrien Th\u00e9o, RIM Master student at University Jean Monnet) a real-time web application allowing to capture, playback and transform sound loops. Here is a video of Pierre-Adrien Th\u00e9o during a performance with TouchVoices . A very close competitor was SuperBeatRepeater (by Vincent Rateau, of SuperDirt fame), a sample accurate beat repeater. Don't miss the demo !","title":"Faust Student Software Competition to TouchVoices"},{"location":"community/news/#2016-08-30-faust-book","text":"","title":"2016-08-30: FAUST book..."},{"location":"community/news/#the-first-faust-book-is-korean","text":"\u201c Sound Programming using FAUST \u201d, written by Jin-Wook Chae , an experienced audio developer and sound engineer (right) and Hyun-Hoo Jung (left), is the very first book ever published on FAUST. While the book is written in Korean, I was able to really appreciate the choice of the examples and the elegance as well as the high quality of the code. I am sure it will be an invaluable tool to promote FAUST in Korea among sound engineering, computer music students and more generally any person interested in sound programming. This book is for people desiring to produce musical instruments or sound processors. I have always been instructing my students that the ultimate importance is to discover interesting ideas about the sound. In spite of that, I have often relied on an unflattering response such as \"you may need to learn a programming language like C/C++...\" when a student asked for help with how to execute his/her ideas related to sound. Now I am pleased to recommend the use of FAUST to bring such ideas into execution. This is an easy self-study guide that can help to do just that. Now I can confidently tell anybody pursuing sound or electronic music that their exciting and brilliant idea about sound is what truly counts! So, really, how do we execute our ideas? Today I am introducing you to FAUST and to this book which you will find immensely helpful in terms of how to use FAUST to bring your fabulous ideas into reality. Jinwook Chae","title":"The first FAUST book is Korean !"},{"location":"community/news/#2016-06-30-faust-interpreter","text":"A new 'interpreter' backend has been added in the faust2 development branch. It allows to execute Faust programs without using the LLVM dynamic compiler chain.","title":"2016-06-30: Faust interpreter"},{"location":"community/news/#interpreter-compilation-chain","text":"The dynamic compilation chain allows developers to embed the Faust compiler technology directly in their application or plugins. Faust2 development branch uses an intermediate FIR representation (Faust Imperative Representation), which can be translated to several output languages. An LLVM backend has been previously developed to allows applications to compile a DSP source into executable code in memory, bypassing the external compiler requirement. In some specific situations, embedding the LLVM chain is not possible : for instance Apple does not allow to deploy dynamic compilers on iOS. Thus having an interpreter backend allows to get around this problem and still make Faust code run on those platforms.","title":"Interpreter compilation chain"},{"location":"community/news/#interpreter-backend","text":"The interpreter backend translates the FIR intermediate language into instructions for a virtual machine. A pure C++ interpreter for this instruction set has been implemented.","title":"Interpreter backend"},{"location":"community/news/#running-and-performances","text":"The interpreter backend translates the FIR intermediate language into bytecode for a virtual machine. It allows to run programs about 4 to 5 slower than native speed . Moreover this interpreter can be compiled in a special 'trace' mode to automatically detect various execution errors : invalid heap access, mathematical errors or warnings (division by zero, integer overloading....) which helps us to check the compiler semantic and code generation quality.","title":"Running and performances"},{"location":"community/news/#deployment-for-developers","text":"Given a Faust source code (as a file or a string), calling the createInterpreterDSPFactoryXXX function runs the compilation chain (Faust + interpreter) and generates the \u201cprototype\u201d of the class, as a interpreter-dsp-factory pointer. class interpreter_dsp_factory : public dsp_factory { public: /* Return Factory name */ std::string getName(); /* Return Factory SHA key */ std::string getSHAKey(); /* Return Factory expanded DSP code */ std::string getDSPCode(); /* Creates a new dsp instance */ dsp* createDSPInstance(); }; Note that the library keeps an internal cache of all allocated factories so that the compilation of the same DSP code, that is same source code and same set of 'normalized' (= sorted in a canonical order) compilations options, will return the same (reference counted) factory pointer. You will have to explicitly use deleteInterpreterDSPFactory to properly decrement the reference counter when the factory is no more needed. You can get a unique SHA1 key of the created factory using its getSHAKey method. Next, the createDSPInstance function, corresponding to the new className of C++, instantiates a interpreter-dsp pointer to be used through its interface, connected to the audio chain and controller interfaces. When finished, simply use delete to destroy the dsp instance. class interpreter_dsp : public dsp { public: void metadata(Meta* m); int getNumInputs(); int getNumOutputs(); void init(int samplingRate); void instanceInit(int samplingRate); dsp* clone(); void buildUserInterface(UI* inter); int getSampleRate(); void compute(int count, FAUSTFLOAT** input, FAUSTFLOAT** output); }; Since interpreter_dsp is a subclass of the dsp base class, an object of this type can be used with all already available audio and UI classes, in essence reusing all architecture files already developed for the static C++ class compilation scheme (like OSCUI, httpdUI interfaces etc.), see Developing a new architecture file .","title":"Deployment for developers"},{"location":"community/news/#savingrestoring-the-factory","text":"After the DSP factory has been compiled, your application or plugin may want to save/restore it in order to save Faust to interpreter bytecode compilation at next use. To get the internal factory compiled code, several functions are available: writeInterpreterDSPFactoryToMachine allows to get the interpreter bytecode as a string, writeInterpreterDSPFactoryToMachineFile allows to save the interpreter bytecode in a file, To re-create a DSP factory from a previously saved code, several functions are available: readInterpreterDSPFactoryFromMachine allows to create a DSP factory from a string containing the interpreter bytecode, readInterpreterDSPFactoryFromMachineFile allows to create a DSP factory from a file containing the interpreter bytecode. The complete API is available and documented in the installed faust/dsp/interpreter-dsp.h header.","title":"Saving/restoring the factory"},{"location":"community/news/#2016-04-07-web-audio-api","text":"","title":"2016-04-07: Web Audio API"},{"location":"community/news/#faust-and-the-web-audio-api-3","text":"The Faust compiler can now directly be used in a Web page. Thanks to the Emscripten compiler, the Faust compiler itself can be compiled to asm.js JavaScript. This has been done by compiling the libfaust C++ library to the libfaust.js JavaScript library, that exports a unique entry point.","title":"Faust and the Web Audio API (3)"},{"location":"community/news/#compiling-dsp-to-javascript-asmjs","text":"The libfaust.js exported function createAsmCDSPFactoryFromString(...) allows to create a DSP factory from a given DSP program as a source string and a set of compilations parameters, uses the Faust compiler asm.js backend, and produces the complete asm.js module and additional pure JavaScript methods as a string. Then calling JavaScript 'eval' function on this string compiles it in the browser. The dynamically created asm.js module and additional pure JavaScript methods can then be used. This internal code in then wrapped with additional JavaScript code. A DSP \u201cfactory\u201d will be created from the DSP source code with the following 'synchronous' code (if using the 'libfaust.js' library): var factory = faust.createDSPFactory(code, arguments); or possibly (if using the 'libfaustworker.js' library in the 'asynchronous' model): faust.createDSPFactory(code, arguments, callback); where 'code' is the DSP source as a string, and 'arguments' is an array of parameters to be given to the Faust compiler (like '-vec', '-vs 512'...), and 'callback' is a function taking the created 'factory' as argument. When no more used, you'll have to explicitly use the following code the deallocate the factory: faust.deleteDSPFactory(factory); Your application may want to save the already compiled factory as asm.js/JavaScript code to speed-up possible restore at later time: var machine_code = faust.writeDSPFactoryToMachine(factory); And restore the factory with the following code: var factory = faust.readDSPFactoryFromMachine(machine_code);","title":"Compiling DSP to JavaScript (asm.js)"},{"location":"community/news/#using-dsp-instances","text":"A fully working DSP \u201cinstance\u201d as a Web Audio node is then created with the code: var dsp = faust.createDSPInstance(factory, audio_context, buffer_size); When no more used, you'll have to explicitly use the following code to deallocate the instance: faust.deleteDSPInstance(dsp); This instance can be used like the statically compiled one, as previously described in this page .","title":"Using DSP instances"},{"location":"community/news/#polyphonic-instruments","text":"Polyphonic instruments can be produced. For a given 'factory' the following code will create a 16 voices polyphonic instance: var dsp = faust.createPolyDSPInstance(factory, audio_context, buffer_size, 16); This instance can be used like the statically compiled one, as previously described in this page .","title":"Polyphonic instruments"},{"location":"community/news/#using-faust-javascript-library","text":"The Emscripten compiled Faust library can be used in two ways. Either using the 'libfaust.js' library: <script src=\"libfaust.js\"></script> <script src=\"webaudio-asm-wrapper.js\"></script> or if using worker mode with the following code which loads the 'libfaustworker.js' library: <script src=\"webaudio/webaudio-asm-worker-wrapper.js\"></script>","title":"Using Faust JavaScript library"},{"location":"community/news/#2016-02-05-faust-award-2016","text":"","title":"2016-02-05: Faust Award 2016"},{"location":"community/news/#faust-award-2016-deadline-june-1-2016","text":"The Faust Open-Source Software Competition is intended to promote innovative high-quality free audio software developed with the Faust programming language, as well as development tools build around the Faust compiler itself. The Faust Open-Source Software award will be attributed to the best submission by an international committee of leading experts in the field. The competition is sponsored by Grame, centre national de cr\u00e9ation musicale. The winning software will receive a 2000\u20ac price to encourage its authors. The results will be announced July 15, 2016. To participate, the software must be provided with source code and licensed with a Free/Open Source license. A substantial part of the software must be written in Faust and the Faust source code must be provided. As part of the review process, the software will be built from the sources. All source code, license, video demonstration, installation instructions, and any other documentation must be available on a public web page. License compatibility with other open source software is encouraged. Dependencies on non-open source third-party software are discouraged, with the exception of operating systems and freely available commercial packages. Authors are required to prepare a video demonstrating the software. This video must be done carefully, and should convincingly present the qualities of the software. The submission must also contain any useful documentation, including examples of how the provided software might be used, existing prototypes that use the software, download statistics or other public usage information. The criteria for judging submissions includes broad applicability and potential impact, novelty, technical depth, reusability, etc.","title":"Faust Award 2016: deadline June 1, 2016"},{"location":"community/news/#junior-competition_1","text":"In parallel to the Faust Open-Source Software Competition we introduce this year a junior competition, the Faust Student Software Competition, with a 200\u20ac prize for the winner. The Faust Student Software Competition is intended to promote interesting audio processing and synthesis applications written in Faust in a single file in less than 1000 words. The word count is done after removing the comments from the code: cat foo.dsp | stripcmt | wc -w. The use of the standard Faust libraries is strongly encouraged. They don't take part in the word count.","title":"Junior Competition"},{"location":"community/news/#important-dates_2","text":"Start of the competition: February 8, 2016 Software Submission Deadline: June 1, 2016 Results of the competition: July 1, 2016","title":"Important dates"},{"location":"community/news/#submission-guidelines_1","text":"Authors interested in participating in the Faust Open Source Software Competition or the Faust Student Software Competition should send a submission email to faustaward@grame.fr with a PDF file attached containing the following information: Title of submission, Category of submission ( Faust Open Source Software Competition or Faust Student Software Competition ), Name, email and affiliation of the main author, Names, emails and affiliations of other authors, A permanent link for the open source software (e.g., Sourceforge, GitHub, Google Code, etc.), A permanent link for the video demonstration (e.g., YouTube, Vimeo, etc.), A link to a compressed archive file that contains the software (source code, documentation, build/install instructions, and licenses). Comprehensive and clear build/install instructions will be a crucial component of any submission. The committee will make a reasonable effort to build the software for the top contributions, but if they are unable to make the software run, it will be excluded from the competition.","title":"Submission Guidelines"},{"location":"community/news/#international-committee_1","text":"Jean-Louis Giavitto (IRCAM, Paris, France), Albert Gr\u00e4f (Johannes Gutenberg U., Mainz, Germany), Pierre Jouvelot (Ecole des Mines, Paris, France), Victor Lazzarini (Maynooth U., Maynooth, Ireland), Romain Michon (CCRMA, Stanford , USA) Yann Orlarey (Grame, Lyon, France), Dave Phillips (Musician/Journalist, Findlay, USA) Laurent Pottier (U. Jean Monnet, Saint Etienne, France), Julius Smith (CCRMA, Stanford , USA)","title":"International Committee"},{"location":"community/news/#previous-winners_1","text":"2015: Guitarix , by Hermann Meyer and Andreas Degert","title":"Previous Winners"},{"location":"community/powered-by-faust/","text":"Powered By Faust The following sections provide an overview of the various ways Faust is employed in diverse projects around the world: Musical Pieces and Artistic Projects: Faust is widely used in the creation of musical pieces and artistic projects. Musicians and artists leverage Faust to develop new audio effects and real-time sound synthesis. The language\u2019s flexibility makes it an efficient tool for composing and performing live electronic music. Plugins and Standalone Applications: Faust's code can be compiled into various plugin formats (VST, JUCE, LV2, etc.) and standalone applications. This capability allows developers to create custom audio processing tools that can be integrated into digital audio workstations (DAWs) or used as independent software for audio manipulation and production. Integration in Audio Programming Environments: Faust seamlessly integrates with several audio programming environments like Pure Data, Max/MSP, SuperCollider, the Web platform and others. This integration enables users to incorporate Faust-generated algorithms into larger multimedia projects, enhancing the scope and quality of audio processing and synthesis. Research Projects: Faust is an powerfull resource in academic and industrial research projects. It is used to explore new DSP techniques, develop prototypes, and implement advanced audio algorithms. Development Tools: Developers use Faust to create innovative development tools that assist in the generation, manipulation, and visualization of audio signals. These tools are essential for both educational purposes and advanced research in DSP. Commercial Applications: Several commercial applications incorporate Faust for high-performance audio processing. These applications range from music production software to audio analysis tools, showcasing Faust\u2019s versatility in meeting professional audio requirements. Project World Map To illustrate the global impact of Faust, a world map showcases all the projects using the language. This map highlights the geographical distribution and diversity of applications, reflecting the widespread adoption and influence of Faust in the audio processing community. Project list The following sections provide a detailed list of current projects utilizing Faust. Faust DSP Testbench As a fork of the DSP-Testbench project, Faust DSP Testbench is designed to help developers using the JUCE framework to analyse their Faust DSP by providing a test harness for code inheriting from juce::dsp::ProcessorBase . The harness provides signal sources, routing, analysis and monitoring functions. SHCdyna SHCdyna is a dynamic and interactive application for musical performance. It allows compiling and executing code in the Faust programming language dynamically, interacting with motion sensors, and creating custom tactile user interfaces. The application uses the Interp backend to be deployed on iOS, where JIT compilation is forbidden by Apple. All SmartFaust applications are available in the application, and new ones can be developed in Faust IDE (for instance) and then installed in the application. formuls formuls is an experimental electronic musical instrument for synthesising and sculpting sound live! Using an intuitive, novel touchscreen-based interface, formuls can sculpt primary sounds into kaleidoscopic meshes of finely tuned timbres and pulsating rhythms. Harnessing the power of simple gestural interactions typically used to operate smartphones and tablets, complex sound synthesis techniques are easy to access, control and explore, reducing the required instrumental technique to finger taps, drags and swipes. formuls aims to make synthesis easy for the beginner, while opening up a plethora of creative sonic possibilities to the seasoned sound designer. This software uses libpd, Faust, Open Stage Control and Python. OneTrick B-BOI Feel the funky fresh flow of a dope drum machine straight outta the '90s. Inspired by the \"World's 1st Rap Keyboard\", get down with some phat record scratches, orchestra hits, vocal chops and vocoder stabs that make you wanna jump! It's even got a fly voice changer to help you rap along to the beat. The project is using Rust and the Faust to Rust backend, and the source code is available . FaustVST FaustVst is a VST3 plugin that allows you to dynamically load/compile/edit Faust effects from source dsp files. It is lets you do quick iteration (make a change and reload it nearly instantly), all while running integrated in your DAW. FaustVst uses the faust compiler to create C# code, which is then dynamically compiled into an assembly and run in the plugin. Accessible musical web applications for individuals with disabilities Series of accessible musical web applications aimed to individuals with intellectual disability and cognitive impairments. The applications are designed for an educational program, based on writing and performing a musical composition evoking a natural soundscape. Their responsive interfaces automatically adapt to all screen sizes; in this way they can be used on all kind of devices (smartphone, laptop, etc.). On mobile devices, some sound parameters of the applications can be controlled by the device movement (through accelerometer mapping). Some applications are also MIDI controllable. The applications are developed in JavaScript, using the Web Audio Api, and some DSP are written in Faust and compiled to Web Audio nodes. The project, developed by Matteo Olivo, was presented at SMC 2022 and SMC 2024 . Stratus The compact, all-in-one pedal by Chaos Audio . Run multiple effects at once, swap between presets, and loop for up to 5 minutes. Stratus\u00ae features a 5-minute looper, hands-free preset switching, and a wide range of effects options. You can save and load presets, chain up to seven effects, and access new effects through Tone Shop\u2122. Beginners can experiment and learn without breaking the bank. Seasoned performers save space, time, and benefit from advanced options like MIDI control. The pedal can be programmed with Faust , see also the faust-stratus project. Noisy2 Noisy 2 merges acoustic and analog resonators into lively sounds. Built for MPE and expression, this synth makes sound design more fun. Modal synthesis comes to Noisy 2 with four new acoustic resonators. The Noise block has also evolved, offering new, meticulously crafted noise types for broader acoustic horizons. The DSP is written in Faust. elysiera (VST3/CLAP) A shimmer reverb plugin. Made with nih-plug, egui and Faust. MeshEditor Real-time mesh viewer and editor, using Vulkan and ImGui, and in-progress rigid body audio model, using Faust to render an object audio model to an audio graph. FlowGrid FlowGrid is an immediate-mode interface for Faust (functional audio language) programs. The full project state is backed by a persistent (as in persistent data structures) store supporting constant-time navigation to any point in project history. Faust in Cables.gl Explore the dynamic integration of the Faust audio library within Cables in this video. This segment delves into the intricacies of generating rich audio experiences on the web, leveraging Faust's advanced capabilities for real-time audio synthesis with synthesizers and oscillators. Discover how to seamlessly compile, modify, and visualize audio within Cables, enhancing your projects with intricate audio-visual synchronization and interactive controls, inviting viewers to contribute and experiment with this powerful tool. polyBLEP HOLE A Faust collection of externals for Pure Data stuck together on the Organelle . The polyBLEPs are the work of Jacek Wieczorek. v1.1 triples the oscillators as sounded a bit thin. The greyhold reverb is immense. OneTrick KEYS A physically modeled piano synth with a chill lo-fi sound. It uses a vintage algorithm developed at Stanford in 1995 called \"Commuted Piano Synthesis\", and runs that through studio reverb, vinyl or tape noise, flutter, bitcrushing, and saturation. The project is using Rust and the Faust to Rust backend, and the source code is available . MOD Audio The compact and powerful standalone guitar effects ecosystem to express your creativity at home, in the studio and on stage, which can be programmed with Faust . nih-faust-jit A plugin to load Faust dsp files and JIT-compile them with LLVM. A simple GUI is provided to select which script to load and where to look for the Faust libraries that this script may import. The selected DSP script is saved as part of the plugin state and therefore is saved with your DAW project. ambient.garden ambient.garden is a musical landscape in a website, developed using Teasynth with these Faust codes . All the music in ambient.garden is generated from code. The music is then laid out in a landscape which can be explored, either interactively, or automatically when the autopilot is left on. Teasynth Teasynth is a tool to make music with code in Javascript, Faust and Sporth . There are two main ways of using it: The web editor runs in the browser and provides an instant composition environment. The command line interface can render music to audio files, serve the editor locally, and bundle music code. LICH Technology OWL platform that allows you to use Pure Data, Max Gen or Faust code into your module!. Lich is a Befaco Rebel collaboration that brings back Owl\u2019s platform with this new hardware iteration. It has stereo in and out, four pot controls summed to cv inputs (like the classic Owl module) And as addition, CV and Gate outputs, patch selection with display and USB MIDI host and device connections. lamb A lookahead compressor/limiter that's soft as a lamb, written in Faust and Rust. Lamb was made with these goals in mind: Be as clean as possible Give the user full control over the character with the minimum amount of knobs. FaustSynth Welcome to FaustSynth, a AU/VST monophonic synthesizer built with the Faust programming language. This is the project deliverable for PAT 481: Independent Study in Fall 2023. EnvelopForLive The nonprofit mission of Envelop is to connect and inspire community through immersive listening. Our listening spaces envelop the audience in pristine 3D sound, amplifying the power of music and nurturing our ability to listen together. Some Max/MSP externals are written in Faust . RCVerb (\"ReaClassical Verb\") A reverb suitable for classical music based on zita-rev1. Available as LV2 and CLAP by default (with optional VST3, VST2 and LADSPA). This plugin is part of the ReaClassical project along with RCComp (\"ReaClassical Compressor\") and Enover (RCVerb's big sister) additionals plugins, also written in Faust. Wam-Studio Wam-Studio\u2019s is an online tool for creating audio projects that you can imagine as multi-track music. Each track corresponds to a different \"layer\" of audio content that can be recorded, edited, or just integrated (using audio files for example). Some track can be used to control virtual instruments: in that case we record the sound that is generated internally by these virtual instruments (and played using a MIDI piano keyboard, for example). Tracks can be added or removed, played isolated or with other tracks. They can also be \"armed\" for recording, and when the recording starts, all other tracks will play along, while the armed track will record new content. Wam-Studio can host WAM plugins and in particular Faust ones , which can be built following this tutorial . SNES Echo Simulator SNES Echo is an cross-platform audio processing plugin, written in Faust. It simulates the SNES SPC700 DSP reverb/echo effect. This plugin does not strive for bit-accuracy and overflow handling, but instead being audibly indistinguishable for \"normal\" SPCs. Syfala project Automatic compilation of Faust audio DSP programs for AMD-Xilinx FPGAs, developed by the Emeraude team , and funded by the FAST ANR project. Supported board models are: Digilent Zybo Z7-10 - Zynq-7000 ARM/FPGA SoC Development Board Digilent Zybo Z7-20 - Zynq-7000 ARM/FPGA SoC Development Board Digilent Genesys ZU-3EG - Zynq UltraScale+ MPSoC Development Board Interactive Granular Texture Synthesiser An interactive granular texture synthesiser built in TouchDesigner, utilising real time signal processing of the domain-specific language Faust (functional audiostream), and the corresponding TD_Faust operator. Reflex-in Reflex-in is a sound installation that uses brain-wave streams to create music composition within the Web environment in real time. The work incorporates various state-of-the-art Web technologies, including Web Audio, WebSocket, WebAssembly, and WebGL. The music generated from the algorithm - mapping brain wave signal to musical events - aims to produce a form of furniture music that is relaxing and meditative, possibly therapeutic. The synthesizer part is created from Faust DSP and the installation can be tested here . FaustCGP Generate new audio synthesizers and filters in FAUST with Recurrent Cartesian Genetic Programming. Given a target sound or impulse response as input, the RCGP will return a FAUST synthesizer or filter, respectively, that best approximates the given signal or impulse response. Samples for an early version of the software can be found here . OneTrick URCHIN A hybrid drum synth that models the gritty lo-fi sound of beats from vintage records without sampling. It takes spectral and physically modeled drums, running them through simulated studio reverb, a vinyl or tape player, and finally a digital sampler. The result is a fat and saturated drum machine that creates a vibe of sampling with the control of a synthesizer. The project is using Rust and the Faust to Rust backend, and the source code is available . KBVerb A Faust reverb, based on the Midiverb architecture by Keith Barr . pasfa - Paste Faust code! A paste service for Faust code, to be tested here . FAUSTmapper FAUSTmapper is a tool for binding popular Digital Musical Intrument (DMI) mapping tools to the FAUST ecosystem. The default action for the FAUSTmapper project is establishing a binding to the libmapper project. When the script is run, the entire parameter space of an active FAUST project (with HTTP control enabled) will be discovered. Once discovered, a libmapper signal will be created for each of the parameters identified, including appropriate meta data such as min, max & default values. The following poster was presented at the 4th Annual International Symposium on the Internet of Sounds and was awarded the Best Poster Award. phausto Pharo is a pure object-oriented programming language and a powerful environment, focused on simplicity and immediate feedback (think IDE and OS rolled into one). Phausto allows to use Faust inside Pharo. Cantor Digitalis The Cantor Digitalis is a singing voice synthesiser controlled in real time by chironomy, i.e. by manual gesture, using interfaces such as a stylus or the fingers on a graphics tablet. More generally, it can be controlled using any MIDI interface. The synthesiser has been reimplemented in Faust by Gr\u00e9goire Locqueville during his PhD thesis . Karya Karya is a score language editor with support for scales, instrumental techniques, and ornaments, with special support for Balinese, Javanese, and Carnatic music. It has backends for MIDI, supercollider OSC, lilypond, and an incremental audio renderer that uses Faust or samples. You can write instruments in Faust and integrate them into a score along with samples and MIDI instruments. Due to incremental rendering, even computationally expensive instruments are not a problem. Body Brain Digital Musical Instrument (BBDMI) BBDMI project aims at making music from electrical signals of the muscle and the brain using EMG and EEG technologies. Producing instrumental prototypes in an open way (open software and open hardware) and to document them in the framework of open science (FAIR). The modular system is built with Max/MSP and interfaced with Faust for the purpose of analyzing, processing and mapping electrophysiological signals to sound. The paper An Interactive Modular System for Electrophysiological DMIs received a best paper award at Audio mostly 2023 . The Spatbox The Spatbox is an interface to intuitively generate 3D trajectories and to spatialize them in real-time on a loudspeaker array with Ambisonics, developed by Pierre Lecomte . Each trajectory is described by a parametric curve, where each of the coordinates varies according to a configurable LFO. Depending on the LFO parameters, many trajectories can be generated. The implementation is done in Faust and the project has been presented at PAW 2022 . MUSS3640 Vocal Synthesiser The MUSS3640 Vocal Synthesiser is a standalone application/VST3 plugin developed to allow exploratory synthesis of the singing voice. It implements a combination of formant-wave-function and bandpass synthesis techniques. The DSP is written in Faust. RITI: Room Is The Instrument RITI: Room Is The Instrument by Luca Spanedda , is a piece based on a complex system capable of manifesting emergent and chaotic behaviors, where the acoustic personality of an environment (digital or physical) becomes a case of study for the performance and is reflected in terms of variation in the behavior of the system itself. The DSP code is written in Faust. See a video of a \"studio\" performance of the system . EQUIS EQUIS is a 4 Channel DJ Mixer built on top of JACK. It's EQ is inspired by the Playdifferently Model1 and offers per channel a highpass, lowpass and sculpt eq. The code is developed in Rust and the DSP is written in Faust . See the video presentation at Sonoj convention . ESP32 Wrover E/IE audio dev board A board to play with FAUST sound synthesis language. Kuroscillators Max/MSP objects for audio and rhythmic synthesis using coupled oscillator networks. Coupled Oscillators networks are dynamical systems that describe how ensembles of interacting elements are able to self-organize and synchronize over time. In terms of sensory perception, they have been examined in a wide range of fields including those related to rhythmic entrainment, biomusicology, psychoacoustics, signal processing, and generative music. The DSP is written in Faust . Jou\u00e9 Music Instruments A new way to make music: the Jou\u00e9 Play is a system that combines an expressive multi-instrument, an intuitive app & interactive content, with a range of musical instruments that use touch-sensitive technology to create a unique playing experience. These instruments are designed to be highly expressive, allowing musicians to play with greater nuance and emotion. Part of the audio effects are coded in Faust. ExternalChugins Chugins , short for \"ChucK plugins,\" are plugins for the ChucK programming language . ChucK is an audio programming language that allows for real-time synthesis, composition, and performance of music. Chugins extend the functionality of ChucK by providing additional classes, objects, and modules that can be used to create more complex and intricate music and sound designs. ExternalChugins are a set of chugins exported from Faust. mesh2audio Generate axisymmetric 3D models, or import existing 3D models, and transform them into real-time playable physical audio models! Supports fast DSP generation of physical audio models that sound decently realistic, as well as blazing fast 2D axisymmetric model generation, at the expense of some fidelity. It is an improvement of the mesh2faust tool. The generated audio model can be played in real-time by \"striking\" (clicking) on mesh vertices in the 3D mesh viewer. OneTrick CRYPTID Whispers of a dreaded drum machine with the cold clanging heart of a DX7 in the fearsome frame of a TR-808 echo in dusty backrooms of backstreet recording studios. A contraption conjured under cover of darkness in the heinous pursuit of chart topping tracks, known only as the DX-808. It's time to bring the beast out of the shadows! Allow us to present the world's most accurate recreation of an FM drum synth skeptics say never actually existed. Using a DX7 emulator of our own design, we forged each facet of the CRYPTID, reconstructing its wretched inner-workings. From the \"Log Drum\" Toms to the \"Wood Block\" Cowbell. Blow that Samba Whistle and hit the Gong! Do you want to believe? The project is using Rust and the Faust to Rust backend, and the source code is available . Bespoke Anywhere This paper reports on the Audio Anywhere project, a framework for working with audio plugins that are compiled once and run anywhere. At the heart of Audio Anywhere is an audio engine whose Digital Signal Processing components are written in Faust and deployed with WebAssembly, by Benedict Gaster and Ryan Challinor, presented at Nime 2021 . A Technical Framework for Musical Biofeedback in Stroke Rehabilitation We here present work a generalized low-level technical framework aimed to provide musical biofeedback in post-stroke balance and gait rehabilitation, built by an iterative user-centered process. The framework comprises wireless wearable inertial sensors and a software interface developed using inexpensive and open-source tools. The interface enables layered and adjustable music synthesis, real-time control over biofeedback parameters in several training modes, and extensive supplementary functionality. JUCE and FAUST are used to create a versatile architecture for layered, yet computationally efficient real-time music synthesis. ForceHost ForceHost: an open-source toolchain for generating firmware embedding the authoring and rendering of audio and force-feedback haptics, by Christian Frisson, Mathias Kirkegaard, Thomas Pietrzak, and Marcelo M. Wanderley presented at Nime 2022 . The Faust compiler has been modified to support haptics. Sentinelle Sentinelle is a sound and robotic art installation made by J\u00e9r\u00f4me Abel . A robot-probe is placed in a dark place, a cellar. It scans its surroundings with two lasers. The reliefs of the old walls, their imperfections, mold, appear thanks to the perfectly straight lines of the lasers. Its movements are synchronized with a sound program. From these very simple visual and sound choreographies are born an imaginary on its functioning and the origin of its presence. The spectator observes in a mirror a robot which observes and testifies. Does it communicate with other systems? Does it send information? Its energy is precious, like a heartbeat or a breath, it works in a segmented way with periods of silence. Likewise, his movements are slow and relentless. Faust objects from https://github.com/grame-cncm/faust/tree/master-dev/examples included with pd-faustgen : examples/gameaudio/bubble examples/delayEcho/echo examples/gameaudio/rain examples/generator/sawtoothLab lang.faust~ and ui.faust~ CEAMMC PureData distribution 2023.02. General purpose Pd distribution and library used for work and education purposes in Centre of electroacoustic music of Moscow Conservatory ( CEAMMC ) and ZIL-electro studio. This repository is an assembly of Puredata that includes the CEAMMC library. It includes the lang.faust~ and ui.faust~ externals and a lot of Faust DSP . arco4 - sound synthesis engine and framework Arco is a sound synthesis engine that offers dynamic patching of of unit generators. It is designed to operate as a small embedded server, running either in its own process or within an application. In the spirit of \"smaller is better,\" Arco DSP is mainly delegated to FAUST , leveraging a wide range of existing algorithms. Arco control is delegated to external languages connecting through O2, which supports running Arco within the same application, in a separate process or even on a remote networked host. Arco should be a nice alternative to libpd as an embedded sound engine. The author is mainly using Arco in tandem with Serpent, a real-time Python-like scripting language, but other language bindings are possible. Synthesizer-synthesizer This is a dual-course project for CS378 NLP and CS393P. The goal is to use language model guided program synthesis to synthesize Faust DSP code to ... automatically program synthesizers. Not guaranteed to work. In the slightest. Ambisonics in KMH studios and Lilla salen The general idea behind using ambisonics for diffusing sounds in a space is to, in the first stage, encode an audio signal to a representation of a sound field - a B-format signal. This B-format signal is independent of whatever speaker array the signal will later be diffused on. In the second stage the B-format signal is decoded to the layout of a particular speaker array. In between these two stages a number of transformations may be applied, but the sound source specification may conveniently be specified in the encoder. The decoders are written in Faust. Sardine Sardine is a free/open-source software for Python 3.10+. It turns Python into a musical instrument. You can play it alone or with your friends. With Sardine you can: Play synthesizers and audio samples using SuperCollider. Control synthesizers through MIDI/OSC messages. Interconnect audio/video softwares and/or sound engines. Play collaboratively with your friends. Extend your musical environment using any Python package. Faust written DSP can be used in Sardine. KandiskyScore KandiskyScore is a graphical editor for the analysis and creation of electroacoustic/acousmatic music. It is an html/javascript application. It works perfectly with Firefox, Chrome and Opera and therefore on all Windows, OSX, Linux and other PCs. It uses the WebAudio API for sound generation and the Faust language of the GRAME for plugins. It also allows you to export a graphic score in SVG format that you can eventually modify with a vector graphics software like Inkscape or LibreOffice-draw. fildesoi1_2_3 Software (including Faust code , Max and PureData patches) to perform Fil de Soi 1 and Fil de Soi 2, mixed music pieces by Alain Bonardi for acoustic guitar and electronics. enecho Faust code for En Echo piece by Manoury for soprano and live electronics. Zen Flute The Guthman Musical Instrument Competition is one of the only competitions of its kind - an event dedicated to identifying the newest and greatest ideas in music. Every year, we invite musical inventors from around the world to share their creations and ideas about the future of music. This year first price is Keith Bexter with the Zen Flute , which sound is produced by a physical model of flute written in Faust , and running on a Teensy audio board . souffle An electro track made with Faust . You can listen to a recording here . GHG (Gruppenhorchger\u00e4t) The project is a demonstration of a technique called delay-sum beamforming with the aim to replicate the sound heard by operators of passive sonar devices used in the second world war. Listen to the video here . The simulation code is written in Faust. Satuverb Satuverb is a flexible reverb that has many creative and natural sounding uses, produced by request for FBPM. It has a saturator and EQ controls inside the reverberator, which apply every time the signal is fed back. This causes the effects to grow more extreme as the reverb tail trails off. Satuverb's reverberator is based on Jon Dattorro's 1997 design and written in Faust . faustilogue Convert Faust DSP files to KORG logue custom oscillators, using the logue SDK . Blippoo for Wingie Blippoo for Wingie is an alternative firmware for Wingie2. The new firmware is inspired by Blippoo Box, a genius instrument created by Rob Hordijk (1958-2022), who contributed a lot to synthesizer design. May his spirit lives on in his instrument designs, thoughts, and influences. The new firmware could turn your Wingie2 into a self-contained instrument capable of producing a variety of sounds and patterns. As a great companion, it will help you in your music-making practice especially when you want to applicate controlled chaos in your music. The DSP is written in Faust . 6171_reverb A vintage reverb based on designs from 1961 and 1971, written in Faust . teensy-wfs Distributed Wave Field Synthesis (WFS) implementation for networked Teensies. There is a WFS Controller JUCE app in wfs-controller. This uses JACK's C API to set up ports and connect to any Teensy JackTrip clients. It notifies the clients of their positions in the WFS array, plus the positions of virtual sound sources, via OSC over UDP multicast. The WFS algorithm is written in Faust . pd-remote This is a simplified and unified version of the Pd remote control helpers that I've been distributing with various Pd externals such as pd-faust and pd-lua over the years. The present implementation will work with any of these and replaces the more specialized versions. It takes the form of a Pd abstraction pd-remote.pd and an accompanying pd-remote.el elisp file for Emacs. Crossroad2Effects Crossroad2Effects, the functional successor to @jatinchowdhury's CrossroadsEffects , is a genetic algorithm infrastructure for filter exploration. Provided with dry and wet sound file, Crossroad2Effect determines the filter that tampered the dry file and presents it as a Faust program. This allows users to have granular access to analog or VST filters through a programming interface. This project constructs its genetic algorithm search on top of pedalboard, Spotify's new plugin API. flatten What is an envelope flattener ? It's similar to an automatic gain control, compressor, or maximizer in that it acts by modifying the gain of the signal according to a control signal. Like these, the control signal is derived from the envelope of the input signal. The DSP is written in Faust . drumvoice Drumvoice is a percussion instrument LV2 plugin. Drumvoice can also make lots of other percussion sounds, like kick drums, toms, single hand claps, and all kinds of smaps and blinks. The DSP is written in Faust . Verber Verber is a simple audio plugin tool with a Sweet, Lushy reverb processor. It is a portolio project built in JUCE and HISE, with the DSP in Faust . REACH Extraterrestrial Reverb for Electronic Music. REACH is modern creative Reverb that is made for synthetic sound sources. There are four effects included to transform the Signal. It features modular routing, pre and post filters and over 40 Presets. Part of the DSP code is written in Faust . Stray_virtual-synth A typical wavetable synthesizer will have a table of predetermined amplitude values which are read through at the appropriate speed relative to the frequency of the current note, resulting in an audible signal. Stray functions similarly, reading through a table of values, but the amplitude values are not predefined. Instead, these values are modulated with one of four LFO shapes. The DSP code is written in Faust. Drty Drums A 4 voices drum machine based on FM synthesis [WIP]. The sound engine is made in Faust . 201 Musical Synthesizer We\u2019re Critter & Guitari and we\u2019re happy to announce our newest synthesizer: the 201! If you\u2019re familiar with our other musical instruments such as the Pocket Piano, Organelle, Bolsa Bass, or Kaleidoloop, we hope you\u2019ll see that the 201 fits right in with them: the 201 is fun, portable, and packed with a medley of musical magic! Inside, the 201 uses a combination of Pure Data and Faust musical programming environments. Users are invited to modify or create new sound engines! OneTrick SIMIAN Crash into the 80s with an open source drum synth inspired by hexagonal classics like the Simmons SDS-V . Thumping kicks , punchy snares , and sizzling cymbals coalesce with its clacky claves and crunchy claps . Bring saccharine synthwave sauce to your sublime soundscapes or drop indelable pewww pewww tom toms into your new nu-disco . Get the source code containing Faust DSP , using the Dlang backend. CollisionDrive.lv2 CollisionDrive is modeled after the Horizon Devices Precision Drive, a modern overdrive pedal with a built-in noise gate, with DSP written in Faust . MetalTone.lv2 Distortion Pedal simulation. MetalTone is modeled after the renowned BOSS MT-2 Metal Zone, a high gain distortion pedal with an advanced EQ section, with DSP written in Faust . tamgamp.lv2 Tamgamp (Rhymes with: \"Damage Amp\") is a LV2 guitar amp simulator that provides two plugins, with DSP code developed with Faust : Tamgamp - a plugin based on Guitarix DK Builder simulated chains. TamgampGX - a plugin based on tuned Guitarix internal amplifiers implementation. ReverbZen A Reverb written with Faust and JUCE, based on SchroederReverberators . This reverb effect uses different stages. It splits input signal in parallel and uses different types of delaylines. Different filters are provided to get rid of unwanted resonances. Check out reverb.dsp file to get more detailed insight. Wingie2 Wingie2 is a handheld stereo resonator that you can use as a development platform, and can be programmed with Faust . Slowmo.lv2 A multiband slow gate with delay/echo. The C++ files for the effect are generated from Faust DSP files: Bandsplit.cc , Delay.cc and Volume.cc . Vocoder App Vocoder mobile app for Android made with Faust and its Smartkeyboard interface. This app was developed in the context of a project for the the Real Time Interaction and Performance exam (Sound and Music Computing MSc, Aalborg University, Copenhagen, 2020). The paper A Faust-built Mobile Vocoder Instrument, included in the repo, provides more information on the algorithm, as well as the description of a case prototype. Echoplex Ep-3 Simulator This archive contains a virtual model of the Echoplex Ep-3 tape delay. The effect has been developed using Faust in the context of a project for the Sound Processing exam (Sound and Music Computing MSc, Aalborg University, Copenhagen, 2019). The paper Faust Model of the Echoplex Tape Delay, included in the repo, provides more information on the algorithm. faust2smartphone faust2smartphone is a tool to generate interactive musical mobile application embedded Faust API. DPF-Fadeli An experiment with Faust Demo Library content as DPF plugins. Basically glueing a few different projects together, to compile Faust DSP programs in several plugins format: LADSPA, LV2, VST2, VST3, CLAP : DPF faust faustpp faust examples TR8CK TR8CK is an experimental DAW/tracker with Faust live coding via faust2webaudio and UI powered by SolidJS . GuitarD It's a basic multi effects processor which follows a node based approach. Components are developed with Faust . HISE HISE is an open source framework for building sample based virtual instruments combining a highly performant Disk-Streaming Engine, a flexible DSP-Audio Module system and a handy Interface Designer. The implementation of the Faust integration was the result of a Google Summer of Code project done by Roman Sommer with the help of Christoph Hart as mentor. MBStereophony This is a simple implementation of a Regalia-Mitra filter bank using 3rd order Cauer low-pass filters as the base designs. There are four filter bank programs available which are described below. MBStereophony itself is a demo effect that down-mixes a stereo signal separately per frequency band. Audiolab A docker based DSP learning/Experimentation environment including: Jupyter lab FAUST python 3.7 (at the moment. Depends on miniconda3 docker image) FAUSTpy to run FAUST code inside jupyter faustWidgets (to interactively control FAUST code ) librosa (for MIR and feature extraction) scipy, pandas, numpy for general data science sox (encoding, batch processing etc) ffmpeg (encoding batch processing etc) seaborn (more beautiful plots) latex TODO (for exporting jupyter notebooks) LR_Delay A stereo delay plugin which emphasizes free (non beat-synced) controls for the individual channels. Built with Faust and JUCE. Leslie speaker simulator This archive presents a virtual simulation of the Leslie Speaker commonly found in Hammond electric organs. The digital effect has been developed using the FAUST programming language, and then ported into a VST-compatible format using the JUCE C++ framework. cookiecutter-dpf-faust A cookiecutter project template for DISTRHO Plugin Framework ( DPF ) audio effect plugins using FAUST for the implementation of the DSP pipeline. Look at the demo video . DF Zita Rev1 A feedback-delay-network reverb plugin built with DPF and based on a FAUST library demo. Several other projects are developed using the same DPF/FAUST methothodolgy: FAUST filters , a collection of virtual-analog filters from the FAUST standard library packaged as multi-format plugins via the DPF SendMixer , a stereo channel strip plugin with one master gain and two pre/post-fader sends Stereo Cross Delay , a stereo delay plugin with feedback and cross-mixing. Theremotion Theremotion is a virtual instrument inspired by the Theremin. Just like a Theremin, the position of your hand in the air controls the pitch and volume of the sound. However, you can also control much more dimensions of the sound with specific motions. With specific hand positions, you can control a low pass filter, a supersaw sound, a guitar sound and more. You can even make the instrument \"stick\" to a scale, making it much easier to control than a Theremin. The hand tracking is provided by Ultraleap's Leap Motion Controller . The sound generation is created with Grame's Faust . The program is built with Rust . Hypercurve Hypercurve is a library allowing you to combine several curve algorithms into a single 2D envelope. It is designed to be used in audio applications, for people who know how to enjoy a finely shaped curve. As shown above, you can perfectly combine gaussian curve with diocles cissoid curve, and plenty of other curve algorithms. The library can be used in C++, Lua, Csound and Faust . faust-mcp This package provides a Pd abstraction mcp.pd (along with some helper abstractions and externals) which lets you control your Faust instruments and effects more conveniently with control surfaces utilizing the Mackie Control Protocol (MCP). Faust.quark This SuperCollider package makes it possible to create SuperCollider packages (Quarks) containing plugins written in Faust code. With this, you can distribute plugins written in Faust and make it easy for others to install, compile or uninstall them. It also contains some simple interfaces for the faust and faust2sc.py commands used behind the scenes. Komet Komet is a computer music / sound system by Mads Kjeldgaard written in SuperCollider and Faust . Komet is a computer music system that makes advanced synthesis operations and composition easier. It auto generates thousands of synthesizer variations from simple recipes and offers a range of DAW-like features such as effect chains (like on channel strips) and other conveniences. It can work natively in stereo, multichannel or high order ambisonics mode with the flick of a switch, allowing the same compositions to be used in different sound systems. Faug A Minimoog Model D emulation with the DSP portion written in Faust and using JUCE framework. Moog + Faust = Faug. Striso Studio A virtual Web version of the Striso board, using the Faust WebAssembly compiled sythesizer code . XUiDesigner A WYSIWYG LV2 X11UI GUI creator tool. Provide a easy to use GUI generator tool to create X11 UI's for LV2 plugins. Currently only libxputty is supported, but the generated GUI C file could be used probably with other widget tool-kits as well, just a wrapper file is needed to translate the generated file to the needs of a toolkit. XUiDesigner could now parse faust (.dsp) files and generate a full LV2 Bundle for them. A faust (.dsp) file could be given by the command-line parameter -f or simply by drag it on the Designer window. It will create all control widgets which you could then rework to your needs before you save your Bundle. eurorack-blocks The eurorack-blocks project allows to develop your own custom Eurorack module for either prototyping or fun in the comfort of your day-to-day IDE with the C++ or Faust language , or using the Cycling '74 Max environment, testing and debugging in a virtual Eurorack environment, and when ready, to auto-magically generate all the needed files to manufacture the eurorack module for you to use in a real Eurorack modular system. AmStramGrame An arts and sciences educational project (STEAM), bringing together services and resources for the educational community. It aims at making abstract scientific concepts more tangible and concrete through musical creation and computer programming. The Gramophone is an audio device/musical instrument specifically designed for the AmStramGrame project. Its various sensors and controllers (e.g., accelerometer, gyroscope, light sensor, etc.) make it react to the user's gestures. Its rechargeable battery offering approximately five hours of autonomy and its powerful speaker make it independent from any computer, bringing it closer to traditional acoustic musical instruments. DSP programs are coded in Faust . Additional examples can be found in GramoCollection . GameLAN GameLAN is a set of musical applications designed by Grame , National Center of Musical Creation. They are based on Faust technology and have been designed to be played using only the movements of the smartphone. No musical prerequisite, only your gestures will make you a musician! Screamer Version 1.0 is the accurate Faust reproduction of a VST plug-in written in 2003. In later versions, the parameter ranges is modified and some new functionality are added. This signal mangler features a weird kind of overdrive (see source code for exact formula), a hard-clip distortion, LFO-modulated bit reduction and the possibility of calculating the modulo of a signal. Typebeat Typebeat is a virtual groovebox that\u2019s entirely keyboard-operated. Typebeat draws inspiration from two computing environments. Effects are developped in Faust then generated as Rust modules . AFDN-reverb (High-Order) Ambisonics Feedback Delay Network Reverb. Code is developed in Faust and Max. Karpsichord A virtual harpsichord based on Karplus-Strong string synthesis, implemented in Faust and running in the Web . Arduino Audio Tools Some basic header-only C++ classes that can be used for Audio Processing provided as Arduino Library. A simple Interface class to use Faust with Arduino Audio Tools is provided . Code can be written using Faust . Organelle The Organelle makes it easy to explore new sounds and experiment with new ways of making music. It combines playful and intuitive controls with a powerful and flexible sound engine. The result is an instrument that is limitless in musical possibility and a joy to play. At the heart of the Organelle's sound engine is a robust computer that runs patches. A patch allows the instrument to take on different forms. Onboard hardware for sound input and output and mappable knobs, keys and buttons enable patches to synthesize, sample, effect, and anything in between! The Organelle can be programed with Faust as explained here and with this PD external using Faust . Zrythm Zrythm is a digital audio workstation designed to be featureful and easy to use. It offers streamlined editing workflows with flexible tools, limitless automation capabilities, powerful mixing features, chord assistance and support for various plugin and file formats. A set of Faust effects are compiled as LV2 plugins and included in the application. Patches for the OWL Pedal/Eurorack Module This is a collection of patches written or ported specifically for the OWL. Most of them were written using Faust and if you want to modify them you'll need to have a working FAUST installation. C++ source code (the .hpp files) for the OWL can be generated by running the \"updateFaustPatches.py\" python script. Then you will need to rebuild the OWL firmware and upload it to the device. Kiwi Kiwi is a graphical programming environment dedicated to music and sound creation, such as Max or Pure Data softwares, but offering a real-time collaborative approach: Kiwi allows several distant users to work simultaneously on the same patch hosted online. Kiwi is part of the French ANR-funded MUSICOLL project that unites the CICM and OhmForce. The main goal of this project is to study how collaboration can enhance the way digital audio music composition is taught and more generally how it can renew music creation practices and improve its workflow. Faust DSP programs can be dynamically compiled as objects included in the patch. An extended presentation of the system can be found in this IFC 2020 paper . Brainwave Virtual Instrument The Brainwave Virtual Instrument (BVI) is an open-source software synthesizer built in the programming language Faust. Its purpose is to facilitate the exploration of electroencephalogram (EEG) and other brain data through sonification. Pre-recorded data is translated as parameter controls of the instrument in the form of Open Source Control (OSC) messages that are generated and streamed by a small python program. The instrument can easily be distributed and compiled to different targets thanks to Faust\u2019s flexibility. Frequency Modulation synthesis provides a comprehensive approach to textural parameters of sounds, so that musical composition and improvisation based on a creative use of brain data become feasible. This is exemplified by the Brainwave Etudes (BE), a series of compositions inspired by measurements of brain activity during different states of mind. The BVI was created for two major purposes: on the one hand, to find musical structures that relate to each other in order to present an aesthetic proposal, and on the other, to create a tool that familiarizes scientists and researchers in the field of neuroscience with sonification techniques, and the exploration of brain activity through sound. An extended presentation of the system can be found in this IFC 2020 paper . Mephisto Mephisto is a transpiler for converting sound patches designed using the graphical computer music environment Pure Data to the functional DSP programming language Faust. Faust itself compiles into highly-optimized C++ code. The aim of the transpiler is to enable creating highly optimized C++ code embeddable in games or other interactive media for sound designers, musicians and sound engineers. weather_organ Weather Organ is a Faust instrument for manipulating sparse noise to imitate slowly-changing natural sound sources such as rain, wind, surf, fire, Geiger counters and volcanic activity, and to create interesting new textures of sound. It is the product of various discoveries made while using Faust to explore the definition, synthesis and experience of acoustic noise while, simultaneously using the exploration of noise as as focus for learning Faust. Genius Eurorack Module The Genius is the next evolutionary step for the OWL platform, and the first product released based on a Cortex M7 microcontroller. It runs the OWL firmware and so can be programmed with Faust. A demo running bells from thee physical library can be listened to here . Dataflow Based FPGA Program Synthesis A Yale-NUS BSc. (Hons) in Mathematical, Computational, and Statistical Sciences Capstone: an FPGA Program Generator written in Python that takes dsp-sig XML Dataflow Graphs created using Faust to produce FPGA programs in VHDL. DSPedal DSPedal is a custom hardware platform for real-time sound effects. It is operated by few knobs, external expression pedal, couple of buttons and a small graphical LCD. Processing effect is written in Faust programming language and compiled into C code. So far the Cortex M4 core clocked at 204 MHz has proven to be capable of executing relatively complex effects like wah, but effect-chaining quickly reaches the limits of processing power. Tambura Waveguide physical model of an Indian Tambura/Tanpura. This is a Faust patch inspired by the Indian Tambura/Tanpura - a four string drone instrument, known for its unique rich harmonic timbre. The model uses a few tricks to produce a Tambura-like sound, and should probably be referred to as a \"pseudo\" physical model, because it does not attempt to accurately recreate the physics of the string-bridge interaction. It includes a range of parameters selected to allow control of the qualities of the excitation/pluck, string behavior and sympathetic resonance. It can produce some beautiful evolving drones, which can vary from very synthetic to quite natural. The model can be tested here . drumbox drumbox is a fun and powerful drum synthesizer for your Android device. Start from a preset and tweak the sounds and appearance to make it your own. Freestyle on the drum pads, record a sequence or both...it's up to you! Granola Granola is a monophonic granular live feed processor. The grain processor is inspired by the Mutable Instruments Beads. The grain window shape control is inspired by the GR-1 Granular synthesizer from Tasty Chips Electronics. The DSP code is written in Faust. fverb A stereo variant of the reverberator by Jon Dattorro coded in Faust. Sonification This study has been developed as a proof-of-concept for data pattern sonification. We've implemented data pattern sonification using FM synthesis coded in Faust. Air pollution data, which is temporal, is retrieved from the server and is done pattern mining. Then pattern data sonification is done. GULA Plugins A collection of guitar effect LV2 plugins ( The Vibey , The Splits , The Fades , SSaP Tone , Sweabed , Pequed , Peak audio to CV , LFO CV ) with MOD Devices user interfaces. limiterStereo Yet another look-ahead limiter code in Faust. The novel aspect of this limiter is that it uses N cascaded one-pole filters for amplitude profiling, which improves smoothness in the first to N-1 order derivatives and reduces total harmonic distortion. This design uses four cascaded one-pole lowpass filters, following the cut-off correction formula (8.9) found in [Zavalishin 2012]. Web Audio Modules Web Audio Modules are an open source framework facilitating the development of high-performance Web Audio plugins (instruments, realtime audio effects and MIDI processors). They can be developed using JavaScript and Web standards or compiled from C, C++ code, and domain-specific languages such as Faust or Csound. The Faust Web IDE contains an integrated GUI builder, read a tutorial here . Kapitonov Plugins Pack Set of 7 plugins for guitar sound processing, compiled in LADSPA and LV2 formats. Compatible with hosts such as Ardour, Qtractor, Carla, guitarix, jack-rack. The DSP of all of them is written in Faust. tubeAmp Designer Standalone software guitar processor, editor of *.tapf profile files for tubeAmp (KPP) and guitar amp profiler. BioSignals BioSignals is a data aquisition and processing device for EMG, ECG and EEG signals. Since it is using the OpenWare firmware, it can be programmed with Faust. Scale it Scale it is an open source program (written in graphical programming language Pure data and in Faust) that allows sonification of a signal distribution in real time. There are two different possibilities of sonification of the signal. One of the objects, tone, generates changes in pitch of a monophonic tone. The other object, chord, expresses the input value in width of polyphony. Scale it is being developed primarily for neurofeedback purposes. To allow straightforward and customizable instruments to carry sonic feedback about EEG activity in specific regions of the neocortex. JackTrip JackTrip is a Linux, macOS, or Windows multi-machine audio system used for network music performance over the Internet. It supports any number of channels (as many as the computer/network can handle) of bidirectional, high quality, uncompressed audio signal streaming. Several DSP effects ( compressor , freeverb , zitarev , limiter ) are written in Faust, compiled as C++ code, and included in project sources . Level Rider This is an audio plugin written in Faust that automates gain level adjustments, based on a target gain level, a time window over which overall loudness is calculated via RMS, and a maximum adjustment threshold. This plugin is comparable to Waves Vocal Rider or Waves Bass Rider in its functionality, but is free and open-source. Whetstone Transient Shaper A free, open source transient shaping audio plugin that operates on a specified frequency band. Whetstone will extract a certain frequency band based on a low cutoff and high cutoff that you choose, apply transient shaping to it, and then reintegrate the shaped band back into the original signal. This plugin is meant to be comparable to the excellent Spiff plugin in its core functionality, but lacks many of the nice features and polished UI. The DSP is coded in Faust . Reverb Trickery A free, open source audio plugin implementing various creative reverb effects, including octave-shifted, distorted, hi-pass/low-passed, gated, and narrowing reverb, coded in Faust . b259wf This is a model of the \"tibre\" circuit of the Buchla 259 Complex Wave Generator, made in Faust . The model follows the circuit modelling as seen on the paper Virtual Analog Buchkla 259 wavefolder , using 5 folds. The proposed 2-point BLAMP antialiasing method has been attempted for arbitrary sources as shown here , but it is not sufficient for high frequencies and/or more complex signals. Instead, filtering and light cubic nonlinearity distiorion has been used to round corners and for clipping. The user interface consists of the controls fold for the folding amount, offset for offseting the signal before folding, and lowpass as a final stage one-pole filtering to control the character (too much folding might introduce unwanted higher harmonics for certain signals). The final output is dc-blocked. string-machine This is a virtual-analog string ensemble synthesizer. The implementation is based on a digital model designed by Peter Whiting. The improvement of the model adds various abilities, in particular a virtual-analog emulation of the bucket brigade delay circuit. Most of the DSP code is developed using Faust. Three VST or LV2 are generated: string-machine , string-machine-chorus and string-machine-chorus-stereo . metaFx The metaFx is a control surface for continuous sound transformations in real time, just like the metaSurface64. Like metaSurface64 , it has both its own loop generator and a multi-effects FX engine, but its operation is different, especially for the management of plugin chains and pads. Each mixer on this surface can directly control the gain and the attached plug-ins. It is also possible to control the tracks of an external sequencer (Ardour or Reaper). To do this, the application uses OSC controllable modules that come from the Faust language library that is embedded in the application. Its interest lies in the construction of a parallel sound processing chain in the form of a graph. Kymatica.com Jonatan Liljedahl at Kymatica AB makes iOS music apps, electronic music, and a little bit of audio hardware. The following iOS applications have DSP code developed using Faust: AU3FX:Push : AUv3 dynamics processor with noise gate, compressor/expander with external side-chain input, brick-wall look-ahead limiter and hard/soft clipper. AU3FX:Space : High quality tweakable AUv3 reverb with resonant filters. For everything between small rooms, resonators, and infinitely large spaces. AU3FX:Dub : Stereo AUv3 delay effect for everything from clean digital delays to filthy dub echoes, ping-pong flangers, and broken cassette tapes. AUFX:PeakQ : A versatile 4-band parametric stereo equalizer for everything between subtle frequency enhancements and agressive boosting/cutting or special resonator effects. Nemesis Nemesis is multichannel dsp platform for eurorack. It can be programmed with Faust . Sonobus SonoBus is an easy to use application for streaming high-quality, low-latency peer-to-peer audio between devices over the internet or a local network. Several DSP effects ( Compressor , Expander , Limiter , ParametricEQ , Reverb ) have been written in Faust , compiled as C++ code, and included in the JUCE project . XPlugs.lv2 This repository contain the LV2 plugins developed using libxputty/XUidesigner. The included makfile allows the build of all plugins against a single checkout of libxputty. Each plugin exists as its own submodule under this repository. Some of the DSP code has been written with Faust. Bass Preamp Drive The goal of this project is to digitally reproduce the behavior of a well-known electric bass preamp: Ampeg SVT3 Pro. This preamp has been copied by several manufacturers. So we have an almost perfect copy with the Bugera BVP5500 which has four preamplifier tubes. An analog copy is also available as a pedal, the Tech 21 BDDI. The project is based on advances in the simulation of analog circuits made available by the Guitarix project and the excellent Faust from Grame cncm. Drum Module This project aims at integrating a digital drum synthesizer using Faust and Miosix real time OS on an STM32F407VG Discovery Board. To do this, a user interface by means of buttons, sliders, encoders, and an LCD has been implemented to control the synthesizer. Moreover, a serial MIDI input port has been added in order to control the synthesizer externally by using an external sequencer or controller. Daisy based audio boards Daisy is an embedded platform for music. It features everything you need for creating high fidelity audio hardware devices. Just plug in a USB cable and start making sound! No soldering required. It can be programed with Faust using the faust2daisy tool. Elk Audio OS Elk is an Audio Operating System developed from the ground up to deliver real time audio performances in embedded systems and remote networks. It can run on several hardware . Faust can be used to generate VST2 plugins to run on the plaform. ER-301 Sound Computer The ER-301 is a voltage-controllable canvas for digital signal processing algorithms. It can be programed with Faust using the faust2er301 tool and some units are developed here . Note that it is still a WIP, read the discussion here . Zynthian platform Zynthian is a new class of musical device. A powerful multitimbral synthesizer and audio processor, capable of managing up to 16 audio chains simultaneously. Also, it's a MIDI processor and router, equipped with standard MIDI ports, USB, WIFI & wired networks. Zynthian is a community-driven project and it's 100% open source. The Zynthian platform can be programmed with Faust with some DSP examples here . GxPlugins.lv2 GxPlugins.lv2 is a set of more than 40 extra standalone lv2 plugins designed to compliment the Guitarix project. Each plugin exists as its own submodule under this repository. The DSP code has been written with Faust. Stone phaser A classic analog phaser effect. This is an analog phaser with similarity to the Small Stone. It has a color switch, which makes the phasing stronger when on, and adds some feedback controls. A stereo variant of the phaser is included. This effect is supported on MOD devices. The DSP code is developed in Faust . sfizz sfizz is a sample-based musical synthesizer. It features the well-established SFZ instrument format at its core, which permits to use existing instrument libraries, or create personal instruments with ease. Not only is sfizz ready-to-use as an instrument plugin of its own, the library allows developers to create instruments of their own, taking advantage of the abilities of SFZ. The sfizz project uses the SFZ parser and synth C++ library, providing AU/LV2/VST3 plugins and JACK standalone client. Some effects are developed in Faust are well as several filters . Antescofo Antescofo is a coupling of a real-time listening machine with a reactive and timed synchronous language developed at IRCAM . The language is used for authoring of music pieces involving live musicians and computer processes, and the real-time system assures its correct performance and synchronization despite listening or performance errors. Antescofo audio DSP processes can be described with Faust , using libfaust dynamic version of the Faust compiler. Motion Vox A mobile music creation and performance workstation with a built-in motion-based controller, sequencer and synthesis engine. The controller unites XY pad, accelerometer and gyroscope events with complex data \ufb01ltering engine. Performance process consists of touching the active area on the screen with the index finger and moving the cursor while moving the device in space. Smartphone position in space and finger movement on a screen affect various parameters of sound or generate realtime MIDI output. The app was inspired by the SmartFaust project of GRAME. The audio engine of the app is made with Faust. INScore INScore is an open source framework for the design of interactive, augmented, live music scores. Augmented music scores are graphic spaces providing representation, composition and manipulation of heterogeneous and arbitrary music objects (music scores but also images, text, signals...), both in the graphic and time domains. Audio DSP processes and effects can be described using Faust. The environment runs as a native application but also in the Web. Faust programs are only supported by the online version . Virtual Rhizome By Vincent Carinola . Virtual Rhizome responds to a proposal by Christophe Lebreton and Jean Geoffroy to compose a work for the original Smart Hand Computer system, developed at the GRAME-CNCM using the Faust language and allowing to play smartphones as an instrument. The work takes the form of a labyrinth, a kind of virtual architecture that could be compared to Borges' \"garden of branching paths\", within which the musician evolves by adapting his gestures to the constraints of different types of situations. Each situation is characterized by an autonomous functioning of the system, that the musician must apprehend in order to find the key allowing him to modify it and to move towards another situation. But in order to orientate himself well, he must create a mental representation of the structure of the work. The performer then becomes an explorer of a world that he unveils, but isn't that what he has always been? Virtual rhizome owes much to the availability and enthusiasm of Jean Geoffroy and Christophe Lebreton. It is amicably dedicated to them. SmartFaust SmartFaust is a concept of musical applications for smartphones. These applications have the particularity of only using the user's gestures and not by tapping on the device's screen. Made for iOS and Android, they can also use the motion sensors of these devices to make them real musical instruments. Smartfaust applications are based on the Faust (Functional Audio Stream) programming language developed by Grame over the last 15 years and recognized as a standard in the field of real-time signal processing for audio. The SmartFaust applications were first used for the creation of the pieces Mephisto (for drums and cell phone ensemble), Belzebuth (participative piece for public equipped with Smartphones), Iblis (for clarinet and cell phone ensemble) and B\u00e9lial (for harp and cell phone ensemble) written by the composer Xavier Garcia. From this same technology were later created the applications \"Geek Bagatelles\" (2016) and \"GameLan\" (2019). Download here: Android & iOS Trombone Simulator This simulator is a physical model of a trombone. Physical models of the lips, mouthpiece, slide, and bell are digitally simulated. The controls are listed at the top. The main controls are to move the cursor (or your finger on a touch device) left and right on the picture to adjust the embouchure, and up and down to extend and retract the slide. The diagonal colored lines are a guide to where the resonances are: playing over a resonance means that the embouchure and slide length are matched. Playing over white space means that one is between resonances and the note quality won't be as good. The big gray wedge on the upper right indicates that the resonances are very close together there. The vertical dashed lines indicate the rough locations of B-flat (thick lines) and F (thin lines). Other notes are unmarked, and likewise the slide positions. (Just like on a real trombone!) The off-key resonances (7th, 11th, 13th, and 14th) are marked in red. The g and f keys can be used to growl and flutter-tongue, respectively. The audio simulation is written in Faust, which conveniently compiles to WebAssembly and a Web Audio API wrapper. The overall approach used was a digital waveguide model, as described in J. O. Smith III's Digital Waveguide Theory. The lips and bell are adapted from F. Scott's masters thesis. Integrating 1-DoF force feedback interactions in self-contained DMIs By Mathias Kirkegaard . This thesis presents a system for designers of Digital Musical Instruments (DMIs) to explore the integration of 1 degree of freedom (DoF) force feedback interactions in new self-contained instruments. The system developed consists of an open-source graphical tool and a rotary force-feedback device made from commercially available components to facilitate the authoring of audio-haptic applications. Implementing an early prototype is used to inform the development of the graphical editing tool and its integration in an embedded audio-haptic environment using the functional programming language Faust for real-time signal processing. Beyond Key Velocity: Continuous Sensing for Expressive Control on the Hammond Organ and Digital Keyboards By Giulio Moro . In this thesis we seek to explore the potential for continuous key position to be used as an expressive control in keyboard musical instruments, and how pre- existing skills can be adapted to leverage this additional control. The nonlinear waveguide physical model of a flute has been developed in Faust. Guide de la synth\u00e8se sonore By Sebastien Clara . In this guide, I try to demystify how sound synthesis works. To do so, I present the fundamental principles of sound synthesis. I accompany these explanations with small sound applications that you can manipulate in your web browser and thus, you will be able to notice the impact of a parameter on the sound. Most of the sound examples are written in Faust and run in the web pages. This guide is currently only in french. PICO DSP PICO DSP is an open-source, Arduino-compatible ESP32 development board for audio and digital signal processing (DSP) applications. It offers an expansive audio-processing feature set on a small-format, breadboard-friendly device that provides audio inputs, audio outputs, a low-noise microphone array, an integrated test-speaker option, additional memory, battery-charge management, and ESD protection all on one tiny PCB. The board can be programmed using Faust . Soundjack The Soundjack realtime communication application is extended by a server cloud to handle up to 60 musicians of an orchestra, developed with the Faust programming language. Each musician is connected to a Soundjack UDP client. An individual stereo mix of the multiple audio streams originating from the multiple Soundjack clients has to be provided to each listening musician. An extended presentation of the system can be found in this IFC 2018 paper . studiox-switcher Studiox-switcher is an input switcher and silence detector for JACK. It can switch between 3 stereo inputs, a fallback channel is activated if the active input is below a volume threshold for some amount of seconds, and channels may be switched via OSC and HTTP. The core DSP engine is done via Faust for switching, silence detection and level metering. SynthSpace Synthspace is the ultimate virtual synthesizer. It combines the familiarity of real instruments with the possibilities of virtual worlds. Nodes for Synthspace can be developed in Faust . Bass21 This VST3 is a virtual-analog simulation of the famous Bass Driver DI Version 1 preamp pedal from Tech21. The discretization, while far from being exact, is moderately close to the original. The potentiometers are identical to these physically present on the BDDI pedal, apart from the pregain which is specific to this digital version. The DSP code is written in Faust. EchoMatrix The EchoMatrix was designed to provide some of the functionality of the Yamaha UD Stomp pedal as used be Alan Holdsworth. This project will be submitted to the KVR Developer Challenge 2021 contest to highlight the power of the Faust DSP development environment and the JUCE framework to create a non-trivial effect VST3 using a managable amount of Faust DSP code . The Striso board The Striso board is a very expressive music instrument which combines multidimensionally sensitive keys with an innovative note layout that helps understand the structures in music. The keys capture each subtle finger movement, which allows for levels of musical expression previously only known to acoustic instruments. Additionally, accents and sound effects can be added by shaking and moving the instrument as a whole. The internal sound is written in Faust, and is controlled directly by the signals from the keys and motion sensor. External synthesizers can be controlled using MPE MIDI, or using OSC which is easier to set up for Faust synthesizers. The firmware source code is released as open source. Live concatenative granular processing This algorithm addresses signal discontinuity and concatenation artefacts in real-time granular processing with rectangular windowing. By combining zero-crossing synchronicity, first-order derivative analysis, and Lagrange polynomials, we can generate streams of uncorrelated and non-overlapping sonic fragments with minimal low-order derivatives discontinuities. The resulting open-source algorithm, implemented in the Faust language, provides a versatile real-time software for dynamical looping, wavetable oscillation, and granulation with reduced artefacts due to rectangular windowing and no artefacts from overlap-add-to-one techniques commonly deployed in granular processing. fb_suppression ALS - Automatic Larsen Suppression algorithms implementing adaptive filtering through spectral centroid calculation, and adaptive frequency shifting through RMS calculation. ossia score Ossia score is a sequencer for audio-visual artists, designed to enable the creation of interactive shows, museum installations, intermedia digital artworks, interactive music and more in an intuitive user interface. Faust can be used to create advanced audio processes . A demo video of the Faust integration can be seen here . FASELUNARE Microcosmos Microcosmos is a small open-source electronic board, developed by \u200bFaselunare (Italy), aimed at prototyping electronic musical instruments and learning electronics, microcontroller programming and audio DSP, and programmable with Faust. A demo video of the project can be seen here . The project has been presented at ADC21 . Audio Anywhere The goal of Audio Anywhere is to explore the idea of compile once, run anywhere for audio DSP code. Audio Anywhere combines Faust, for audio DSP code, and HTML5 to enable development of modern audio synthesis and effects tools. There are currently three main repos for this work: AA examples AA standalone app AA Wasmtime runtime The KeyWi An Expressive and Accessible Electronic Wind Instrument, where the sound is synthesized with Faust running on the Bela Mini processing board. React Web Audio Guitar Studio React Web Audio Guitar Studio is an online real-time Web Audio based all-in-one guitar studio, using native plugins written on Faust, compiled on-demand, and ran in a browser. JSPatcher JSPatcher is a Visual Programming Language (VPL) in Max/PureData style on the web with following features: Patch WebAudio native AudioNodes Play with JavaScript Web APIs Import and patch external JavaScript modules Customize AudioWorklet DSPs with Faust A presentation video can be seen here . Gwion Gwion is a programming language aimed at making music. It is strongly inspired by ChucK and can use a set of plugins for Gwion . One allows to use the libfaust library to JIT compile and run DSP code on the fly. The faust2gw tool allows to produce statically compiled modules. sonejostudios A set of tools written using Faust. Panoramix Stereo Panorama/Balance and Volume Automation Tool. Mixer4x A simple 4-channel stereo mixer. The main goal is to use it as a submixer on a 4 channel track, but you can use it everywhere you need a small 4 channel stereo mixer. faustdrumseq A very simple drum sequencer written with Faust, using the new soundfile object. MidiClockClick A simple metronom driven by MidiClock. SuperBeatRepeater Beat Repeater with Sidechain Beat Recognation and Midi-Clock Sync. Very useful i.e to add musical diversity by looping short parts of the stream (i.e drums). SuperCutSequencer Cut \"On/Off\" Sequencer (8 steps with smooth) synced to Midi-Clock Beats and Midi-Clock Start/Stop. Very useful i.e to add musical diversity in looped tracks (very nice with i.e bass lines). DeLooper Sample-accurate Looper/Delay with free mode and midi-clock sync mode. XYMatrix XY Surround Matrix for one Source (Mono Input) with 4 Outputs (Left, Right, Surround Left, Surround Right) and Position Lock. stm32-faust-synth STM32 synthesizer video is a short presentation of a polyphonic synthesizer based on STM32F405 \u00b5C. Faust is used for signal processing and a TLV320AIC23B stereo codec serves as DAC. Another more recent video is here . faustgen2~ The faustgen2~ object is a Faust external for Pd a.k.a. Pure Data , Miller Puckette's interactive multimedia programming environment. Amati Amati is a VST plugin for live-coding effects in the Faust programming language. As of now it only provides basic functionality. PureTones PureTones PureTones is a family of software tools for Indian Classical music. They are built based on an in-depth study and exploration of Indian Classical music to understand the role of harmonics, microtones and consonance in Indian Ragas and musical scales: PureTones Drone (using first tab) , is a digital Tanpura with controls for fine tuning the strings and adjusting their harmonic envelope. PureTones Musical Scale (using second tab) is a digital 12 note keyboard with controls for fine tuning each key to be consonant with an accompanying drone track. PureTones Sequencer (using third tab) is a sequencer which enables composition of melodies and musical works in Indian Classical music using notes from a fine tuned musical scale. The Ragatronics project combines Ragas from Indian Classical music with elements from Rock, Jazz and Electronic music. All applications have been developed using Faust and WebAudio tools. Making Sound Machines Making Sound Machines are a duo of makers from D\u00fcsseldorf, Germany. We build kits, modules and DIY projects, and use the projects we\u2019ve built to make music. Faust is used in several projects. master_me Automatic audio mastering plugin for live-streaming, podcasting and internet radio stations. With the first Covid-19 related lock-downs in 2020, many real-life concerts, conferences and festivals were forced into the digital domain - and sounded pretty crappy. Having worked for almost 20 years in audio mastering, Berlin based engineer Klaus Scheuermann started to develop master_me - a word fusion of automatic mastering and mini-me - in order to make open source streaming sound better. After a few weeks of learning and development, master_me was first used at the 'Quarantine Sessions' - a weekly distributed electro-acoustic improvised concert, hosted at Stanford's CCRMA Institute. master_me was developed further to be an easy-to-use tool for all live streaming applications. In 2022 it was funded by the Prototype Fund, an open source software funding initiative by the german ministry of education and research. A stable release is available since September 2022. metaSurface64 metaSurface64 is a real-time continuous sound transformation control surface that features both its own loop generator for up to 64 voices and a multi-effects FX engine. The application embeds the libfaust dynamic version of the Faust compiler. Fragment Audio Server and Fragment Fragment Audio Server (FAS) is a high performance pixels-based graphical audio synthesizer implemented as a WebSocket server with the C language (C11). Faust , is embedded (when compiled with WITH_FAUST ) and allow to dynamically extend FAS bank generators and effects with custom one written with the Faust DSP specification language. FAS is the audio engine used in Fragment , the Collaborative Graphical Audio Synthesizer. Follow the demo here . Swanky Amp Swanky Amp is a tube amplifier simulation DSP plugin which aims to capture the details in the dynamics of tube amplifiers. The DSP is primarily written in Faust , whereas the UI is written in C++ using the JUCE . Follow the demo here . A commercial version is available here . Web Synth This is a web-based DAW (Digital Audio Workstation) written in Rust/WebAssembly and TypeScript with extensive Faust language integration with dynamic remote code compilation and executing via WebAssembly. Follow the demo here . DawDreamer DawDreamer is an audio-processing Python framework supporting core DAW features such as audio playback, VST MIDI instruments, VST effects, Faust , and parameter automation. DawDreamer is written with JUCE , with a user-friendly Python interface thanks to pybind11 . DawDreamer draws from an earlier VSTi audio \"renderer\", RenderMan . TD-Faust TD-Faust enables Faust code to run inside TouchDesigner . Follow the demo here . Mephisto LV2 Mephisto LV2 a Just-in-Time Faust compiler embedded in an LV2 plugin. Write LV2 audio/cv instruments/filters directly in your host in Faust DSP language without any need to restart/reload host or plugin upon code changes. iPlug2 iPlug 2 is a simple-to-use C++ framework for developing cross platform audio plug-ins/apps and targeting multiple plug-in APIs with the same minimalistic code, support for the Faust programming language, and the libfaust JIT compiler. pMix pMix (short for preset mixer) is a sound design, composition and performance tool that facilitates the control of multiple parameters using an intuitive graphical interface. It includes a graphical patcher for creating a network of audio synthesis or processing nodes. A node could be a VST2, VST3, AU or LADSPA plug-in or it could a JIT compiled Faust script. Faust is a first class citizen in pMix and an integrated code editor and SVG display makes it a nice environment for Faust development. Temper JUCE plugin Temper is a digital distortion audio plugin targeting VST, VST3, and AU for OS X and Windows. It builds upon traditional waveshaping techniques using modulated filter coefficients to produce a unique phase distortion. The primary signal processing loop is written with Faust, and compiled with JUCE for the various build targets. Faust Mass-Interaction mi_faust implements 1D mass-interaction models in the Faust programming language. Starting from a scripted model description (see MIMS), mi_faust compiles a physical model into Faust code. It handles this by generating routing functions between all the masses and all the interactions in the model. Head over to the FAUST community page to see examples of a series of instruments created in mi_faust, and available as web-apps ! Dynamic PedalBoard Dynamic PedalBoard allows users to plug different stompboxes together in a web browser. SHARC DSP Board The ADI SHARC DSP board fully supports Faust. Nuance Nuance is a pressure sensitive music controller that uses Faust for sound synthesis and processing. The PlateAxe The PlateAxe is a percussion instrument physical model controller using Faust for sound synthesis and processing. The BladeAxe The BladeAxe is an electric guitar physical model controller using Faust for sound synthesis and processing. Bart Brouns' Projects A collection of projects by Bart Brouns and based on Faust. EarTone Toolbox The Ear Tone Toolbox is a collection of unit generators for the production of auditory distortion product synthesis. AudioKit AudioKit allows developers to quickly add professional audio functionality to iOS, macOS, and Apple Watch apps. Radium Radium is a music editor with a new type of interface. It includes a Faust audio DSP development environment. Compared to the normal sequencer interface editing is quicker and more musical data fits on the screen. Compared to trackers, note positions and effects are edited graphically, which should be quicker, provide more vertical space and give a better musically overview. (Everything can also be edited by text, like in a normal tracker) Radium can also be used as a normal multitracker to mix and record audio. BELA Bela is a maker platform for creating beautifully responsive audio and interactive applications. Designed for artists, musicians, researchers and makers, Bela brings the power of ultra-low latency interactive audio and sensors to your digital projects. It can be programmed with Faust . HOA Library HOA Library allows musicians and composers to synthesize, transform and render sound fields in a creative and artistic way. This library facilitates the understanding and the appropriation of key concepts of ambisonics. Thanks to original graphical interfaces a lot of new signal processings are allowed like diffuse sound field synthesis, perspective distorsion or spatial filtering. HOA library is open-source and free and offers a set of C++ and FAUST classes and implementation for Max, PureData and Unity. Ambitools Ambitools is a collection of plug-ins and tools for 3D sound field synthesis using Higher Order Ambisonics (HOA). The plugins are written in the Faust language , which allows them to be compiled for a multitude of architectures and platforms (Windows, Mac, Linux, WebAudio, embedded systems, etc.) Moreover, the code is written in a scalable way: there is no limit to the maximum Ambisonic order! Other tools are also available, such as a 3D Visualizer written in the Processing language. Ambisonic Decoder Toolbox The Ambisonic Decoder Toolbox is a collection of MATLAB and GNU Octave functions for creating Ambisonic Decoders. Currently, it implements: (1) the AllRAD design technique, (2) inversion or mode-matching, (3) truncated mode-matching, constant energy, (4) linear combinations of 2 and 3, and (5) Slepian function basis (EPAD). The DSP code is written in MATLAB and Faust. Ambisonic.xyz A set of tools around Ambisonics. FaustPy FaustPy is a Python wrapper for Faust. It is implemented using the CFFI and hence creates the wrapper dynamically at run-time. Rebel Technology The OWL Pedal is an open source, programmable stage effects pedal, made for guitarists, musicians, hackers and programmers. Users can program their own effects, or download ready-made patches from our growing online patch library. faust-vst This project provides a VST plugin architecture for the Faust programming language. The package contains the Faust architecture, faustvst.cpp, the faust2faustvst helper script which provides a quick way to compile a plugin, a collection of sample plugins written in Faust, and a generic GNU Makefile for compiling and installing the plugins. faust-lv2 This project provides an LV2 plugin architecture for the Faust programming language. The package contains the Faust architecture and templates for the needed LV2 manifest (ttl) files, a collection of sample plugins written in Faust, and a generic GNU Makefile as well as a shell script to compile plugins using the architecture. RDK Reverb Design is about creating a spacial impression aimed at sweetening the listening experience for a given context. The ambiguity of auditory and visual cues in reproduced sound makes it necessary to create an auditory illusion: To make this illusion work, I propose an aesthetic concept of simplicity and intelligibility based on psychoacoustic facts and recording practice as professional producer. Foo YC20 The Foo YC20 is an open source implementation of the Yamaha YC-20 combo organ from 1969. Processing for the organ is based on original schematics and measurements from a working specimen. This instrument simulates the circutry as a whole to realisticly reproduce the features and flaws of the real deal. FaucK FaucK is a Chugin allowing to combine the powerful, succinct Functional AUdio STream (Faust) language with the strongly-timed ChucK audio programming language. FaucK allows programmers to on-the-fly evaluate Faust code directly from ChucK code and control Faust signal processors using ChucK's sample-precise timing and concurrency mechanisms. The goal is to create an amalgam that plays to the strengths of each language, giving rise to new possibilities for rapid prototyping, interaction design and controller mapping, pedagogy, and new ways of working with both Faust and ChucK. Snd-RT Snd-RT is the realtime extension for the sound editor SND and consists of two parts: the RT Engine - An engine for doing realtime signal processing. the RT Compiler - A compiler for a scheme-like programming language to generate realtime-safe code understood by the RT Engine. Pure Language Pure is a modern-style functional programming language based on term rewriting. It offers equational definitions with pattern matching, full symbolic rewriting capabilities, dynamic typing, eager and lazy evaluation, lexical closures, built-in list and matrix support and an easy-to-use C interface. The interpreter uses LLVM as a backend to JIT-compile Pure programs to fast native code. It has been created by Albert Gr\u00e4f. pd-faust is a collection of Pd objects written using pd-pure which lets you run Faust programs inside Pd. It combines the functionality of pure-faust and faust2pd in a single package, and also features dynamic reloading of Faust plugins, automatic generation of controller GUIs and MIDI/OSC controller mappings, as well as OSC-based controller automation. It thus provides a complete solution for interactively developing Faust dsps in Pd. Guitarix An audio plug-in for guitar effects whose sound processing engine is written in Faust. moForte GeoShred An electric guitar app using physical modeling. Faust was used to implement its sound synthesis/processing engine. moForte PowerStomp An app implementing various guitar effects to be used on stage. moForte Guitar An app that can be used as an electric guitar and whose sound synthesis engine is implemented in Faust. FaustWorks FaustWorks is an IDE (Integrated Development Environment) for the Faust dsp programming language. You must have Faust installed to be able to use FaustWorks. Platforms supported are Linux and OSX. FaustLive FaustLive is an advanced self-contained prototyping environment for the Faust programming language with an ultra-short edit-compile-run cycle. Thanks to its fully embedded compilation chain, FaustLive is simple to install and doesn't require any external compiler, development toolchain or SDK to run. FaustLive is the ideal tool for fast prototyping. Faust programs can be compiled and run on the fly by simple drag and drop. They can even be edited and recompiled while running, without sound interruption. It supports also native applications generation using the Faust online compiler. FaustLive is based on the Faust library and on LLVM. \u200b","title":"Powered By Faust"},{"location":"community/powered-by-faust/#powered-by-faust","text":"The following sections provide an overview of the various ways Faust is employed in diverse projects around the world: Musical Pieces and Artistic Projects: Faust is widely used in the creation of musical pieces and artistic projects. Musicians and artists leverage Faust to develop new audio effects and real-time sound synthesis. The language\u2019s flexibility makes it an efficient tool for composing and performing live electronic music. Plugins and Standalone Applications: Faust's code can be compiled into various plugin formats (VST, JUCE, LV2, etc.) and standalone applications. This capability allows developers to create custom audio processing tools that can be integrated into digital audio workstations (DAWs) or used as independent software for audio manipulation and production. Integration in Audio Programming Environments: Faust seamlessly integrates with several audio programming environments like Pure Data, Max/MSP, SuperCollider, the Web platform and others. This integration enables users to incorporate Faust-generated algorithms into larger multimedia projects, enhancing the scope and quality of audio processing and synthesis. Research Projects: Faust is an powerfull resource in academic and industrial research projects. It is used to explore new DSP techniques, develop prototypes, and implement advanced audio algorithms. Development Tools: Developers use Faust to create innovative development tools that assist in the generation, manipulation, and visualization of audio signals. These tools are essential for both educational purposes and advanced research in DSP. Commercial Applications: Several commercial applications incorporate Faust for high-performance audio processing. These applications range from music production software to audio analysis tools, showcasing Faust\u2019s versatility in meeting professional audio requirements.","title":"Powered By Faust"},{"location":"community/powered-by-faust/#project-world-map","text":"To illustrate the global impact of Faust, a world map showcases all the projects using the language. This map highlights the geographical distribution and diversity of applications, reflecting the widespread adoption and influence of Faust in the audio processing community.","title":"Project World Map"},{"location":"community/powered-by-faust/#project-list","text":"The following sections provide a detailed list of current projects utilizing Faust.","title":"Project list"},{"location":"community/powered-by-faust/#faust-dsp-testbench","text":"As a fork of the DSP-Testbench project, Faust DSP Testbench is designed to help developers using the JUCE framework to analyse their Faust DSP by providing a test harness for code inheriting from juce::dsp::ProcessorBase . The harness provides signal sources, routing, analysis and monitoring functions.","title":"Faust DSP Testbench"},{"location":"community/powered-by-faust/#shcdyna","text":"SHCdyna is a dynamic and interactive application for musical performance. It allows compiling and executing code in the Faust programming language dynamically, interacting with motion sensors, and creating custom tactile user interfaces. The application uses the Interp backend to be deployed on iOS, where JIT compilation is forbidden by Apple. All SmartFaust applications are available in the application, and new ones can be developed in Faust IDE (for instance) and then installed in the application.","title":"SHCdyna"},{"location":"community/powered-by-faust/#formuls","text":"formuls is an experimental electronic musical instrument for synthesising and sculpting sound live! Using an intuitive, novel touchscreen-based interface, formuls can sculpt primary sounds into kaleidoscopic meshes of finely tuned timbres and pulsating rhythms. Harnessing the power of simple gestural interactions typically used to operate smartphones and tablets, complex sound synthesis techniques are easy to access, control and explore, reducing the required instrumental technique to finger taps, drags and swipes. formuls aims to make synthesis easy for the beginner, while opening up a plethora of creative sonic possibilities to the seasoned sound designer. This software uses libpd, Faust, Open Stage Control and Python.","title":"formuls"},{"location":"community/powered-by-faust/#onetrick-b-boi","text":"Feel the funky fresh flow of a dope drum machine straight outta the '90s. Inspired by the \"World's 1st Rap Keyboard\", get down with some phat record scratches, orchestra hits, vocal chops and vocoder stabs that make you wanna jump! It's even got a fly voice changer to help you rap along to the beat. The project is using Rust and the Faust to Rust backend, and the source code is available .","title":"OneTrick B-BOI"},{"location":"community/powered-by-faust/#faustvst","text":"FaustVst is a VST3 plugin that allows you to dynamically load/compile/edit Faust effects from source dsp files. It is lets you do quick iteration (make a change and reload it nearly instantly), all while running integrated in your DAW. FaustVst uses the faust compiler to create C# code, which is then dynamically compiled into an assembly and run in the plugin.","title":"FaustVST"},{"location":"community/powered-by-faust/#accessible-musical-web-applications-for-individuals-with-disabilities","text":"Series of accessible musical web applications aimed to individuals with intellectual disability and cognitive impairments. The applications are designed for an educational program, based on writing and performing a musical composition evoking a natural soundscape. Their responsive interfaces automatically adapt to all screen sizes; in this way they can be used on all kind of devices (smartphone, laptop, etc.). On mobile devices, some sound parameters of the applications can be controlled by the device movement (through accelerometer mapping). Some applications are also MIDI controllable. The applications are developed in JavaScript, using the Web Audio Api, and some DSP are written in Faust and compiled to Web Audio nodes. The project, developed by Matteo Olivo, was presented at SMC 2022 and SMC 2024 .","title":"Accessible musical web applications for individuals with disabilities"},{"location":"community/powered-by-faust/#stratus","text":"The compact, all-in-one pedal by Chaos Audio . Run multiple effects at once, swap between presets, and loop for up to 5 minutes. Stratus\u00ae features a 5-minute looper, hands-free preset switching, and a wide range of effects options. You can save and load presets, chain up to seven effects, and access new effects through Tone Shop\u2122. Beginners can experiment and learn without breaking the bank. Seasoned performers save space, time, and benefit from advanced options like MIDI control. The pedal can be programmed with Faust , see also the faust-stratus project.","title":"Stratus"},{"location":"community/powered-by-faust/#noisy2","text":"Noisy 2 merges acoustic and analog resonators into lively sounds. Built for MPE and expression, this synth makes sound design more fun. Modal synthesis comes to Noisy 2 with four new acoustic resonators. The Noise block has also evolved, offering new, meticulously crafted noise types for broader acoustic horizons. The DSP is written in Faust.","title":"Noisy2"},{"location":"community/powered-by-faust/#elysiera","text":"(VST3/CLAP) A shimmer reverb plugin. Made with nih-plug, egui and Faust.","title":"elysiera"},{"location":"community/powered-by-faust/#mesheditor","text":"Real-time mesh viewer and editor, using Vulkan and ImGui, and in-progress rigid body audio model, using Faust to render an object audio model to an audio graph.","title":"MeshEditor"},{"location":"community/powered-by-faust/#flowgrid","text":"FlowGrid is an immediate-mode interface for Faust (functional audio language) programs. The full project state is backed by a persistent (as in persistent data structures) store supporting constant-time navigation to any point in project history.","title":"FlowGrid"},{"location":"community/powered-by-faust/#faust-in-cablesgl","text":"Explore the dynamic integration of the Faust audio library within Cables in this video. This segment delves into the intricacies of generating rich audio experiences on the web, leveraging Faust's advanced capabilities for real-time audio synthesis with synthesizers and oscillators. Discover how to seamlessly compile, modify, and visualize audio within Cables, enhancing your projects with intricate audio-visual synchronization and interactive controls, inviting viewers to contribute and experiment with this powerful tool.","title":"Faust in Cables.gl"},{"location":"community/powered-by-faust/#polyblep-hole","text":"A Faust collection of externals for Pure Data stuck together on the Organelle . The polyBLEPs are the work of Jacek Wieczorek. v1.1 triples the oscillators as sounded a bit thin. The greyhold reverb is immense.","title":"polyBLEP HOLE"},{"location":"community/powered-by-faust/#onetrick-keys","text":"A physically modeled piano synth with a chill lo-fi sound. It uses a vintage algorithm developed at Stanford in 1995 called \"Commuted Piano Synthesis\", and runs that through studio reverb, vinyl or tape noise, flutter, bitcrushing, and saturation. The project is using Rust and the Faust to Rust backend, and the source code is available .","title":"OneTrick KEYS"},{"location":"community/powered-by-faust/#mod-audio","text":"The compact and powerful standalone guitar effects ecosystem to express your creativity at home, in the studio and on stage, which can be programmed with Faust .","title":"MOD Audio"},{"location":"community/powered-by-faust/#nih-faust-jit","text":"A plugin to load Faust dsp files and JIT-compile them with LLVM. A simple GUI is provided to select which script to load and where to look for the Faust libraries that this script may import. The selected DSP script is saved as part of the plugin state and therefore is saved with your DAW project.","title":"nih-faust-jit"},{"location":"community/powered-by-faust/#ambientgarden","text":"ambient.garden is a musical landscape in a website, developed using Teasynth with these Faust codes . All the music in ambient.garden is generated from code. The music is then laid out in a landscape which can be explored, either interactively, or automatically when the autopilot is left on.","title":"ambient.garden"},{"location":"community/powered-by-faust/#teasynth","text":"Teasynth is a tool to make music with code in Javascript, Faust and Sporth . There are two main ways of using it: The web editor runs in the browser and provides an instant composition environment. The command line interface can render music to audio files, serve the editor locally, and bundle music code.","title":"Teasynth"},{"location":"community/powered-by-faust/#lich","text":"Technology OWL platform that allows you to use Pure Data, Max Gen or Faust code into your module!. Lich is a Befaco Rebel collaboration that brings back Owl\u2019s platform with this new hardware iteration. It has stereo in and out, four pot controls summed to cv inputs (like the classic Owl module) And as addition, CV and Gate outputs, patch selection with display and USB MIDI host and device connections.","title":"LICH"},{"location":"community/powered-by-faust/#lamb","text":"A lookahead compressor/limiter that's soft as a lamb, written in Faust and Rust. Lamb was made with these goals in mind: Be as clean as possible Give the user full control over the character with the minimum amount of knobs.","title":"lamb"},{"location":"community/powered-by-faust/#faustsynth","text":"Welcome to FaustSynth, a AU/VST monophonic synthesizer built with the Faust programming language. This is the project deliverable for PAT 481: Independent Study in Fall 2023.","title":"FaustSynth"},{"location":"community/powered-by-faust/#envelopforlive","text":"The nonprofit mission of Envelop is to connect and inspire community through immersive listening. Our listening spaces envelop the audience in pristine 3D sound, amplifying the power of music and nurturing our ability to listen together. Some Max/MSP externals are written in Faust .","title":"EnvelopForLive"},{"location":"community/powered-by-faust/#rcverb-reaclassical-verb","text":"A reverb suitable for classical music based on zita-rev1. Available as LV2 and CLAP by default (with optional VST3, VST2 and LADSPA). This plugin is part of the ReaClassical project along with RCComp (\"ReaClassical Compressor\") and Enover (RCVerb's big sister) additionals plugins, also written in Faust.","title":"RCVerb (\"ReaClassical Verb\")"},{"location":"community/powered-by-faust/#wam-studio","text":"Wam-Studio\u2019s is an online tool for creating audio projects that you can imagine as multi-track music. Each track corresponds to a different \"layer\" of audio content that can be recorded, edited, or just integrated (using audio files for example). Some track can be used to control virtual instruments: in that case we record the sound that is generated internally by these virtual instruments (and played using a MIDI piano keyboard, for example). Tracks can be added or removed, played isolated or with other tracks. They can also be \"armed\" for recording, and when the recording starts, all other tracks will play along, while the armed track will record new content. Wam-Studio can host WAM plugins and in particular Faust ones , which can be built following this tutorial .","title":"Wam-Studio"},{"location":"community/powered-by-faust/#snes-echo-simulator","text":"SNES Echo is an cross-platform audio processing plugin, written in Faust. It simulates the SNES SPC700 DSP reverb/echo effect. This plugin does not strive for bit-accuracy and overflow handling, but instead being audibly indistinguishable for \"normal\" SPCs.","title":"SNES Echo Simulator"},{"location":"community/powered-by-faust/#syfala-project","text":"Automatic compilation of Faust audio DSP programs for AMD-Xilinx FPGAs, developed by the Emeraude team , and funded by the FAST ANR project. Supported board models are: Digilent Zybo Z7-10 - Zynq-7000 ARM/FPGA SoC Development Board Digilent Zybo Z7-20 - Zynq-7000 ARM/FPGA SoC Development Board Digilent Genesys ZU-3EG - Zynq UltraScale+ MPSoC Development Board","title":"Syfala project"},{"location":"community/powered-by-faust/#interactive-granular-texture-synthesiser","text":"An interactive granular texture synthesiser built in TouchDesigner, utilising real time signal processing of the domain-specific language Faust (functional audiostream), and the corresponding TD_Faust operator.","title":"Interactive Granular Texture Synthesiser"},{"location":"community/powered-by-faust/#reflex-in","text":"Reflex-in is a sound installation that uses brain-wave streams to create music composition within the Web environment in real time. The work incorporates various state-of-the-art Web technologies, including Web Audio, WebSocket, WebAssembly, and WebGL. The music generated from the algorithm - mapping brain wave signal to musical events - aims to produce a form of furniture music that is relaxing and meditative, possibly therapeutic. The synthesizer part is created from Faust DSP and the installation can be tested here .","title":"Reflex-in"},{"location":"community/powered-by-faust/#faustcgp","text":"Generate new audio synthesizers and filters in FAUST with Recurrent Cartesian Genetic Programming. Given a target sound or impulse response as input, the RCGP will return a FAUST synthesizer or filter, respectively, that best approximates the given signal or impulse response. Samples for an early version of the software can be found here .","title":"FaustCGP"},{"location":"community/powered-by-faust/#onetrick-urchin","text":"A hybrid drum synth that models the gritty lo-fi sound of beats from vintage records without sampling. It takes spectral and physically modeled drums, running them through simulated studio reverb, a vinyl or tape player, and finally a digital sampler. The result is a fat and saturated drum machine that creates a vibe of sampling with the control of a synthesizer. The project is using Rust and the Faust to Rust backend, and the source code is available .","title":"OneTrick URCHIN"},{"location":"community/powered-by-faust/#kbverb","text":"A Faust reverb, based on the Midiverb architecture by Keith Barr .","title":"KBVerb"},{"location":"community/powered-by-faust/#pasfa-paste-faust-code","text":"A paste service for Faust code, to be tested here .","title":"pasfa - Paste Faust code!"},{"location":"community/powered-by-faust/#faustmapper","text":"FAUSTmapper is a tool for binding popular Digital Musical Intrument (DMI) mapping tools to the FAUST ecosystem. The default action for the FAUSTmapper project is establishing a binding to the libmapper project. When the script is run, the entire parameter space of an active FAUST project (with HTTP control enabled) will be discovered. Once discovered, a libmapper signal will be created for each of the parameters identified, including appropriate meta data such as min, max & default values. The following poster was presented at the 4th Annual International Symposium on the Internet of Sounds and was awarded the Best Poster Award.","title":"FAUSTmapper"},{"location":"community/powered-by-faust/#phausto","text":"Pharo is a pure object-oriented programming language and a powerful environment, focused on simplicity and immediate feedback (think IDE and OS rolled into one). Phausto allows to use Faust inside Pharo.","title":"phausto"},{"location":"community/powered-by-faust/#cantor-digitalis","text":"The Cantor Digitalis is a singing voice synthesiser controlled in real time by chironomy, i.e. by manual gesture, using interfaces such as a stylus or the fingers on a graphics tablet. More generally, it can be controlled using any MIDI interface. The synthesiser has been reimplemented in Faust by Gr\u00e9goire Locqueville during his PhD thesis .","title":"Cantor Digitalis"},{"location":"community/powered-by-faust/#karya","text":"Karya is a score language editor with support for scales, instrumental techniques, and ornaments, with special support for Balinese, Javanese, and Carnatic music. It has backends for MIDI, supercollider OSC, lilypond, and an incremental audio renderer that uses Faust or samples. You can write instruments in Faust and integrate them into a score along with samples and MIDI instruments. Due to incremental rendering, even computationally expensive instruments are not a problem.","title":"Karya"},{"location":"community/powered-by-faust/#body-brain-digital-musical-instrument-bbdmi","text":"BBDMI project aims at making music from electrical signals of the muscle and the brain using EMG and EEG technologies. Producing instrumental prototypes in an open way (open software and open hardware) and to document them in the framework of open science (FAIR). The modular system is built with Max/MSP and interfaced with Faust for the purpose of analyzing, processing and mapping electrophysiological signals to sound. The paper An Interactive Modular System for Electrophysiological DMIs received a best paper award at Audio mostly 2023 .","title":"Body Brain Digital Musical Instrument (BBDMI)"},{"location":"community/powered-by-faust/#the-spatbox","text":"The Spatbox is an interface to intuitively generate 3D trajectories and to spatialize them in real-time on a loudspeaker array with Ambisonics, developed by Pierre Lecomte . Each trajectory is described by a parametric curve, where each of the coordinates varies according to a configurable LFO. Depending on the LFO parameters, many trajectories can be generated. The implementation is done in Faust and the project has been presented at PAW 2022 .","title":"The Spatbox"},{"location":"community/powered-by-faust/#muss3640-vocal-synthesiser","text":"The MUSS3640 Vocal Synthesiser is a standalone application/VST3 plugin developed to allow exploratory synthesis of the singing voice. It implements a combination of formant-wave-function and bandpass synthesis techniques. The DSP is written in Faust.","title":"MUSS3640 Vocal Synthesiser"},{"location":"community/powered-by-faust/#riti-room-is-the-instrument","text":"RITI: Room Is The Instrument by Luca Spanedda , is a piece based on a complex system capable of manifesting emergent and chaotic behaviors, where the acoustic personality of an environment (digital or physical) becomes a case of study for the performance and is reflected in terms of variation in the behavior of the system itself. The DSP code is written in Faust. See a video of a \"studio\" performance of the system .","title":"RITI: Room Is The Instrument"},{"location":"community/powered-by-faust/#equis","text":"EQUIS is a 4 Channel DJ Mixer built on top of JACK. It's EQ is inspired by the Playdifferently Model1 and offers per channel a highpass, lowpass and sculpt eq. The code is developed in Rust and the DSP is written in Faust . See the video presentation at Sonoj convention .","title":"EQUIS"},{"location":"community/powered-by-faust/#esp32-wrover-eie-audio-dev-board","text":"A board to play with FAUST sound synthesis language.","title":"ESP32 Wrover E/IE audio dev board"},{"location":"community/powered-by-faust/#kuroscillators","text":"Max/MSP objects for audio and rhythmic synthesis using coupled oscillator networks. Coupled Oscillators networks are dynamical systems that describe how ensembles of interacting elements are able to self-organize and synchronize over time. In terms of sensory perception, they have been examined in a wide range of fields including those related to rhythmic entrainment, biomusicology, psychoacoustics, signal processing, and generative music. The DSP is written in Faust .","title":"Kuroscillators"},{"location":"community/powered-by-faust/#joue-music-instruments","text":"A new way to make music: the Jou\u00e9 Play is a system that combines an expressive multi-instrument, an intuitive app & interactive content, with a range of musical instruments that use touch-sensitive technology to create a unique playing experience. These instruments are designed to be highly expressive, allowing musicians to play with greater nuance and emotion. Part of the audio effects are coded in Faust.","title":"Jou\u00e9 Music Instruments"},{"location":"community/powered-by-faust/#externalchugins","text":"Chugins , short for \"ChucK plugins,\" are plugins for the ChucK programming language . ChucK is an audio programming language that allows for real-time synthesis, composition, and performance of music. Chugins extend the functionality of ChucK by providing additional classes, objects, and modules that can be used to create more complex and intricate music and sound designs. ExternalChugins are a set of chugins exported from Faust.","title":"ExternalChugins"},{"location":"community/powered-by-faust/#mesh2audio","text":"Generate axisymmetric 3D models, or import existing 3D models, and transform them into real-time playable physical audio models! Supports fast DSP generation of physical audio models that sound decently realistic, as well as blazing fast 2D axisymmetric model generation, at the expense of some fidelity. It is an improvement of the mesh2faust tool. The generated audio model can be played in real-time by \"striking\" (clicking) on mesh vertices in the 3D mesh viewer.","title":"mesh2audio"},{"location":"community/powered-by-faust/#onetrick-cryptid","text":"Whispers of a dreaded drum machine with the cold clanging heart of a DX7 in the fearsome frame of a TR-808 echo in dusty backrooms of backstreet recording studios. A contraption conjured under cover of darkness in the heinous pursuit of chart topping tracks, known only as the DX-808. It's time to bring the beast out of the shadows! Allow us to present the world's most accurate recreation of an FM drum synth skeptics say never actually existed. Using a DX7 emulator of our own design, we forged each facet of the CRYPTID, reconstructing its wretched inner-workings. From the \"Log Drum\" Toms to the \"Wood Block\" Cowbell. Blow that Samba Whistle and hit the Gong! Do you want to believe? The project is using Rust and the Faust to Rust backend, and the source code is available .","title":"OneTrick CRYPTID"},{"location":"community/powered-by-faust/#bespoke-anywhere","text":"This paper reports on the Audio Anywhere project, a framework for working with audio plugins that are compiled once and run anywhere. At the heart of Audio Anywhere is an audio engine whose Digital Signal Processing components are written in Faust and deployed with WebAssembly, by Benedict Gaster and Ryan Challinor, presented at Nime 2021 .","title":"Bespoke Anywhere"},{"location":"community/powered-by-faust/#a-technical-framework-for-musical-biofeedback-in-stroke-rehabilitation","text":"We here present work a generalized low-level technical framework aimed to provide musical biofeedback in post-stroke balance and gait rehabilitation, built by an iterative user-centered process. The framework comprises wireless wearable inertial sensors and a software interface developed using inexpensive and open-source tools. The interface enables layered and adjustable music synthesis, real-time control over biofeedback parameters in several training modes, and extensive supplementary functionality. JUCE and FAUST are used to create a versatile architecture for layered, yet computationally efficient real-time music synthesis.","title":"A Technical Framework for Musical Biofeedback in Stroke Rehabilitation"},{"location":"community/powered-by-faust/#forcehost","text":"ForceHost: an open-source toolchain for generating firmware embedding the authoring and rendering of audio and force-feedback haptics, by Christian Frisson, Mathias Kirkegaard, Thomas Pietrzak, and Marcelo M. Wanderley presented at Nime 2022 . The Faust compiler has been modified to support haptics.","title":"ForceHost"},{"location":"community/powered-by-faust/#sentinelle","text":"Sentinelle is a sound and robotic art installation made by J\u00e9r\u00f4me Abel . A robot-probe is placed in a dark place, a cellar. It scans its surroundings with two lasers. The reliefs of the old walls, their imperfections, mold, appear thanks to the perfectly straight lines of the lasers. Its movements are synchronized with a sound program. From these very simple visual and sound choreographies are born an imaginary on its functioning and the origin of its presence. The spectator observes in a mirror a robot which observes and testifies. Does it communicate with other systems? Does it send information? Its energy is precious, like a heartbeat or a breath, it works in a segmented way with periods of silence. Likewise, his movements are slow and relentless. Faust objects from https://github.com/grame-cncm/faust/tree/master-dev/examples included with pd-faustgen : examples/gameaudio/bubble examples/delayEcho/echo examples/gameaudio/rain examples/generator/sawtoothLab","title":"Sentinelle"},{"location":"community/powered-by-faust/#langfaust-and-uifaust","text":"CEAMMC PureData distribution 2023.02. General purpose Pd distribution and library used for work and education purposes in Centre of electroacoustic music of Moscow Conservatory ( CEAMMC ) and ZIL-electro studio. This repository is an assembly of Puredata that includes the CEAMMC library. It includes the lang.faust~ and ui.faust~ externals and a lot of Faust DSP .","title":"lang.faust~ and ui.faust~"},{"location":"community/powered-by-faust/#arco4-sound-synthesis-engine-and-framework","text":"Arco is a sound synthesis engine that offers dynamic patching of of unit generators. It is designed to operate as a small embedded server, running either in its own process or within an application. In the spirit of \"smaller is better,\" Arco DSP is mainly delegated to FAUST , leveraging a wide range of existing algorithms. Arco control is delegated to external languages connecting through O2, which supports running Arco within the same application, in a separate process or even on a remote networked host. Arco should be a nice alternative to libpd as an embedded sound engine. The author is mainly using Arco in tandem with Serpent, a real-time Python-like scripting language, but other language bindings are possible.","title":"arco4 - sound synthesis engine and framework"},{"location":"community/powered-by-faust/#synthesizer-synthesizer","text":"This is a dual-course project for CS378 NLP and CS393P. The goal is to use language model guided program synthesis to synthesize Faust DSP code to ... automatically program synthesizers. Not guaranteed to work. In the slightest.","title":"Synthesizer-synthesizer"},{"location":"community/powered-by-faust/#ambisonics-in-kmh-studios-and-lilla-salen","text":"The general idea behind using ambisonics for diffusing sounds in a space is to, in the first stage, encode an audio signal to a representation of a sound field - a B-format signal. This B-format signal is independent of whatever speaker array the signal will later be diffused on. In the second stage the B-format signal is decoded to the layout of a particular speaker array. In between these two stages a number of transformations may be applied, but the sound source specification may conveniently be specified in the encoder. The decoders are written in Faust.","title":"Ambisonics in KMH studios and Lilla salen"},{"location":"community/powered-by-faust/#sardine","text":"Sardine is a free/open-source software for Python 3.10+. It turns Python into a musical instrument. You can play it alone or with your friends. With Sardine you can: Play synthesizers and audio samples using SuperCollider. Control synthesizers through MIDI/OSC messages. Interconnect audio/video softwares and/or sound engines. Play collaboratively with your friends. Extend your musical environment using any Python package. Faust written DSP can be used in Sardine.","title":"Sardine"},{"location":"community/powered-by-faust/#kandiskyscore","text":"KandiskyScore is a graphical editor for the analysis and creation of electroacoustic/acousmatic music. It is an html/javascript application. It works perfectly with Firefox, Chrome and Opera and therefore on all Windows, OSX, Linux and other PCs. It uses the WebAudio API for sound generation and the Faust language of the GRAME for plugins. It also allows you to export a graphic score in SVG format that you can eventually modify with a vector graphics software like Inkscape or LibreOffice-draw.","title":"KandiskyScore"},{"location":"community/powered-by-faust/#fildesoi1_2_3","text":"Software (including Faust code , Max and PureData patches) to perform Fil de Soi 1 and Fil de Soi 2, mixed music pieces by Alain Bonardi for acoustic guitar and electronics.","title":"fildesoi1_2_3"},{"location":"community/powered-by-faust/#enecho","text":"Faust code for En Echo piece by Manoury for soprano and live electronics.","title":"enecho"},{"location":"community/powered-by-faust/#zen-flute","text":"The Guthman Musical Instrument Competition is one of the only competitions of its kind - an event dedicated to identifying the newest and greatest ideas in music. Every year, we invite musical inventors from around the world to share their creations and ideas about the future of music. This year first price is Keith Bexter with the Zen Flute , which sound is produced by a physical model of flute written in Faust , and running on a Teensy audio board .","title":"Zen Flute"},{"location":"community/powered-by-faust/#souffle","text":"An electro track made with Faust . You can listen to a recording here .","title":"souffle"},{"location":"community/powered-by-faust/#ghg-gruppenhorchgerat","text":"The project is a demonstration of a technique called delay-sum beamforming with the aim to replicate the sound heard by operators of passive sonar devices used in the second world war. Listen to the video here . The simulation code is written in Faust.","title":"GHG (Gruppenhorchger\u00e4t)"},{"location":"community/powered-by-faust/#satuverb","text":"Satuverb is a flexible reverb that has many creative and natural sounding uses, produced by request for FBPM. It has a saturator and EQ controls inside the reverberator, which apply every time the signal is fed back. This causes the effects to grow more extreme as the reverb tail trails off. Satuverb's reverberator is based on Jon Dattorro's 1997 design and written in Faust .","title":"Satuverb"},{"location":"community/powered-by-faust/#faustilogue","text":"Convert Faust DSP files to KORG logue custom oscillators, using the logue SDK .","title":"faustilogue"},{"location":"community/powered-by-faust/#blippoo-for-wingie","text":"Blippoo for Wingie is an alternative firmware for Wingie2. The new firmware is inspired by Blippoo Box, a genius instrument created by Rob Hordijk (1958-2022), who contributed a lot to synthesizer design. May his spirit lives on in his instrument designs, thoughts, and influences. The new firmware could turn your Wingie2 into a self-contained instrument capable of producing a variety of sounds and patterns. As a great companion, it will help you in your music-making practice especially when you want to applicate controlled chaos in your music. The DSP is written in Faust .","title":"Blippoo for Wingie"},{"location":"community/powered-by-faust/#6171_reverb","text":"A vintage reverb based on designs from 1961 and 1971, written in Faust .","title":"6171_reverb"},{"location":"community/powered-by-faust/#teensy-wfs","text":"Distributed Wave Field Synthesis (WFS) implementation for networked Teensies. There is a WFS Controller JUCE app in wfs-controller. This uses JACK's C API to set up ports and connect to any Teensy JackTrip clients. It notifies the clients of their positions in the WFS array, plus the positions of virtual sound sources, via OSC over UDP multicast. The WFS algorithm is written in Faust .","title":"teensy-wfs"},{"location":"community/powered-by-faust/#pd-remote","text":"This is a simplified and unified version of the Pd remote control helpers that I've been distributing with various Pd externals such as pd-faust and pd-lua over the years. The present implementation will work with any of these and replaces the more specialized versions. It takes the form of a Pd abstraction pd-remote.pd and an accompanying pd-remote.el elisp file for Emacs.","title":"pd-remote"},{"location":"community/powered-by-faust/#crossroad2effects","text":"Crossroad2Effects, the functional successor to @jatinchowdhury's CrossroadsEffects , is a genetic algorithm infrastructure for filter exploration. Provided with dry and wet sound file, Crossroad2Effect determines the filter that tampered the dry file and presents it as a Faust program. This allows users to have granular access to analog or VST filters through a programming interface. This project constructs its genetic algorithm search on top of pedalboard, Spotify's new plugin API.","title":"Crossroad2Effects"},{"location":"community/powered-by-faust/#flatten","text":"What is an envelope flattener ? It's similar to an automatic gain control, compressor, or maximizer in that it acts by modifying the gain of the signal according to a control signal. Like these, the control signal is derived from the envelope of the input signal. The DSP is written in Faust .","title":"flatten"},{"location":"community/powered-by-faust/#drumvoice","text":"Drumvoice is a percussion instrument LV2 plugin. Drumvoice can also make lots of other percussion sounds, like kick drums, toms, single hand claps, and all kinds of smaps and blinks. The DSP is written in Faust .","title":"drumvoice"},{"location":"community/powered-by-faust/#verber","text":"Verber is a simple audio plugin tool with a Sweet, Lushy reverb processor. It is a portolio project built in JUCE and HISE, with the DSP in Faust .","title":"Verber"},{"location":"community/powered-by-faust/#reach","text":"Extraterrestrial Reverb for Electronic Music. REACH is modern creative Reverb that is made for synthetic sound sources. There are four effects included to transform the Signal. It features modular routing, pre and post filters and over 40 Presets. Part of the DSP code is written in Faust .","title":"REACH"},{"location":"community/powered-by-faust/#stray_virtual-synth","text":"A typical wavetable synthesizer will have a table of predetermined amplitude values which are read through at the appropriate speed relative to the frequency of the current note, resulting in an audible signal. Stray functions similarly, reading through a table of values, but the amplitude values are not predefined. Instead, these values are modulated with one of four LFO shapes. The DSP code is written in Faust.","title":"Stray_virtual-synth"},{"location":"community/powered-by-faust/#drty-drums","text":"A 4 voices drum machine based on FM synthesis [WIP]. The sound engine is made in Faust .","title":"Drty Drums"},{"location":"community/powered-by-faust/#201-musical-synthesizer","text":"We\u2019re Critter & Guitari and we\u2019re happy to announce our newest synthesizer: the 201! If you\u2019re familiar with our other musical instruments such as the Pocket Piano, Organelle, Bolsa Bass, or Kaleidoloop, we hope you\u2019ll see that the 201 fits right in with them: the 201 is fun, portable, and packed with a medley of musical magic! Inside, the 201 uses a combination of Pure Data and Faust musical programming environments. Users are invited to modify or create new sound engines!","title":"201 Musical Synthesizer"},{"location":"community/powered-by-faust/#onetrick-simian","text":"Crash into the 80s with an open source drum synth inspired by hexagonal classics like the Simmons SDS-V . Thumping kicks , punchy snares , and sizzling cymbals coalesce with its clacky claves and crunchy claps . Bring saccharine synthwave sauce to your sublime soundscapes or drop indelable pewww pewww tom toms into your new nu-disco . Get the source code containing Faust DSP , using the Dlang backend.","title":"OneTrick SIMIAN"},{"location":"community/powered-by-faust/#collisiondrivelv2","text":"CollisionDrive is modeled after the Horizon Devices Precision Drive, a modern overdrive pedal with a built-in noise gate, with DSP written in Faust .","title":"CollisionDrive.lv2"},{"location":"community/powered-by-faust/#metaltonelv2","text":"Distortion Pedal simulation. MetalTone is modeled after the renowned BOSS MT-2 Metal Zone, a high gain distortion pedal with an advanced EQ section, with DSP written in Faust .","title":"MetalTone.lv2"},{"location":"community/powered-by-faust/#tamgamplv2","text":"Tamgamp (Rhymes with: \"Damage Amp\") is a LV2 guitar amp simulator that provides two plugins, with DSP code developed with Faust : Tamgamp - a plugin based on Guitarix DK Builder simulated chains. TamgampGX - a plugin based on tuned Guitarix internal amplifiers implementation.","title":"tamgamp.lv2"},{"location":"community/powered-by-faust/#reverbzen","text":"A Reverb written with Faust and JUCE, based on SchroederReverberators . This reverb effect uses different stages. It splits input signal in parallel and uses different types of delaylines. Different filters are provided to get rid of unwanted resonances. Check out reverb.dsp file to get more detailed insight.","title":"ReverbZen"},{"location":"community/powered-by-faust/#wingie2","text":"Wingie2 is a handheld stereo resonator that you can use as a development platform, and can be programmed with Faust .","title":"Wingie2"},{"location":"community/powered-by-faust/#slowmolv2","text":"A multiband slow gate with delay/echo. The C++ files for the effect are generated from Faust DSP files: Bandsplit.cc , Delay.cc and Volume.cc .","title":"Slowmo.lv2"},{"location":"community/powered-by-faust/#vocoder-app","text":"Vocoder mobile app for Android made with Faust and its Smartkeyboard interface. This app was developed in the context of a project for the the Real Time Interaction and Performance exam (Sound and Music Computing MSc, Aalborg University, Copenhagen, 2020). The paper A Faust-built Mobile Vocoder Instrument, included in the repo, provides more information on the algorithm, as well as the description of a case prototype.","title":"Vocoder App"},{"location":"community/powered-by-faust/#echoplex-ep-3-simulator","text":"This archive contains a virtual model of the Echoplex Ep-3 tape delay. The effect has been developed using Faust in the context of a project for the Sound Processing exam (Sound and Music Computing MSc, Aalborg University, Copenhagen, 2019). The paper Faust Model of the Echoplex Tape Delay, included in the repo, provides more information on the algorithm.","title":"Echoplex Ep-3 Simulator"},{"location":"community/powered-by-faust/#faust2smartphone","text":"faust2smartphone is a tool to generate interactive musical mobile application embedded Faust API.","title":"faust2smartphone"},{"location":"community/powered-by-faust/#dpf-fadeli","text":"An experiment with Faust Demo Library content as DPF plugins. Basically glueing a few different projects together, to compile Faust DSP programs in several plugins format: LADSPA, LV2, VST2, VST3, CLAP : DPF faust faustpp faust examples","title":"DPF-Fadeli"},{"location":"community/powered-by-faust/#tr8ck","text":"TR8CK is an experimental DAW/tracker with Faust live coding via faust2webaudio and UI powered by SolidJS .","title":"TR8CK"},{"location":"community/powered-by-faust/#guitard","text":"It's a basic multi effects processor which follows a node based approach. Components are developed with Faust .","title":"GuitarD"},{"location":"community/powered-by-faust/#hise","text":"HISE is an open source framework for building sample based virtual instruments combining a highly performant Disk-Streaming Engine, a flexible DSP-Audio Module system and a handy Interface Designer. The implementation of the Faust integration was the result of a Google Summer of Code project done by Roman Sommer with the help of Christoph Hart as mentor.","title":"HISE"},{"location":"community/powered-by-faust/#mbstereophony","text":"This is a simple implementation of a Regalia-Mitra filter bank using 3rd order Cauer low-pass filters as the base designs. There are four filter bank programs available which are described below. MBStereophony itself is a demo effect that down-mixes a stereo signal separately per frequency band.","title":"MBStereophony"},{"location":"community/powered-by-faust/#audiolab","text":"A docker based DSP learning/Experimentation environment including: Jupyter lab FAUST python 3.7 (at the moment. Depends on miniconda3 docker image) FAUSTpy to run FAUST code inside jupyter faustWidgets (to interactively control FAUST code ) librosa (for MIR and feature extraction) scipy, pandas, numpy for general data science sox (encoding, batch processing etc) ffmpeg (encoding batch processing etc) seaborn (more beautiful plots) latex TODO (for exporting jupyter notebooks)","title":"Audiolab"},{"location":"community/powered-by-faust/#lr_delay","text":"A stereo delay plugin which emphasizes free (non beat-synced) controls for the individual channels. Built with Faust and JUCE.","title":"LR_Delay"},{"location":"community/powered-by-faust/#leslie-speaker-simulator","text":"This archive presents a virtual simulation of the Leslie Speaker commonly found in Hammond electric organs. The digital effect has been developed using the FAUST programming language, and then ported into a VST-compatible format using the JUCE C++ framework.","title":"Leslie speaker simulator"},{"location":"community/powered-by-faust/#cookiecutter-dpf-faust","text":"A cookiecutter project template for DISTRHO Plugin Framework ( DPF ) audio effect plugins using FAUST for the implementation of the DSP pipeline. Look at the demo video .","title":"cookiecutter-dpf-faust"},{"location":"community/powered-by-faust/#df-zita-rev1","text":"A feedback-delay-network reverb plugin built with DPF and based on a FAUST library demo. Several other projects are developed using the same DPF/FAUST methothodolgy: FAUST filters , a collection of virtual-analog filters from the FAUST standard library packaged as multi-format plugins via the DPF SendMixer , a stereo channel strip plugin with one master gain and two pre/post-fader sends Stereo Cross Delay , a stereo delay plugin with feedback and cross-mixing.","title":"DF Zita Rev1"},{"location":"community/powered-by-faust/#theremotion","text":"Theremotion is a virtual instrument inspired by the Theremin. Just like a Theremin, the position of your hand in the air controls the pitch and volume of the sound. However, you can also control much more dimensions of the sound with specific motions. With specific hand positions, you can control a low pass filter, a supersaw sound, a guitar sound and more. You can even make the instrument \"stick\" to a scale, making it much easier to control than a Theremin. The hand tracking is provided by Ultraleap's Leap Motion Controller . The sound generation is created with Grame's Faust . The program is built with Rust .","title":"Theremotion"},{"location":"community/powered-by-faust/#hypercurve","text":"Hypercurve is a library allowing you to combine several curve algorithms into a single 2D envelope. It is designed to be used in audio applications, for people who know how to enjoy a finely shaped curve. As shown above, you can perfectly combine gaussian curve with diocles cissoid curve, and plenty of other curve algorithms. The library can be used in C++, Lua, Csound and Faust .","title":"Hypercurve"},{"location":"community/powered-by-faust/#faust-mcp","text":"This package provides a Pd abstraction mcp.pd (along with some helper abstractions and externals) which lets you control your Faust instruments and effects more conveniently with control surfaces utilizing the Mackie Control Protocol (MCP).","title":"faust-mcp"},{"location":"community/powered-by-faust/#faustquark","text":"This SuperCollider package makes it possible to create SuperCollider packages (Quarks) containing plugins written in Faust code. With this, you can distribute plugins written in Faust and make it easy for others to install, compile or uninstall them. It also contains some simple interfaces for the faust and faust2sc.py commands used behind the scenes.","title":"Faust.quark"},{"location":"community/powered-by-faust/#komet","text":"Komet is a computer music / sound system by Mads Kjeldgaard written in SuperCollider and Faust . Komet is a computer music system that makes advanced synthesis operations and composition easier. It auto generates thousands of synthesizer variations from simple recipes and offers a range of DAW-like features such as effect chains (like on channel strips) and other conveniences. It can work natively in stereo, multichannel or high order ambisonics mode with the flick of a switch, allowing the same compositions to be used in different sound systems.","title":"Komet"},{"location":"community/powered-by-faust/#faug","text":"A Minimoog Model D emulation with the DSP portion written in Faust and using JUCE framework. Moog + Faust = Faug.","title":"Faug"},{"location":"community/powered-by-faust/#striso-studio","text":"A virtual Web version of the Striso board, using the Faust WebAssembly compiled sythesizer code .","title":"Striso Studio"},{"location":"community/powered-by-faust/#xuidesigner","text":"A WYSIWYG LV2 X11UI GUI creator tool. Provide a easy to use GUI generator tool to create X11 UI's for LV2 plugins. Currently only libxputty is supported, but the generated GUI C file could be used probably with other widget tool-kits as well, just a wrapper file is needed to translate the generated file to the needs of a toolkit. XUiDesigner could now parse faust (.dsp) files and generate a full LV2 Bundle for them. A faust (.dsp) file could be given by the command-line parameter -f or simply by drag it on the Designer window. It will create all control widgets which you could then rework to your needs before you save your Bundle.","title":"XUiDesigner"},{"location":"community/powered-by-faust/#eurorack-blocks","text":"The eurorack-blocks project allows to develop your own custom Eurorack module for either prototyping or fun in the comfort of your day-to-day IDE with the C++ or Faust language , or using the Cycling '74 Max environment, testing and debugging in a virtual Eurorack environment, and when ready, to auto-magically generate all the needed files to manufacture the eurorack module for you to use in a real Eurorack modular system.","title":"eurorack-blocks"},{"location":"community/powered-by-faust/#amstramgrame","text":"An arts and sciences educational project (STEAM), bringing together services and resources for the educational community. It aims at making abstract scientific concepts more tangible and concrete through musical creation and computer programming. The Gramophone is an audio device/musical instrument specifically designed for the AmStramGrame project. Its various sensors and controllers (e.g., accelerometer, gyroscope, light sensor, etc.) make it react to the user's gestures. Its rechargeable battery offering approximately five hours of autonomy and its powerful speaker make it independent from any computer, bringing it closer to traditional acoustic musical instruments. DSP programs are coded in Faust . Additional examples can be found in GramoCollection .","title":"AmStramGrame"},{"location":"community/powered-by-faust/#gamelan","text":"GameLAN is a set of musical applications designed by Grame , National Center of Musical Creation. They are based on Faust technology and have been designed to be played using only the movements of the smartphone. No musical prerequisite, only your gestures will make you a musician!","title":"GameLAN"},{"location":"community/powered-by-faust/#screamer","text":"Version 1.0 is the accurate Faust reproduction of a VST plug-in written in 2003. In later versions, the parameter ranges is modified and some new functionality are added. This signal mangler features a weird kind of overdrive (see source code for exact formula), a hard-clip distortion, LFO-modulated bit reduction and the possibility of calculating the modulo of a signal.","title":"Screamer"},{"location":"community/powered-by-faust/#typebeat","text":"Typebeat is a virtual groovebox that\u2019s entirely keyboard-operated. Typebeat draws inspiration from two computing environments. Effects are developped in Faust then generated as Rust modules .","title":"Typebeat"},{"location":"community/powered-by-faust/#afdn-reverb","text":"(High-Order) Ambisonics Feedback Delay Network Reverb. Code is developed in Faust and Max.","title":"AFDN-reverb"},{"location":"community/powered-by-faust/#karpsichord","text":"A virtual harpsichord based on Karplus-Strong string synthesis, implemented in Faust and running in the Web .","title":"Karpsichord"},{"location":"community/powered-by-faust/#arduino-audio-tools","text":"Some basic header-only C++ classes that can be used for Audio Processing provided as Arduino Library. A simple Interface class to use Faust with Arduino Audio Tools is provided . Code can be written using Faust .","title":"Arduino Audio Tools"},{"location":"community/powered-by-faust/#organelle","text":"The Organelle makes it easy to explore new sounds and experiment with new ways of making music. It combines playful and intuitive controls with a powerful and flexible sound engine. The result is an instrument that is limitless in musical possibility and a joy to play. At the heart of the Organelle's sound engine is a robust computer that runs patches. A patch allows the instrument to take on different forms. Onboard hardware for sound input and output and mappable knobs, keys and buttons enable patches to synthesize, sample, effect, and anything in between! The Organelle can be programed with Faust as explained here and with this PD external using Faust .","title":"Organelle"},{"location":"community/powered-by-faust/#zrythm","text":"Zrythm is a digital audio workstation designed to be featureful and easy to use. It offers streamlined editing workflows with flexible tools, limitless automation capabilities, powerful mixing features, chord assistance and support for various plugin and file formats. A set of Faust effects are compiled as LV2 plugins and included in the application.","title":"Zrythm"},{"location":"community/powered-by-faust/#patches-for-the-owl-pedaleurorack-module","text":"This is a collection of patches written or ported specifically for the OWL. Most of them were written using Faust and if you want to modify them you'll need to have a working FAUST installation. C++ source code (the .hpp files) for the OWL can be generated by running the \"updateFaustPatches.py\" python script. Then you will need to rebuild the OWL firmware and upload it to the device.","title":"Patches for the OWL Pedal/Eurorack Module"},{"location":"community/powered-by-faust/#kiwi","text":"Kiwi is a graphical programming environment dedicated to music and sound creation, such as Max or Pure Data softwares, but offering a real-time collaborative approach: Kiwi allows several distant users to work simultaneously on the same patch hosted online. Kiwi is part of the French ANR-funded MUSICOLL project that unites the CICM and OhmForce. The main goal of this project is to study how collaboration can enhance the way digital audio music composition is taught and more generally how it can renew music creation practices and improve its workflow. Faust DSP programs can be dynamically compiled as objects included in the patch. An extended presentation of the system can be found in this IFC 2020 paper .","title":"Kiwi"},{"location":"community/powered-by-faust/#brainwave-virtual-instrument","text":"The Brainwave Virtual Instrument (BVI) is an open-source software synthesizer built in the programming language Faust. Its purpose is to facilitate the exploration of electroencephalogram (EEG) and other brain data through sonification. Pre-recorded data is translated as parameter controls of the instrument in the form of Open Source Control (OSC) messages that are generated and streamed by a small python program. The instrument can easily be distributed and compiled to different targets thanks to Faust\u2019s flexibility. Frequency Modulation synthesis provides a comprehensive approach to textural parameters of sounds, so that musical composition and improvisation based on a creative use of brain data become feasible. This is exemplified by the Brainwave Etudes (BE), a series of compositions inspired by measurements of brain activity during different states of mind. The BVI was created for two major purposes: on the one hand, to find musical structures that relate to each other in order to present an aesthetic proposal, and on the other, to create a tool that familiarizes scientists and researchers in the field of neuroscience with sonification techniques, and the exploration of brain activity through sound. An extended presentation of the system can be found in this IFC 2020 paper .","title":"Brainwave Virtual Instrument"},{"location":"community/powered-by-faust/#mephisto","text":"Mephisto is a transpiler for converting sound patches designed using the graphical computer music environment Pure Data to the functional DSP programming language Faust. Faust itself compiles into highly-optimized C++ code. The aim of the transpiler is to enable creating highly optimized C++ code embeddable in games or other interactive media for sound designers, musicians and sound engineers.","title":"Mephisto"},{"location":"community/powered-by-faust/#weather_organ","text":"Weather Organ is a Faust instrument for manipulating sparse noise to imitate slowly-changing natural sound sources such as rain, wind, surf, fire, Geiger counters and volcanic activity, and to create interesting new textures of sound. It is the product of various discoveries made while using Faust to explore the definition, synthesis and experience of acoustic noise while, simultaneously using the exploration of noise as as focus for learning Faust.","title":"weather_organ"},{"location":"community/powered-by-faust/#genius-eurorack-module","text":"The Genius is the next evolutionary step for the OWL platform, and the first product released based on a Cortex M7 microcontroller. It runs the OWL firmware and so can be programmed with Faust. A demo running bells from thee physical library can be listened to here .","title":"Genius Eurorack Module"},{"location":"community/powered-by-faust/#dataflow-based-fpga-program-synthesis","text":"A Yale-NUS BSc. (Hons) in Mathematical, Computational, and Statistical Sciences Capstone: an FPGA Program Generator written in Python that takes dsp-sig XML Dataflow Graphs created using Faust to produce FPGA programs in VHDL.","title":"Dataflow Based FPGA Program Synthesis"},{"location":"community/powered-by-faust/#dspedal","text":"DSPedal is a custom hardware platform for real-time sound effects. It is operated by few knobs, external expression pedal, couple of buttons and a small graphical LCD. Processing effect is written in Faust programming language and compiled into C code. So far the Cortex M4 core clocked at 204 MHz has proven to be capable of executing relatively complex effects like wah, but effect-chaining quickly reaches the limits of processing power.","title":"DSPedal"},{"location":"community/powered-by-faust/#tambura","text":"Waveguide physical model of an Indian Tambura/Tanpura. This is a Faust patch inspired by the Indian Tambura/Tanpura - a four string drone instrument, known for its unique rich harmonic timbre. The model uses a few tricks to produce a Tambura-like sound, and should probably be referred to as a \"pseudo\" physical model, because it does not attempt to accurately recreate the physics of the string-bridge interaction. It includes a range of parameters selected to allow control of the qualities of the excitation/pluck, string behavior and sympathetic resonance. It can produce some beautiful evolving drones, which can vary from very synthetic to quite natural. The model can be tested here .","title":"Tambura"},{"location":"community/powered-by-faust/#drumbox","text":"drumbox is a fun and powerful drum synthesizer for your Android device. Start from a preset and tweak the sounds and appearance to make it your own. Freestyle on the drum pads, record a sequence or both...it's up to you!","title":"drumbox"},{"location":"community/powered-by-faust/#granola","text":"Granola is a monophonic granular live feed processor. The grain processor is inspired by the Mutable Instruments Beads. The grain window shape control is inspired by the GR-1 Granular synthesizer from Tasty Chips Electronics. The DSP code is written in Faust.","title":"Granola"},{"location":"community/powered-by-faust/#fverb","text":"A stereo variant of the reverberator by Jon Dattorro coded in Faust.","title":"fverb"},{"location":"community/powered-by-faust/#sonification","text":"This study has been developed as a proof-of-concept for data pattern sonification. We've implemented data pattern sonification using FM synthesis coded in Faust. Air pollution data, which is temporal, is retrieved from the server and is done pattern mining. Then pattern data sonification is done.","title":"Sonification"},{"location":"community/powered-by-faust/#gula-plugins","text":"A collection of guitar effect LV2 plugins ( The Vibey , The Splits , The Fades , SSaP Tone , Sweabed , Pequed , Peak audio to CV , LFO CV ) with MOD Devices user interfaces.","title":"GULA Plugins"},{"location":"community/powered-by-faust/#limiterstereo","text":"Yet another look-ahead limiter code in Faust. The novel aspect of this limiter is that it uses N cascaded one-pole filters for amplitude profiling, which improves smoothness in the first to N-1 order derivatives and reduces total harmonic distortion. This design uses four cascaded one-pole lowpass filters, following the cut-off correction formula (8.9) found in [Zavalishin 2012].","title":"limiterStereo"},{"location":"community/powered-by-faust/#web-audio-modules","text":"Web Audio Modules are an open source framework facilitating the development of high-performance Web Audio plugins (instruments, realtime audio effects and MIDI processors). They can be developed using JavaScript and Web standards or compiled from C, C++ code, and domain-specific languages such as Faust or Csound. The Faust Web IDE contains an integrated GUI builder, read a tutorial here .","title":"Web Audio Modules"},{"location":"community/powered-by-faust/#kapitonov-plugins-pack","text":"Set of 7 plugins for guitar sound processing, compiled in LADSPA and LV2 formats. Compatible with hosts such as Ardour, Qtractor, Carla, guitarix, jack-rack. The DSP of all of them is written in Faust.","title":"Kapitonov Plugins Pack"},{"location":"community/powered-by-faust/#tubeamp-designer","text":"Standalone software guitar processor, editor of *.tapf profile files for tubeAmp (KPP) and guitar amp profiler.","title":"tubeAmp Designer"},{"location":"community/powered-by-faust/#biosignals","text":"BioSignals is a data aquisition and processing device for EMG, ECG and EEG signals. Since it is using the OpenWare firmware, it can be programmed with Faust.","title":"BioSignals"},{"location":"community/powered-by-faust/#scale-it","text":"Scale it is an open source program (written in graphical programming language Pure data and in Faust) that allows sonification of a signal distribution in real time. There are two different possibilities of sonification of the signal. One of the objects, tone, generates changes in pitch of a monophonic tone. The other object, chord, expresses the input value in width of polyphony. Scale it is being developed primarily for neurofeedback purposes. To allow straightforward and customizable instruments to carry sonic feedback about EEG activity in specific regions of the neocortex.","title":"Scale it"},{"location":"community/powered-by-faust/#jacktrip","text":"JackTrip is a Linux, macOS, or Windows multi-machine audio system used for network music performance over the Internet. It supports any number of channels (as many as the computer/network can handle) of bidirectional, high quality, uncompressed audio signal streaming. Several DSP effects ( compressor , freeverb , zitarev , limiter ) are written in Faust, compiled as C++ code, and included in project sources .","title":"JackTrip"},{"location":"community/powered-by-faust/#level-rider","text":"This is an audio plugin written in Faust that automates gain level adjustments, based on a target gain level, a time window over which overall loudness is calculated via RMS, and a maximum adjustment threshold. This plugin is comparable to Waves Vocal Rider or Waves Bass Rider in its functionality, but is free and open-source.","title":"Level Rider"},{"location":"community/powered-by-faust/#whetstone-transient-shaper","text":"A free, open source transient shaping audio plugin that operates on a specified frequency band. Whetstone will extract a certain frequency band based on a low cutoff and high cutoff that you choose, apply transient shaping to it, and then reintegrate the shaped band back into the original signal. This plugin is meant to be comparable to the excellent Spiff plugin in its core functionality, but lacks many of the nice features and polished UI. The DSP is coded in Faust .","title":"Whetstone Transient Shaper"},{"location":"community/powered-by-faust/#reverb-trickery","text":"A free, open source audio plugin implementing various creative reverb effects, including octave-shifted, distorted, hi-pass/low-passed, gated, and narrowing reverb, coded in Faust .","title":"Reverb Trickery"},{"location":"community/powered-by-faust/#b259wf","text":"This is a model of the \"tibre\" circuit of the Buchla 259 Complex Wave Generator, made in Faust . The model follows the circuit modelling as seen on the paper Virtual Analog Buchkla 259 wavefolder , using 5 folds. The proposed 2-point BLAMP antialiasing method has been attempted for arbitrary sources as shown here , but it is not sufficient for high frequencies and/or more complex signals. Instead, filtering and light cubic nonlinearity distiorion has been used to round corners and for clipping. The user interface consists of the controls fold for the folding amount, offset for offseting the signal before folding, and lowpass as a final stage one-pole filtering to control the character (too much folding might introduce unwanted higher harmonics for certain signals). The final output is dc-blocked.","title":"b259wf"},{"location":"community/powered-by-faust/#string-machine","text":"This is a virtual-analog string ensemble synthesizer. The implementation is based on a digital model designed by Peter Whiting. The improvement of the model adds various abilities, in particular a virtual-analog emulation of the bucket brigade delay circuit. Most of the DSP code is developed using Faust. Three VST or LV2 are generated: string-machine , string-machine-chorus and string-machine-chorus-stereo .","title":"string-machine"},{"location":"community/powered-by-faust/#metafx","text":"The metaFx is a control surface for continuous sound transformations in real time, just like the metaSurface64. Like metaSurface64 , it has both its own loop generator and a multi-effects FX engine, but its operation is different, especially for the management of plugin chains and pads. Each mixer on this surface can directly control the gain and the attached plug-ins. It is also possible to control the tracks of an external sequencer (Ardour or Reaper). To do this, the application uses OSC controllable modules that come from the Faust language library that is embedded in the application. Its interest lies in the construction of a parallel sound processing chain in the form of a graph.","title":"metaFx"},{"location":"community/powered-by-faust/#kymaticacom","text":"Jonatan Liljedahl at Kymatica AB makes iOS music apps, electronic music, and a little bit of audio hardware. The following iOS applications have DSP code developed using Faust: AU3FX:Push : AUv3 dynamics processor with noise gate, compressor/expander with external side-chain input, brick-wall look-ahead limiter and hard/soft clipper. AU3FX:Space : High quality tweakable AUv3 reverb with resonant filters. For everything between small rooms, resonators, and infinitely large spaces. AU3FX:Dub : Stereo AUv3 delay effect for everything from clean digital delays to filthy dub echoes, ping-pong flangers, and broken cassette tapes. AUFX:PeakQ : A versatile 4-band parametric stereo equalizer for everything between subtle frequency enhancements and agressive boosting/cutting or special resonator effects.","title":"Kymatica.com"},{"location":"community/powered-by-faust/#nemesis","text":"Nemesis is multichannel dsp platform for eurorack. It can be programmed with Faust .","title":"Nemesis"},{"location":"community/powered-by-faust/#sonobus","text":"SonoBus is an easy to use application for streaming high-quality, low-latency peer-to-peer audio between devices over the internet or a local network. Several DSP effects ( Compressor , Expander , Limiter , ParametricEQ , Reverb ) have been written in Faust , compiled as C++ code, and included in the JUCE project .","title":"Sonobus"},{"location":"community/powered-by-faust/#xplugslv2","text":"This repository contain the LV2 plugins developed using libxputty/XUidesigner. The included makfile allows the build of all plugins against a single checkout of libxputty. Each plugin exists as its own submodule under this repository. Some of the DSP code has been written with Faust.","title":"XPlugs.lv2"},{"location":"community/powered-by-faust/#bass-preamp-drive","text":"The goal of this project is to digitally reproduce the behavior of a well-known electric bass preamp: Ampeg SVT3 Pro. This preamp has been copied by several manufacturers. So we have an almost perfect copy with the Bugera BVP5500 which has four preamplifier tubes. An analog copy is also available as a pedal, the Tech 21 BDDI. The project is based on advances in the simulation of analog circuits made available by the Guitarix project and the excellent Faust from Grame cncm.","title":"Bass Preamp Drive"},{"location":"community/powered-by-faust/#drum-module","text":"This project aims at integrating a digital drum synthesizer using Faust and Miosix real time OS on an STM32F407VG Discovery Board. To do this, a user interface by means of buttons, sliders, encoders, and an LCD has been implemented to control the synthesizer. Moreover, a serial MIDI input port has been added in order to control the synthesizer externally by using an external sequencer or controller.","title":"Drum Module"},{"location":"community/powered-by-faust/#daisy-based-audio-boards","text":"Daisy is an embedded platform for music. It features everything you need for creating high fidelity audio hardware devices. Just plug in a USB cable and start making sound! No soldering required. It can be programed with Faust using the faust2daisy tool.","title":"Daisy based audio boards"},{"location":"community/powered-by-faust/#elk-audio-os","text":"Elk is an Audio Operating System developed from the ground up to deliver real time audio performances in embedded systems and remote networks. It can run on several hardware . Faust can be used to generate VST2 plugins to run on the plaform.","title":"Elk Audio OS"},{"location":"community/powered-by-faust/#er-301-sound-computer","text":"The ER-301 is a voltage-controllable canvas for digital signal processing algorithms. It can be programed with Faust using the faust2er301 tool and some units are developed here . Note that it is still a WIP, read the discussion here .","title":"ER-301 Sound Computer"},{"location":"community/powered-by-faust/#zynthian-platform","text":"Zynthian is a new class of musical device. A powerful multitimbral synthesizer and audio processor, capable of managing up to 16 audio chains simultaneously. Also, it's a MIDI processor and router, equipped with standard MIDI ports, USB, WIFI & wired networks. Zynthian is a community-driven project and it's 100% open source. The Zynthian platform can be programmed with Faust with some DSP examples here .","title":"Zynthian platform"},{"location":"community/powered-by-faust/#gxpluginslv2","text":"GxPlugins.lv2 is a set of more than 40 extra standalone lv2 plugins designed to compliment the Guitarix project. Each plugin exists as its own submodule under this repository. The DSP code has been written with Faust.","title":"GxPlugins.lv2"},{"location":"community/powered-by-faust/#stone-phaser","text":"A classic analog phaser effect. This is an analog phaser with similarity to the Small Stone. It has a color switch, which makes the phasing stronger when on, and adds some feedback controls. A stereo variant of the phaser is included. This effect is supported on MOD devices. The DSP code is developed in Faust .","title":"Stone phaser"},{"location":"community/powered-by-faust/#sfizz","text":"sfizz is a sample-based musical synthesizer. It features the well-established SFZ instrument format at its core, which permits to use existing instrument libraries, or create personal instruments with ease. Not only is sfizz ready-to-use as an instrument plugin of its own, the library allows developers to create instruments of their own, taking advantage of the abilities of SFZ. The sfizz project uses the SFZ parser and synth C++ library, providing AU/LV2/VST3 plugins and JACK standalone client. Some effects are developed in Faust are well as several filters .","title":"sfizz"},{"location":"community/powered-by-faust/#antescofo","text":"Antescofo is a coupling of a real-time listening machine with a reactive and timed synchronous language developed at IRCAM . The language is used for authoring of music pieces involving live musicians and computer processes, and the real-time system assures its correct performance and synchronization despite listening or performance errors. Antescofo audio DSP processes can be described with Faust , using libfaust dynamic version of the Faust compiler.","title":"Antescofo"},{"location":"community/powered-by-faust/#motion-vox","text":"A mobile music creation and performance workstation with a built-in motion-based controller, sequencer and synthesis engine. The controller unites XY pad, accelerometer and gyroscope events with complex data \ufb01ltering engine. Performance process consists of touching the active area on the screen with the index finger and moving the cursor while moving the device in space. Smartphone position in space and finger movement on a screen affect various parameters of sound or generate realtime MIDI output. The app was inspired by the SmartFaust project of GRAME. The audio engine of the app is made with Faust.","title":"Motion Vox"},{"location":"community/powered-by-faust/#inscore","text":"INScore is an open source framework for the design of interactive, augmented, live music scores. Augmented music scores are graphic spaces providing representation, composition and manipulation of heterogeneous and arbitrary music objects (music scores but also images, text, signals...), both in the graphic and time domains. Audio DSP processes and effects can be described using Faust. The environment runs as a native application but also in the Web. Faust programs are only supported by the online version .","title":"INScore"},{"location":"community/powered-by-faust/#virtual-rhizome","text":"By Vincent Carinola . Virtual Rhizome responds to a proposal by Christophe Lebreton and Jean Geoffroy to compose a work for the original Smart Hand Computer system, developed at the GRAME-CNCM using the Faust language and allowing to play smartphones as an instrument. The work takes the form of a labyrinth, a kind of virtual architecture that could be compared to Borges' \"garden of branching paths\", within which the musician evolves by adapting his gestures to the constraints of different types of situations. Each situation is characterized by an autonomous functioning of the system, that the musician must apprehend in order to find the key allowing him to modify it and to move towards another situation. But in order to orientate himself well, he must create a mental representation of the structure of the work. The performer then becomes an explorer of a world that he unveils, but isn't that what he has always been? Virtual rhizome owes much to the availability and enthusiasm of Jean Geoffroy and Christophe Lebreton. It is amicably dedicated to them.","title":"Virtual Rhizome"},{"location":"community/powered-by-faust/#smartfaust","text":"SmartFaust is a concept of musical applications for smartphones. These applications have the particularity of only using the user's gestures and not by tapping on the device's screen. Made for iOS and Android, they can also use the motion sensors of these devices to make them real musical instruments. Smartfaust applications are based on the Faust (Functional Audio Stream) programming language developed by Grame over the last 15 years and recognized as a standard in the field of real-time signal processing for audio. The SmartFaust applications were first used for the creation of the pieces Mephisto (for drums and cell phone ensemble), Belzebuth (participative piece for public equipped with Smartphones), Iblis (for clarinet and cell phone ensemble) and B\u00e9lial (for harp and cell phone ensemble) written by the composer Xavier Garcia. From this same technology were later created the applications \"Geek Bagatelles\" (2016) and \"GameLan\" (2019). Download here: Android & iOS","title":"SmartFaust"},{"location":"community/powered-by-faust/#trombone-simulator","text":"This simulator is a physical model of a trombone. Physical models of the lips, mouthpiece, slide, and bell are digitally simulated. The controls are listed at the top. The main controls are to move the cursor (or your finger on a touch device) left and right on the picture to adjust the embouchure, and up and down to extend and retract the slide. The diagonal colored lines are a guide to where the resonances are: playing over a resonance means that the embouchure and slide length are matched. Playing over white space means that one is between resonances and the note quality won't be as good. The big gray wedge on the upper right indicates that the resonances are very close together there. The vertical dashed lines indicate the rough locations of B-flat (thick lines) and F (thin lines). Other notes are unmarked, and likewise the slide positions. (Just like on a real trombone!) The off-key resonances (7th, 11th, 13th, and 14th) are marked in red. The g and f keys can be used to growl and flutter-tongue, respectively. The audio simulation is written in Faust, which conveniently compiles to WebAssembly and a Web Audio API wrapper. The overall approach used was a digital waveguide model, as described in J. O. Smith III's Digital Waveguide Theory. The lips and bell are adapted from F. Scott's masters thesis.","title":"Trombone Simulator"},{"location":"community/powered-by-faust/#integrating-1-dof-force-feedback-interactions-in-self-contained-dmis","text":"By Mathias Kirkegaard . This thesis presents a system for designers of Digital Musical Instruments (DMIs) to explore the integration of 1 degree of freedom (DoF) force feedback interactions in new self-contained instruments. The system developed consists of an open-source graphical tool and a rotary force-feedback device made from commercially available components to facilitate the authoring of audio-haptic applications. Implementing an early prototype is used to inform the development of the graphical editing tool and its integration in an embedded audio-haptic environment using the functional programming language Faust for real-time signal processing.","title":"Integrating 1-DoF force feedback interactions in self-contained DMIs"},{"location":"community/powered-by-faust/#beyond-key-velocity-continuous-sensing-for-expressive-control-on-the-hammond-organ-and-digital-keyboards","text":"By Giulio Moro . In this thesis we seek to explore the potential for continuous key position to be used as an expressive control in keyboard musical instruments, and how pre- existing skills can be adapted to leverage this additional control. The nonlinear waveguide physical model of a flute has been developed in Faust.","title":"Beyond Key Velocity: Continuous Sensing for Expressive Control on the Hammond Organ and Digital Keyboards"},{"location":"community/powered-by-faust/#guide-de-la-synthese-sonore","text":"By Sebastien Clara . In this guide, I try to demystify how sound synthesis works. To do so, I present the fundamental principles of sound synthesis. I accompany these explanations with small sound applications that you can manipulate in your web browser and thus, you will be able to notice the impact of a parameter on the sound. Most of the sound examples are written in Faust and run in the web pages. This guide is currently only in french.","title":"Guide de la synth\u00e8se sonore"},{"location":"community/powered-by-faust/#pico-dsp","text":"PICO DSP is an open-source, Arduino-compatible ESP32 development board for audio and digital signal processing (DSP) applications. It offers an expansive audio-processing feature set on a small-format, breadboard-friendly device that provides audio inputs, audio outputs, a low-noise microphone array, an integrated test-speaker option, additional memory, battery-charge management, and ESD protection all on one tiny PCB. The board can be programmed using Faust .","title":"PICO DSP"},{"location":"community/powered-by-faust/#soundjack","text":"The Soundjack realtime communication application is extended by a server cloud to handle up to 60 musicians of an orchestra, developed with the Faust programming language. Each musician is connected to a Soundjack UDP client. An individual stereo mix of the multiple audio streams originating from the multiple Soundjack clients has to be provided to each listening musician. An extended presentation of the system can be found in this IFC 2018 paper .","title":"Soundjack"},{"location":"community/powered-by-faust/#studiox-switcher","text":"Studiox-switcher is an input switcher and silence detector for JACK. It can switch between 3 stereo inputs, a fallback channel is activated if the active input is below a volume threshold for some amount of seconds, and channels may be switched via OSC and HTTP. The core DSP engine is done via Faust for switching, silence detection and level metering.","title":"studiox-switcher"},{"location":"community/powered-by-faust/#synthspace","text":"Synthspace is the ultimate virtual synthesizer. It combines the familiarity of real instruments with the possibilities of virtual worlds. Nodes for Synthspace can be developed in Faust .","title":"SynthSpace"},{"location":"community/powered-by-faust/#bass21","text":"This VST3 is a virtual-analog simulation of the famous Bass Driver DI Version 1 preamp pedal from Tech21. The discretization, while far from being exact, is moderately close to the original. The potentiometers are identical to these physically present on the BDDI pedal, apart from the pregain which is specific to this digital version. The DSP code is written in Faust.","title":"Bass21"},{"location":"community/powered-by-faust/#echomatrix","text":"The EchoMatrix was designed to provide some of the functionality of the Yamaha UD Stomp pedal as used be Alan Holdsworth. This project will be submitted to the KVR Developer Challenge 2021 contest to highlight the power of the Faust DSP development environment and the JUCE framework to create a non-trivial effect VST3 using a managable amount of Faust DSP code .","title":"EchoMatrix"},{"location":"community/powered-by-faust/#the-striso-board","text":"The Striso board is a very expressive music instrument which combines multidimensionally sensitive keys with an innovative note layout that helps understand the structures in music. The keys capture each subtle finger movement, which allows for levels of musical expression previously only known to acoustic instruments. Additionally, accents and sound effects can be added by shaking and moving the instrument as a whole. The internal sound is written in Faust, and is controlled directly by the signals from the keys and motion sensor. External synthesizers can be controlled using MPE MIDI, or using OSC which is easier to set up for Faust synthesizers. The firmware source code is released as open source.","title":"The Striso board"},{"location":"community/powered-by-faust/#live-concatenative-granular-processing","text":"This algorithm addresses signal discontinuity and concatenation artefacts in real-time granular processing with rectangular windowing. By combining zero-crossing synchronicity, first-order derivative analysis, and Lagrange polynomials, we can generate streams of uncorrelated and non-overlapping sonic fragments with minimal low-order derivatives discontinuities. The resulting open-source algorithm, implemented in the Faust language, provides a versatile real-time software for dynamical looping, wavetable oscillation, and granulation with reduced artefacts due to rectangular windowing and no artefacts from overlap-add-to-one techniques commonly deployed in granular processing.","title":"Live concatenative granular processing"},{"location":"community/powered-by-faust/#fb_suppression","text":"ALS - Automatic Larsen Suppression algorithms implementing adaptive filtering through spectral centroid calculation, and adaptive frequency shifting through RMS calculation.","title":"fb_suppression"},{"location":"community/powered-by-faust/#ossia-score","text":"Ossia score is a sequencer for audio-visual artists, designed to enable the creation of interactive shows, museum installations, intermedia digital artworks, interactive music and more in an intuitive user interface. Faust can be used to create advanced audio processes . A demo video of the Faust integration can be seen here .","title":"ossia score"},{"location":"community/powered-by-faust/#faselunare-microcosmos","text":"Microcosmos is a small open-source electronic board, developed by \u200bFaselunare (Italy), aimed at prototyping electronic musical instruments and learning electronics, microcontroller programming and audio DSP, and programmable with Faust. A demo video of the project can be seen here . The project has been presented at ADC21 .","title":"FASELUNARE Microcosmos"},{"location":"community/powered-by-faust/#audio-anywhere","text":"The goal of Audio Anywhere is to explore the idea of compile once, run anywhere for audio DSP code. Audio Anywhere combines Faust, for audio DSP code, and HTML5 to enable development of modern audio synthesis and effects tools. There are currently three main repos for this work: AA examples AA standalone app AA Wasmtime runtime","title":"Audio Anywhere"},{"location":"community/powered-by-faust/#the-keywi","text":"An Expressive and Accessible Electronic Wind Instrument, where the sound is synthesized with Faust running on the Bela Mini processing board.","title":"The KeyWi"},{"location":"community/powered-by-faust/#react-web-audio-guitar-studio","text":"React Web Audio Guitar Studio is an online real-time Web Audio based all-in-one guitar studio, using native plugins written on Faust, compiled on-demand, and ran in a browser.","title":"React Web Audio Guitar Studio"},{"location":"community/powered-by-faust/#jspatcher","text":"JSPatcher is a Visual Programming Language (VPL) in Max/PureData style on the web with following features: Patch WebAudio native AudioNodes Play with JavaScript Web APIs Import and patch external JavaScript modules Customize AudioWorklet DSPs with Faust A presentation video can be seen here .","title":"JSPatcher"},{"location":"community/powered-by-faust/#gwion","text":"Gwion is a programming language aimed at making music. It is strongly inspired by ChucK and can use a set of plugins for Gwion . One allows to use the libfaust library to JIT compile and run DSP code on the fly. The faust2gw tool allows to produce statically compiled modules.","title":"Gwion"},{"location":"community/powered-by-faust/#sonejostudios","text":"A set of tools written using Faust.","title":"sonejostudios"},{"location":"community/powered-by-faust/#panoramix","text":"Stereo Panorama/Balance and Volume Automation Tool.","title":"Panoramix"},{"location":"community/powered-by-faust/#mixer4x","text":"A simple 4-channel stereo mixer. The main goal is to use it as a submixer on a 4 channel track, but you can use it everywhere you need a small 4 channel stereo mixer.","title":"Mixer4x"},{"location":"community/powered-by-faust/#faustdrumseq","text":"A very simple drum sequencer written with Faust, using the new soundfile object.","title":"faustdrumseq"},{"location":"community/powered-by-faust/#midiclockclick","text":"A simple metronom driven by MidiClock.","title":"MidiClockClick"},{"location":"community/powered-by-faust/#superbeatrepeater","text":"Beat Repeater with Sidechain Beat Recognation and Midi-Clock Sync. Very useful i.e to add musical diversity by looping short parts of the stream (i.e drums).","title":"SuperBeatRepeater"},{"location":"community/powered-by-faust/#supercutsequencer","text":"Cut \"On/Off\" Sequencer (8 steps with smooth) synced to Midi-Clock Beats and Midi-Clock Start/Stop. Very useful i.e to add musical diversity in looped tracks (very nice with i.e bass lines).","title":"SuperCutSequencer"},{"location":"community/powered-by-faust/#delooper","text":"Sample-accurate Looper/Delay with free mode and midi-clock sync mode.","title":"DeLooper"},{"location":"community/powered-by-faust/#xymatrix","text":"XY Surround Matrix for one Source (Mono Input) with 4 Outputs (Left, Right, Surround Left, Surround Right) and Position Lock.","title":"XYMatrix"},{"location":"community/powered-by-faust/#stm32-faust-synth","text":"STM32 synthesizer video is a short presentation of a polyphonic synthesizer based on STM32F405 \u00b5C. Faust is used for signal processing and a TLV320AIC23B stereo codec serves as DAC. Another more recent video is here .","title":"stm32-faust-synth"},{"location":"community/powered-by-faust/#faustgen2","text":"The faustgen2~ object is a Faust external for Pd a.k.a. Pure Data , Miller Puckette's interactive multimedia programming environment.","title":"faustgen2~"},{"location":"community/powered-by-faust/#amati","text":"Amati is a VST plugin for live-coding effects in the Faust programming language. As of now it only provides basic functionality.","title":"Amati"},{"location":"community/powered-by-faust/#puretones","text":"PureTones PureTones is a family of software tools for Indian Classical music. They are built based on an in-depth study and exploration of Indian Classical music to understand the role of harmonics, microtones and consonance in Indian Ragas and musical scales: PureTones Drone (using first tab) , is a digital Tanpura with controls for fine tuning the strings and adjusting their harmonic envelope. PureTones Musical Scale (using second tab) is a digital 12 note keyboard with controls for fine tuning each key to be consonant with an accompanying drone track. PureTones Sequencer (using third tab) is a sequencer which enables composition of melodies and musical works in Indian Classical music using notes from a fine tuned musical scale. The Ragatronics project combines Ragas from Indian Classical music with elements from Rock, Jazz and Electronic music. All applications have been developed using Faust and WebAudio tools.","title":"PureTones"},{"location":"community/powered-by-faust/#making-sound-machines","text":"Making Sound Machines are a duo of makers from D\u00fcsseldorf, Germany. We build kits, modules and DIY projects, and use the projects we\u2019ve built to make music. Faust is used in several projects.","title":"Making Sound Machines"},{"location":"community/powered-by-faust/#master_me","text":"Automatic audio mastering plugin for live-streaming, podcasting and internet radio stations. With the first Covid-19 related lock-downs in 2020, many real-life concerts, conferences and festivals were forced into the digital domain - and sounded pretty crappy. Having worked for almost 20 years in audio mastering, Berlin based engineer Klaus Scheuermann started to develop master_me - a word fusion of automatic mastering and mini-me - in order to make open source streaming sound better. After a few weeks of learning and development, master_me was first used at the 'Quarantine Sessions' - a weekly distributed electro-acoustic improvised concert, hosted at Stanford's CCRMA Institute. master_me was developed further to be an easy-to-use tool for all live streaming applications. In 2022 it was funded by the Prototype Fund, an open source software funding initiative by the german ministry of education and research. A stable release is available since September 2022.","title":"master_me"},{"location":"community/powered-by-faust/#metasurface64","text":"metaSurface64 is a real-time continuous sound transformation control surface that features both its own loop generator for up to 64 voices and a multi-effects FX engine. The application embeds the libfaust dynamic version of the Faust compiler.","title":"metaSurface64"},{"location":"community/powered-by-faust/#fragment-audio-server-and-fragment","text":"Fragment Audio Server (FAS) is a high performance pixels-based graphical audio synthesizer implemented as a WebSocket server with the C language (C11). Faust , is embedded (when compiled with WITH_FAUST ) and allow to dynamically extend FAS bank generators and effects with custom one written with the Faust DSP specification language. FAS is the audio engine used in Fragment , the Collaborative Graphical Audio Synthesizer. Follow the demo here .","title":"Fragment Audio Server and Fragment"},{"location":"community/powered-by-faust/#swanky-amp","text":"Swanky Amp is a tube amplifier simulation DSP plugin which aims to capture the details in the dynamics of tube amplifiers. The DSP is primarily written in Faust , whereas the UI is written in C++ using the JUCE . Follow the demo here . A commercial version is available here .","title":"Swanky Amp"},{"location":"community/powered-by-faust/#web-synth","text":"This is a web-based DAW (Digital Audio Workstation) written in Rust/WebAssembly and TypeScript with extensive Faust language integration with dynamic remote code compilation and executing via WebAssembly. Follow the demo here .","title":"Web Synth"},{"location":"community/powered-by-faust/#dawdreamer","text":"DawDreamer is an audio-processing Python framework supporting core DAW features such as audio playback, VST MIDI instruments, VST effects, Faust , and parameter automation. DawDreamer is written with JUCE , with a user-friendly Python interface thanks to pybind11 . DawDreamer draws from an earlier VSTi audio \"renderer\", RenderMan .","title":"DawDreamer"},{"location":"community/powered-by-faust/#td-faust","text":"TD-Faust enables Faust code to run inside TouchDesigner . Follow the demo here .","title":"TD-Faust"},{"location":"community/powered-by-faust/#mephisto-lv2","text":"Mephisto LV2 a Just-in-Time Faust compiler embedded in an LV2 plugin. Write LV2 audio/cv instruments/filters directly in your host in Faust DSP language without any need to restart/reload host or plugin upon code changes.","title":"Mephisto LV2"},{"location":"community/powered-by-faust/#iplug2","text":"iPlug 2 is a simple-to-use C++ framework for developing cross platform audio plug-ins/apps and targeting multiple plug-in APIs with the same minimalistic code, support for the Faust programming language, and the libfaust JIT compiler.","title":"iPlug2"},{"location":"community/powered-by-faust/#pmix","text":"pMix (short for preset mixer) is a sound design, composition and performance tool that facilitates the control of multiple parameters using an intuitive graphical interface. It includes a graphical patcher for creating a network of audio synthesis or processing nodes. A node could be a VST2, VST3, AU or LADSPA plug-in or it could a JIT compiled Faust script. Faust is a first class citizen in pMix and an integrated code editor and SVG display makes it a nice environment for Faust development.","title":"pMix"},{"location":"community/powered-by-faust/#temper-juce-plugin","text":"Temper is a digital distortion audio plugin targeting VST, VST3, and AU for OS X and Windows. It builds upon traditional waveshaping techniques using modulated filter coefficients to produce a unique phase distortion. The primary signal processing loop is written with Faust, and compiled with JUCE for the various build targets.","title":"Temper JUCE plugin"},{"location":"community/powered-by-faust/#faust-mass-interaction","text":"mi_faust implements 1D mass-interaction models in the Faust programming language. Starting from a scripted model description (see MIMS), mi_faust compiles a physical model into Faust code. It handles this by generating routing functions between all the masses and all the interactions in the model. Head over to the FAUST community page to see examples of a series of instruments created in mi_faust, and available as web-apps !","title":"Faust Mass-Interaction"},{"location":"community/powered-by-faust/#dynamic-pedalboard","text":"Dynamic PedalBoard allows users to plug different stompboxes together in a web browser.","title":"Dynamic PedalBoard"},{"location":"community/powered-by-faust/#sharc-dsp-board","text":"The ADI SHARC DSP board fully supports Faust.","title":"SHARC DSP Board"},{"location":"community/powered-by-faust/#nuance","text":"Nuance is a pressure sensitive music controller that uses Faust for sound synthesis and processing.","title":"Nuance"},{"location":"community/powered-by-faust/#the-plateaxe","text":"The PlateAxe is a percussion instrument physical model controller using Faust for sound synthesis and processing.","title":"The PlateAxe"},{"location":"community/powered-by-faust/#the-bladeaxe","text":"The BladeAxe is an electric guitar physical model controller using Faust for sound synthesis and processing.","title":"The BladeAxe"},{"location":"community/powered-by-faust/#bart-brouns-projects","text":"A collection of projects by Bart Brouns and based on Faust.","title":"Bart Brouns' Projects"},{"location":"community/powered-by-faust/#eartone-toolbox","text":"The Ear Tone Toolbox is a collection of unit generators for the production of auditory distortion product synthesis.","title":"EarTone Toolbox"},{"location":"community/powered-by-faust/#audiokit","text":"AudioKit allows developers to quickly add professional audio functionality to iOS, macOS, and Apple Watch apps.","title":"AudioKit"},{"location":"community/powered-by-faust/#radium","text":"Radium is a music editor with a new type of interface. It includes a Faust audio DSP development environment. Compared to the normal sequencer interface editing is quicker and more musical data fits on the screen. Compared to trackers, note positions and effects are edited graphically, which should be quicker, provide more vertical space and give a better musically overview. (Everything can also be edited by text, like in a normal tracker) Radium can also be used as a normal multitracker to mix and record audio.","title":"Radium"},{"location":"community/powered-by-faust/#bela","text":"Bela is a maker platform for creating beautifully responsive audio and interactive applications. Designed for artists, musicians, researchers and makers, Bela brings the power of ultra-low latency interactive audio and sensors to your digital projects. It can be programmed with Faust .","title":"BELA"},{"location":"community/powered-by-faust/#hoa-library","text":"HOA Library allows musicians and composers to synthesize, transform and render sound fields in a creative and artistic way. This library facilitates the understanding and the appropriation of key concepts of ambisonics. Thanks to original graphical interfaces a lot of new signal processings are allowed like diffuse sound field synthesis, perspective distorsion or spatial filtering. HOA library is open-source and free and offers a set of C++ and FAUST classes and implementation for Max, PureData and Unity.","title":"HOA Library"},{"location":"community/powered-by-faust/#ambitools","text":"Ambitools is a collection of plug-ins and tools for 3D sound field synthesis using Higher Order Ambisonics (HOA). The plugins are written in the Faust language , which allows them to be compiled for a multitude of architectures and platforms (Windows, Mac, Linux, WebAudio, embedded systems, etc.) Moreover, the code is written in a scalable way: there is no limit to the maximum Ambisonic order! Other tools are also available, such as a 3D Visualizer written in the Processing language.","title":"Ambitools"},{"location":"community/powered-by-faust/#ambisonic-decoder-toolbox","text":"The Ambisonic Decoder Toolbox is a collection of MATLAB and GNU Octave functions for creating Ambisonic Decoders. Currently, it implements: (1) the AllRAD design technique, (2) inversion or mode-matching, (3) truncated mode-matching, constant energy, (4) linear combinations of 2 and 3, and (5) Slepian function basis (EPAD). The DSP code is written in MATLAB and Faust.","title":"Ambisonic Decoder Toolbox"},{"location":"community/powered-by-faust/#ambisonicxyz","text":"A set of tools around Ambisonics.","title":"Ambisonic.xyz"},{"location":"community/powered-by-faust/#faustpy","text":"FaustPy is a Python wrapper for Faust. It is implemented using the CFFI and hence creates the wrapper dynamically at run-time.","title":"FaustPy"},{"location":"community/powered-by-faust/#rebel-technology","text":"The OWL Pedal is an open source, programmable stage effects pedal, made for guitarists, musicians, hackers and programmers. Users can program their own effects, or download ready-made patches from our growing online patch library.","title":"Rebel Technology"},{"location":"community/powered-by-faust/#faust-vst","text":"This project provides a VST plugin architecture for the Faust programming language. The package contains the Faust architecture, faustvst.cpp, the faust2faustvst helper script which provides a quick way to compile a plugin, a collection of sample plugins written in Faust, and a generic GNU Makefile for compiling and installing the plugins.","title":"faust-vst"},{"location":"community/powered-by-faust/#faust-lv2","text":"This project provides an LV2 plugin architecture for the Faust programming language. The package contains the Faust architecture and templates for the needed LV2 manifest (ttl) files, a collection of sample plugins written in Faust, and a generic GNU Makefile as well as a shell script to compile plugins using the architecture.","title":"faust-lv2"},{"location":"community/powered-by-faust/#rdk","text":"Reverb Design is about creating a spacial impression aimed at sweetening the listening experience for a given context. The ambiguity of auditory and visual cues in reproduced sound makes it necessary to create an auditory illusion: To make this illusion work, I propose an aesthetic concept of simplicity and intelligibility based on psychoacoustic facts and recording practice as professional producer.","title":"RDK"},{"location":"community/powered-by-faust/#foo-yc20","text":"The Foo YC20 is an open source implementation of the Yamaha YC-20 combo organ from 1969. Processing for the organ is based on original schematics and measurements from a working specimen. This instrument simulates the circutry as a whole to realisticly reproduce the features and flaws of the real deal.","title":"Foo YC20"},{"location":"community/powered-by-faust/#fauck","text":"FaucK is a Chugin allowing to combine the powerful, succinct Functional AUdio STream (Faust) language with the strongly-timed ChucK audio programming language. FaucK allows programmers to on-the-fly evaluate Faust code directly from ChucK code and control Faust signal processors using ChucK's sample-precise timing and concurrency mechanisms. The goal is to create an amalgam that plays to the strengths of each language, giving rise to new possibilities for rapid prototyping, interaction design and controller mapping, pedagogy, and new ways of working with both Faust and ChucK.","title":"FaucK"},{"location":"community/powered-by-faust/#snd-rt","text":"Snd-RT is the realtime extension for the sound editor SND and consists of two parts: the RT Engine - An engine for doing realtime signal processing. the RT Compiler - A compiler for a scheme-like programming language to generate realtime-safe code understood by the RT Engine.","title":"Snd-RT"},{"location":"community/powered-by-faust/#pure-language","text":"Pure is a modern-style functional programming language based on term rewriting. It offers equational definitions with pattern matching, full symbolic rewriting capabilities, dynamic typing, eager and lazy evaluation, lexical closures, built-in list and matrix support and an easy-to-use C interface. The interpreter uses LLVM as a backend to JIT-compile Pure programs to fast native code. It has been created by Albert Gr\u00e4f. pd-faust is a collection of Pd objects written using pd-pure which lets you run Faust programs inside Pd. It combines the functionality of pure-faust and faust2pd in a single package, and also features dynamic reloading of Faust plugins, automatic generation of controller GUIs and MIDI/OSC controller mappings, as well as OSC-based controller automation. It thus provides a complete solution for interactively developing Faust dsps in Pd.","title":"Pure Language"},{"location":"community/powered-by-faust/#guitarix","text":"An audio plug-in for guitar effects whose sound processing engine is written in Faust.","title":"Guitarix"},{"location":"community/powered-by-faust/#moforte-geoshred","text":"An electric guitar app using physical modeling. Faust was used to implement its sound synthesis/processing engine.","title":"moForte GeoShred"},{"location":"community/powered-by-faust/#moforte-powerstomp","text":"An app implementing various guitar effects to be used on stage.","title":"moForte PowerStomp"},{"location":"community/powered-by-faust/#moforte-guitar","text":"An app that can be used as an electric guitar and whose sound synthesis engine is implemented in Faust.","title":"moForte Guitar"},{"location":"community/powered-by-faust/#faustworks","text":"FaustWorks is an IDE (Integrated Development Environment) for the Faust dsp programming language. You must have Faust installed to be able to use FaustWorks. Platforms supported are Linux and OSX.","title":"FaustWorks"},{"location":"community/powered-by-faust/#faustlive","text":"FaustLive is an advanced self-contained prototyping environment for the Faust programming language with an ultra-short edit-compile-run cycle. Thanks to its fully embedded compilation chain, FaustLive is simple to install and doesn't require any external compiler, development toolchain or SDK to run. FaustLive is the ideal tool for fast prototyping. Faust programs can be compiled and run on the fly by simple drag and drop. They can even be edited and recompiled while running, without sound interruption. It supports also native applications generation using the Faust online compiler. FaustLive is based on the Faust library and on LLVM. \u200b","title":"FaustLive"},{"location":"community/press/","text":"Faust in the Press 2018 CDM, Vadim is a master of the dark arts of DSP \u2013 listen to him explain filters , October 19, 2018. France Musique, Bernard Cavanna, compositeur agit\u00e9 ! - Albums \"\u00c0 l\u2019agit\u00e9 du bocal\" & \"Le caillou dans la chaussure\" , October 10, 2018. BNEWS, \u0426\u0438\u0444\u0440\u043e\u0432\u0430\u044f \u043e\u0441\u0435\u043d\u044c \u0432 \u0410\u043b\u043c\u0430\u0442\u044b: \u041c\u043e\u043b\u043e\u0434\u044b\u0435 \u043c\u0443\u0437\u044b\u043a\u0430\u043d\u0442\u044b \u0438\u0441\u043f\u043e\u043b\u043d\u0438\u043b\u0438 \u0441\u043e\u0432\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435 \u043f\u0440\u043e\u0438\u0437\u0432\u0435\u0434\u0435\u043d\u0438\u044f \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e \u0433\u0430\u0434\u0436\u0435\u0442\u043e\u0432 , October 18, 2018. iProfesional, Una orquesta sinf\u00f3nica dara un concierto en Buenos Aires junto a un coro de \"smartphones\" , October 06, 2018. SWR Aktuell Rheinland-Pfalz, Programmiersprache macht digitale T\u00f6ne , July 17, 2018. Deutschlandfunk, F\u00fcr einen Mathematiker ist das der Himmel , July 21, 2018. Deutschlandfunk, Radio-Premiere f\u00fcr die Zarenglocke , July 21, 2018. Piekary, Ch\u00f3r\u2026smarfon\u00f3w w Filharmonii \u015al\u0105skiej , May 10, 2018. Tribune de Gen\u00e8ve, Quand smartphones et orchestre s\u2019accordent , March 22, 2018. MDR Th\u00fcringen, Jenaer Philharmonie spielt Smartphone-Konzert , February 26, 2018. iDNES.cz, VIDEO: Filharmonici p\u0159izvali na p\u00f3dium studenty, zahr\u00e1li na sv\u00e9 mobily , February 16, 2018. 2017 Le Dauphin\u00e9 Lib\u00e9r\u00e9, https://www.ledauphine.com/isere-nord/2017/10/28/rejoignez-l-orchestre-de-smartphones , October 28, 2017. Wired.it, Geek Bagatelles, il concerto per orchestra e smartphone , October 18, 2017. Tecnologia, Geek Bagatelles. Al Romaeuropa Festival il concerto per orchestra e coro di smartphone , October 12, 2017. Capital avec Management, Musique et Entreprise : la M\u00e9thode Gagnante de la Soci\u00e9t\u00e9 G\u00e9n\u00e9rale , April 17, 2017. France Info, Fl\u00fbte pr\u00e9historique et ch\u0153ur de smartphones, l\u2019Orchestre de Picardie innove , February 07, 2017. France Info, La smartophonie : quand le portable devient instrument de musique , January 24, 2017. 2016 France Info, SmartFaust, l'application qui transforme les portables en instruments , December, 6, 2016. Le Parisien, \"SmartFaust\", des applis pour jouer de la musique avec son portable , March 26, 2016.","title":"Press"},{"location":"community/press/#faust-in-the-press","text":"","title":"Faust in the Press"},{"location":"community/press/#2018","text":"CDM, Vadim is a master of the dark arts of DSP \u2013 listen to him explain filters , October 19, 2018. France Musique, Bernard Cavanna, compositeur agit\u00e9 ! - Albums \"\u00c0 l\u2019agit\u00e9 du bocal\" & \"Le caillou dans la chaussure\" , October 10, 2018. BNEWS, \u0426\u0438\u0444\u0440\u043e\u0432\u0430\u044f \u043e\u0441\u0435\u043d\u044c \u0432 \u0410\u043b\u043c\u0430\u0442\u044b: \u041c\u043e\u043b\u043e\u0434\u044b\u0435 \u043c\u0443\u0437\u044b\u043a\u0430\u043d\u0442\u044b \u0438\u0441\u043f\u043e\u043b\u043d\u0438\u043b\u0438 \u0441\u043e\u0432\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435 \u043f\u0440\u043e\u0438\u0437\u0432\u0435\u0434\u0435\u043d\u0438\u044f \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e \u0433\u0430\u0434\u0436\u0435\u0442\u043e\u0432 , October 18, 2018. iProfesional, Una orquesta sinf\u00f3nica dara un concierto en Buenos Aires junto a un coro de \"smartphones\" , October 06, 2018. SWR Aktuell Rheinland-Pfalz, Programmiersprache macht digitale T\u00f6ne , July 17, 2018. Deutschlandfunk, F\u00fcr einen Mathematiker ist das der Himmel , July 21, 2018. Deutschlandfunk, Radio-Premiere f\u00fcr die Zarenglocke , July 21, 2018. Piekary, Ch\u00f3r\u2026smarfon\u00f3w w Filharmonii \u015al\u0105skiej , May 10, 2018. Tribune de Gen\u00e8ve, Quand smartphones et orchestre s\u2019accordent , March 22, 2018. MDR Th\u00fcringen, Jenaer Philharmonie spielt Smartphone-Konzert , February 26, 2018. iDNES.cz, VIDEO: Filharmonici p\u0159izvali na p\u00f3dium studenty, zahr\u00e1li na sv\u00e9 mobily , February 16, 2018.","title":"2018"},{"location":"community/press/#2017","text":"Le Dauphin\u00e9 Lib\u00e9r\u00e9, https://www.ledauphine.com/isere-nord/2017/10/28/rejoignez-l-orchestre-de-smartphones , October 28, 2017. Wired.it, Geek Bagatelles, il concerto per orchestra e smartphone , October 18, 2017. Tecnologia, Geek Bagatelles. Al Romaeuropa Festival il concerto per orchestra e coro di smartphone , October 12, 2017. Capital avec Management, Musique et Entreprise : la M\u00e9thode Gagnante de la Soci\u00e9t\u00e9 G\u00e9n\u00e9rale , April 17, 2017. France Info, Fl\u00fbte pr\u00e9historique et ch\u0153ur de smartphones, l\u2019Orchestre de Picardie innove , February 07, 2017. France Info, La smartophonie : quand le portable devient instrument de musique , January 24, 2017.","title":"2017"},{"location":"community/press/#2016","text":"France Info, SmartFaust, l'application qui transforme les portables en instruments , December, 6, 2016. Le Parisien, \"SmartFaust\", des applis pour jouer de la musique avec son portable , March 26, 2016.","title":"2016"},{"location":"community/publications/","text":"Academic Publications Around Faust This page presents a non-exhaustive list of publications around the Faust programming language. If you think one of your papers is missing, let us know and we'll add it! menuholder","title":"Academic Publications"},{"location":"community/publications/#academic-publications-around-faust","text":"This page presents a non-exhaustive list of publications around the Faust programming language. If you think one of your papers is missing, let us know and we'll add it!","title":"Academic Publications Around Faust"},{"location":"community/publications/#menuholder","text":"","title":"menuholder"},{"location":"community/sponsors/","text":"Faust Sponsors","title":"Sponsors"},{"location":"community/sponsors/#faust-sponsors","text":"","title":"Faust Sponsors"}]}